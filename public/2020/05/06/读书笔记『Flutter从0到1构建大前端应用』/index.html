<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>读书笔记『Flutter从0到1构建大前端应用』 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一章 Flutter简介P4：Flutter Engine  Skia：2D渲染引擎(Android系统自带，iOS系统不自带，因此iOS包所占用的存储空间更大) Dart：Dart运行时 Text：文本排版引擎  第二章 Dart 语言入门P18：Dart是一门强类型语言，在第一次赋值时，如果已经确定了是字符串类型，则不能更改为别的类型。如果真的想要改变，可以使用dynamic关键字。 P19">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记『Flutter从0到1构建大前端应用』">
<meta property="og:url" content="http://yoursite.com/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 Flutter简介P4：Flutter Engine  Skia：2D渲染引擎(Android系统自带，iOS系统不自带，因此iOS包所占用的存储空间更大) Dart：Dart运行时 Text：文本排版引擎  第二章 Dart 语言入门P18：Dart是一门强类型语言，在第一次赋值时，如果已经确定了是字符串类型，则不能更改为别的类型。如果真的想要改变，可以使用dynamic关键字。 P19">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-06T04:29:29.217Z">
<meta property="article:modified_time" content="2020-05-11T15:11:55.500Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Flutter">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-读书笔记『Flutter从0到1构建大前端应用』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/" class="article-date">
  <time datetime="2020-05-06T04:29:29.217Z" itemprop="datePublished">2020-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      读书笔记『Flutter从0到1构建大前端应用』
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-Flutter简介"><a href="#第一章-Flutter简介" class="headerlink" title="第一章 Flutter简介"></a>第一章 Flutter简介</h3><p><strong>P4</strong>：Flutter Engine</p>
<ul>
<li>Skia：2D渲染引擎(Android系统自带，<strong>iOS系统不自带，因此iOS包所占用的存储空间更大</strong>)</li>
<li>Dart：Dart运行时</li>
<li>Text：文本排版引擎</li>
</ul>
<h3 id="第二章-Dart-语言入门"><a href="#第二章-Dart-语言入门" class="headerlink" title="第二章 Dart 语言入门"></a>第二章 Dart 语言入门</h3><p><strong>P18</strong>：Dart是一门强类型语言，在第一次赋值时，<strong>如果已经确定了是字符串类型，则不能更改为别的类型</strong>。如果真的想要改变，可以使用<strong>dynamic</strong>关键字。</p>
<p><strong>P19</strong>：num声明的变量可以加入的是int型，还可以被改成double型，但是反过来int声明的变量不能再赋值为double。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">30.2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>P23</strong>：使用bool表示布尔值，布尔值只有true和false；可以在debug模式下通过assert断言判断布尔值</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(a.isEmpty);</span><br></pre></td></tr></table></figure>

<p>创建一个不可变数组，使用const[…]</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><strong>P25</strong>：<font color="#dd0000"><strong>使用dynamic时会告诉编译器，我们不用做类型检测，并且知道自己在做什么。</strong></font></p>
<p><strong>P26</strong>：可以使用as，is关键字对类型进行检测</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> obj = &lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt;) &#123;</span><br><span class="line">  obj[<span class="string">'age'</span>] = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>~/ 除法，返回一个整数结果</strong></font></p>
<a id="more"></a>

<p><strong>级联操作符</strong>：有点类似一些语言的链式调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>()</span><br><span class="line">  	..write(<span class="string">'a'</span>)</span><br><span class="line">  	..write(<span class="string">'b'</span>).toString();</span><br></pre></td></tr></table></figure>

<p><strong>P28-29</strong>：函数Function</p>
<p>可选参数，可选的命名参数，即不传这些参数也可以。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> userSettings(&#123;<span class="built_in">int</span> age,<span class="built_in">String</span> name&#125;) <span class="comment">//可选参数使用&#123;&#125;包括</span></span><br></pre></td></tr></table></figure>

<p>必传参数，使用@required修饰</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> userSettings(&#123;<span class="meta">@required</span> <span class="built_in">int</span> age,<span class="built_in">String</span> name&#125;)</span><br></pre></td></tr></table></figure>

<p>可选的位置参数</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> userSettings(&#123;<span class="built_in">int</span> age,<span class="built_in">String</span> name,[<span class="built_in">String</span> interests]&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span>(interests != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数，默认值是编译时常量</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> userSettings(&#123;<span class="built_in">int</span> age = <span class="number">21</span>,<span class="built_in">String</span> name=<span class="string">'小米'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>P31</strong>：一个Future表示一个异步操作产生的的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">int</span>&gt; future = getFuture();</span><br><span class="line">future.then((value) =&gt; handleValue(value)) <span class="comment">//then用于接受异步处理的结果</span></span><br><span class="line">  .catchError((error) =&gt; handleError(error)) <span class="comment">//catchError用于捕获异常</span></span><br><span class="line">  .whenComplete() =&gt; handleComplete(); <span class="comment">//whenComplete用于处理执行结束的回调，无论是否异常都会执行</span></span><br></pre></td></tr></table></figure>

<p>then用于接受异步处理的结果；catchError用于捕获异常；whenComplete用于处理执行结束的回调，无论是否异常都会执行</p>
<p>当有需要有延迟的运算(async)时，可以将其放到队列(await)中去，注意：<font color="#dd0000"><strong>await必须在async标记的函数中运行，否则会报错。</strong></font>async和await用于解决嵌套回调等问题：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">steps() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> step1Res = <span class="keyword">await</span> step1(<span class="string">'step1'</span>);</span><br><span class="line">    <span class="built_in">String</span> step2Res = <span class="keyword">await</span> step2(step1Res);</span><br><span class="line">    <span class="built_in">String</span> step3Res = <span class="keyword">await</span> step1(step2Res);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P32</strong>：<strong>Flutter的继承也是单继承的(extends)</strong>，因为Flutter没有访问修饰符，所以子类可以访问父类中所有的变量和方法；<font color="#dd0000"><strong>Flutter中每个类都是一个隐式的接口，这个接口包含类中所有的成员变量和方法</strong></font>。当类被当做接口使用时，类中的方法需要在子类中被实现。</p>
<p><font color="#dd0000"><strong>P34：</strong></font>Dart新增的mixins语法特性，作用是<strong>可以在类中混入其他功能。</strong>具体的讲，就是把<font color="#dd0000"><strong>自己的方法提供给其他类使用，但却不需要成为其他类的父类，它以非继承的方式来复用代码</strong></font>。使用mixins，需要使用with关键字。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CanFixComputer</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">void</span> fixComputer() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'软件工程师修电脑'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITTeacher</span> <span class="title">with</span> <span class="title">CanFixComputer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> fixComputer() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'IT老师修电脑'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###第三章 一切皆组件</p>
<p>P40**：从布局来看，官方把Flutter布局分为Basic Widget、Single-Child、Multi-Child。</p>
<p><strong>P58</strong>：Scaffold是基于<strong>Material库</strong>的一个<strong>与路由相关</strong>的模板组件，可以认为是Flutter提供的标准化的布局容器。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">  	AppBar:...</span><br><span class="line">    body:...</span><br><span class="line">    bottomNavigationBar:...</span><br><span class="line">    floatingActionButton:...</span><br><span class="line">    drawer:...</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P62</strong>：Column是不支持滚动的，如果需要实现滚动功能，则需要考虑使用ListView。</p>
<p><strong>P76</strong>：使用Wrap替换Row可以实现自动换行的效果。</p>
<p><strong>P79</strong>：Context表示组件上下文的意思。<strong>通过Context可以遍历和查找当前Widget树</strong>。</p>
<p><font color="#dd0000"><strong>P80：</strong></font>StatelessWidget即无状态的Widget，它<font color="#dd0000"><strong>无法通过setState设置组件的状态</strong></font>。对于其内部属性，应该被声明为final，防止被意外修改。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatelessWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MyStatelessWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.parameter,</span><br><span class="line">  &#125;):<span class="keyword">super</span>(key:Key),</span><br><span class="line">  <span class="keyword">final</span> parameter;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StatefulWidget即有状态Widget。创建一个StatefulWidget组件时，<strong>会同时创建一个State对象</strong>，并且StatefulWidget通过与State关联可以达到刷新UI的目的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyStatefulWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.color,</span><br><span class="line">  &#125;):<span class="keyword">super</span>(key:key),</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Color color;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  _MyStatefulWidgetState createState() =&gt; <span class="keyword">new</span> _MyStatefulWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyStatefulWidget</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P82</strong>：生命周期</p>
<p><strong>initState</strong>是State生命周期里第一个被执行的方法，可以在该方法进行一些初始化动作。<font color="#dd0000"><strong>在initState里，Framework层还没有把Context和State关联在一起，所以还不能访问Context。初始化方法在生命周期里只会被执行一次。</strong></font></p>
<p><strong>didChangeDependencies</strong>：在执行完initState之后就可以访问Context了。如果Widget使用了InheritedWidget的数据，并且在InheritedWidget的数据发生改变时，Flutter Framework就会触发didChangeDependencies的回调。</p>
<p><strong>build</strong>：在执行完didChangeDependencies之后，<font color="#dd0000"><strong>每次调用setState都会触发build方法。</strong></font></p>
<p><strong>dispose</strong>：在组件被销毁时调用。</p>
<p>![img](<a href="http://47.110.40.63:8080/img/blog/Flutter" target="_blank" rel="noopener">http://47.110.40.63:8080/img/blog/Flutter</a> State生命周期.png)</p>
<p><font color="#dd0000"><strong>P88</strong></font>：在Flutter中，每个Widget都有一个唯一标识Key，在创建和渲染时生成，可以手动指定。在某些场景下，需要保存Key，<strong>可以保存到GlobalKey、LocalKey、UniqueKey、ObjectKey中</strong>，可以根据key找到的对应的Widget。</p>
<p><strong>P89</strong>：被InheritedWidget暴露出来的数据，可以高效地在Widget树中<strong>从上往下</strong>传递和共享，并支持<strong>跨级</strong>数据传递。</p>
<h3 id="第四章-事件处理"><a href="#第四章-事件处理" class="headerlink" title="第四章 事件处理"></a>第四章 事件处理</h3><p><strong>P100</strong>：原始指针事件，把Listener包裹在需要监听的组件外来实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  body:Center(</span><br><span class="line">  	child:Listener(</span><br><span class="line">    	child:Container()</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p><strong>P102</strong>：可以使用IgnorePoiner和AbsorbPointer对事件进行忽略，前者本身可以接受事件，后者本身也不可接收事件。</p>
<p><strong>P105</strong>：GestureDetector可以支持更丰富的事件，如缩放、双击、垂直、水平的手势。同样需要包裹在要监听的组件外面。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector (</span><br><span class="line">	onTap:() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'tap'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child:Container()...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>P112</strong>：事件竞争和手势冲突</p>
<p>Flutter加入了<strong>手势竞技场</strong>的概念。在给同一个组件同时添加水平和垂直回调时，若用户将指针水平移动超过一定的逻辑像素，则判定水平获胜。反之判定垂直获胜。</p>
<h3 id="第五章-动画"><a href="#第五章-动画" class="headerlink" title="第五章 动画"></a>第五章 动画</h3><p><strong>P129</strong>：当创建AnimationController时，需要传入vsync参数，这个参数接受的是TickerProvider类型的对象，<font color="#dd0000"><strong>作用是阻止在屏幕锁屏时执行动画以避免不必要的资源浪费。</strong></font></p>
<p><strong>P136</strong>：AnimatedWidget对addListener、setState等动画相关动作进行了封装，使用起来更方便。</p>
<p><strong>P141</strong>：通过Hero，可以在路由之间做出流程的转场动画。<strong>Hero的组件需要同时定义源组件和目标组件，其中源组件和目标组件被Hero包裹在需要动画控制的组件外面。</strong></p>
<h3 id="第六章-使用网络技术和异步编程"><a href="#第六章-使用网络技术和异步编程" class="headerlink" title="第六章 使用网络技术和异步编程"></a>第六章 使用网络技术和异步编程</h3><p><strong>P184</strong>：在Flutter里，异步使用Futrue来修饰的，并运行在event loop里。Flutter中一个很重要的概念是isolate，通过Flutter Engine层面的<strong>一个线程</strong>来实现的，而实现isolate的线程又是由Flutter管理和创建的。所有的Dart代码都运行在isolate上。通常情况下，我们的应用都运行在main isolate中，在有必要时，我们可以创建新的isolate。<font color="#dd0000"><strong>多个isolate无法共享内存，必须通过相关的API通信才可以。</strong></font></p>
<p><strong>P185</strong>：event loop</p>
<p>![img](<a href="http://47.110.40.63:8080/img/blog/Flutter" target="_blank" rel="noopener">http://47.110.40.63:8080/img/blog/Flutter</a> eventloop运行流程图.png)</p>
<ol>
<li><p>运行APP并执行main方法</p>
</li>
<li><p>开始ging优先处理microtask queue，知道队列为空</p>
</li>
<li><p>当microtask queue为空后，开始处理event queue。如果event queue里面有event，则执行，<font color="#dd0000"><strong>每执行一条再判断此时新的microtask queue是否为空</strong></font>，并且每次只取出一条来执行。可以这么理解，在处理所有event之前，我们会做一些市区内给，并且会把这些事情放在microtask queue中。</p>
</li>
<li><p>microtask queue 和 event queue都为空，则APP可以正常退出。</p>
</li>
</ol>
<p>注意：当处理microtask queue时，event queue会被阻塞，所以microtask queue中应避免任务太多或长时间处理，<strong>否则将导致APP的绘制和交互等行为被卡住</strong>。</p>
<p><strong>P192</strong>：Future表示“将来”一次异步获取得到的数据，而Stream是多次异步获取得到的数据；Future将返回一个值，而Stream将返回多次值。</p>
<h3 id="第七章-路由"><a href="#第七章-路由" class="headerlink" title="第七章 路由"></a>第七章 路由</h3><p><strong>P197</strong>：一个界面跳转到另一个界面使用Navigator.push方法，返回上一个界面使用Navigator.pop方法。路由分为静态路由和动态路由。</p>
<p><strong>204</strong>：参数回传</p>
<ol>
<li><p>等待回传数据</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_navigateAndDisplaySelection(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    MaterialPageRoute(builder: (context) =&gt; SelectionScreen()),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回传数据</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pop(context, <span class="string">'Flutter'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>P207</strong>：路由栈</p>
<p>类似Android的launchMode功效</p>
<ul>
<li>pushReplacementNamed：替换当前栈顶页面为新的页面</li>
<li>popAndPushNamed：和上面的一样，只是多了pop的交互效果</li>
<li>pushNamedAndRemoveUntil：添加一个元素，并且移除历史，直到named对象</li>
<li>popUnil：没有push，移除历史，直到named对象</li>
</ul>
<h3 id="第八章-持久化"><a href="#第八章-持久化" class="headerlink" title="第八章 持久化"></a>第八章 持久化</h3><p><strong>P215</strong>：推荐使用shared_preferences插件，这是一个异步的key-value存储的插件。</p>
<ul>
<li><p>写入</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">prefs.setString(k,v);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">prefs.getString(k);</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">prefs.remove(k);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>P220</strong>：sqflite</p>
<ul>
<li>支持事务和批处理</li>
<li>支持自动version管理</li>
<li>支持增、删、改、查的Helper工具类</li>
<li><strong>支持Android/iOS后台线程的运行</strong></li>
</ul>
<p><strong>获取和删除</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> databasesPath = <span class="keyword">await</span> getDatabasesPath();</span><br><span class="line"><span class="built_in">String</span> path = join(databasePath,<span class="string">'demo.db'</span>);</span><br><span class="line"><span class="keyword">await</span> deleteDatabase(path);</span><br></pre></td></tr></table></figure>

<p><strong>打开并创建数据库</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Database database = <span class="keyword">await</span> openDatabase(path,version:<span class="number">1</span>,oncreate:(</span><br><span class="line">	Database db,<span class="built_in">int</span> version) <span class="keyword">async</span> &#123;</span><br><span class="line">  	<span class="keyword">await</span> db.execute(<span class="string">'CREATE TABLE Test(id INTEGER ...)'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p><strong>插入数据的两种方式</strong></p>
<p>//方式一，直接使用sql</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; rawInsert(<span class="built_in">String</span> sql,[<span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; arguments]);</span><br><span class="line"><span class="built_in">int</span> id = <span class="keyword">await</span> txn.rawInsert(</span><br><span class="line">	<span class="string">'INSERT INTO Test(name,value,num) VALUES(?,?,?)'</span>,[<span class="string">'another name'</span>,<span class="number">1213</span>,<span class="number">3.1212</span>])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>//方式二，使用map</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; insert(<span class="built_in">String</span> table,<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">dynamic</span>&gt; values,&#123;<span class="built_in">String</span> nullColumnHack,ConflictAlgorithm conflictAlgorithm&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>修改的两种方式</strong>，和插入一样，只是方法名变了</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; rawUpdate(<span class="built_in">String</span> sql,[<span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; arguments]);</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; rawUpdate(<span class="built_in">String</span> table,<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">dynamic</span>&gt; values,&#123;<span class="built_in">String</span> nullColumnHack,ConflictAlgorithm conflictAlgorithm&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>查询的两种方式</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">dynamic</span>&gt;&gt;&gt; rawQuery(<span class="built_in">String</span> sql,[<span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; arguments]);</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">List</span>&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">dynamic</span>&gt;&gt;&gt; Query(<span class="built_in">String</span> table,&#123;</span><br><span class="line">  <span class="built_in">bool</span> distinct,<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; columns,<span class="built_in">String</span> where,<span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; whereArgs,</span><br><span class="line">  <span class="built_in">String</span> groupBy,<span class="built_in">String</span> having,<span class="built_in">String</span> orderBy,<span class="built_in">int</span> limit,<span class="built_in">int</span> offset</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>物理删除的两种方式</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; rawDelete(<span class="built_in">String</span> sql,[<span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; arguments]);</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; delete(<span class="built_in">String</span> table,&#123;<span class="built_in">String</span> where,<span class="built_in">List</span>&lt;<span class="built_in">dynamic</span>&gt; whereArgs&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>计算总记录数</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sqflite.firstIntValue(<span class="keyword">await</span> database.rawQuery(<span class="string">'SELECT COUNT(*) FROM Test'</span>))</span><br></pre></td></tr></table></figure>

<p><strong>关闭数据库</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> databse.close()</span><br></pre></td></tr></table></figure>

<h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><p><strong>P238</strong>：添加未发布的package，编辑pubspec.yaml</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">	plugin1:</span><br><span class="line">		path: ../plugin1/</span><br></pre></td></tr></table></figure>

<p>添加git上的依赖</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">	plugin1:</span><br><span class="line">		git:</span><br><span class="line">			url: git:<span class="comment">//github.com/flutter/plugin1.git</span></span><br></pre></td></tr></table></figure>

<p><strong>P239</strong>：调用flutter packages get之后，会生成pubspec.lock。该文件确保更新的package不会影响现有代码。</p>
<p><strong>P240</strong>：创建自己的package</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --org com.example --template=plugin -i swift -a kotlin hello</span><br></pre></td></tr></table></figure>

<p>–org：指定包名；-i：指定iOS语言；-a：指定Android语言</p>
<p><strong>P241</strong>：Platform Channel</p>
<p>Platform Channel 是Flutter与Platform指定的通信机制，包括3种</p>
<ol>
<li>BasicMessageChannel：<strong>用于传递字符串和半结构化的信息（在大内存数据块传递的情况使用）</strong></li>
<li>MethodChannel：<strong>用于传递方法的调用</strong></li>
<li>EventChannel：<strong>用于数据流(event streams)的通信</strong></li>
</ol>
<p><strong>P242</strong>：Flutter的消息传递工具是BinaryMessager，传递的消息格式是二进制的。二进制格式的消息通过消息编解码器(Codec)解码为能识别的消息，并传递给Handler来进行处理。</p>
<p><strong>P253</strong>：在Android里每初始化一个FlutterView就会有一个FlutterEngine被初始化，这样就会有新的线程在Dart上运行。如果每个Activity中都有一个FlutterView，则会创建多个Flutter Engine实例，这会导致每个Flutter Engine实例加载的代码都独立运行在ioslate中，这种模式被称为多引擎模式。存在问题</p>
<ol>
<li>冗余的资源问题。</li>
<li>插件注册问题。插件依赖Messenger传递消息，多个FlutterView时，插件的注册和通信将变得混乱和难以维护。</li>
<li>Flutter Widget和Native页面的差异化问题。</li>
<li>增加页面之间通信的复杂度。</li>
</ol>
<p><strong>P254</strong>：FlutterBoost的思想是把Flutter容器做成浏览器的样子，然后填写一个页面地址，再由容器去管理页面的绘制。在Native端，如果初始化容器，就设置容器对应页面的标志即可。</p>
<p>读后感：</p>
<p>这本书很一般，知识点都是浅浅的谈一下，其实没什么买的必要，不推荐</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/" data-id="cka2mk1is004mds26chzubet6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android基础『V1V2V3签名』</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JetPack/" rel="tag">JetPack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paging/" rel="tag">Paging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Room/" rel="tag">Room</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava2/" rel="tag">RxJava2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" rel="tag">开源项目学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Flutter/" style="font-size: 12.5px;">Flutter</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JetPack/" style="font-size: 12.5px;">JetPack</a> <a href="/tags/Kotlin/" style="font-size: 12.5px;">Kotlin</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Paging/" style="font-size: 10px;">Paging</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Room/" style="font-size: 10px;">Room</a> <a href="/tags/RxJava2/" style="font-size: 12.5px;">RxJava2</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">开源项目学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">源码学习</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 10px;">组件化</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/">读书笔记『Flutter从0到1构建大前端应用』</a>
          </li>
        
          <li>
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ > </script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>