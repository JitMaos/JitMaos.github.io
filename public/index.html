<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-读书笔记『Android进阶解密』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EAndroid%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86%E3%80%8F/" class="article-date">
  <time datetime="2020-05-19T13:25:56.739Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EAndroid%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86%E3%80%8F/">Android『进阶解密』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第二章 Android系统启动</p>
<h3 id="2-1-init进程启动过程"><a href="#2-1-init进程启动过程" class="headerlink" title="2.1 init进程启动过程"></a>2.1 init进程启动过程</h3><p><strong>P13</strong>：init进程是Android系统中<strong>用户空间</strong>的第一个进程，进程号为1，是Android系统启动流程中一个关键的步骤，作为第一个进程，它被赋予了很多极其重要的工作职责，比如<font color="#dd0000"><strong>创建Zygote进程和属性服务等</strong></font>。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init/中。</p>
<p><strong>P14</strong>：Android系统启动的步骤</p>
<ol>
<li><p>启动电源以及系统启动</p>
<p>当电源按下时引导芯片代码从预定义的地方（固化在ROM）开始执行。<strong>加载引导程序BootLoader到RAM中，然后执行</strong>。</p>
</li>
<li><p>引导程序BootLoader</p>
<p>引导程序BootLoader是在Android<strong>操作系统开始运行前</strong>的一个小程序，它的主要作用是把系统OS拉起来并运行。</p>
</li>
<li><p>Linux内核启动</p>
<p>当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。<strong>在内核完成系统设置后，它首先在系统文件中寻找init.rc文件，并启动init进程</strong>。</p>
</li>
<li><p>init进程启动</p>
<p><font color="#dd0000"><strong>init进程做的工作比较多，主要用来初始化和启动属性服务（后文P23提到类似Window的注册表，存储的是key-value形式的数据），也用来启动Zygote进程。</strong></font></p>
</li>
</ol>
<p>###2.1.6属性服务</p>
<p>P23：Window平台上有一个注册表管理器，其内容采用键值对的形式记录一些用户、软件的使用信息。即使系统重启，还能根据之前注册表中的记录来进行相应的初始化工作。<strong>Android也提供了类似的机制，叫做属性服务</strong>。</p>
<p><strong>P24</strong>：start_property_service()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  property_set(<span class="string">"ro.property_service.version"</span>,<span class="string">"2"</span>);</span><br><span class="line">  property_set_fd = create_socket(PROP_SERVICE_NAME,SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<span class="number">0666</span>,<span class="number">0</span>,<span class="number">0</span>,NULL); <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">if</span>(property_set_fd == -<span class="number">1</span>) &#123;</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"start_property_service socket creation failed"</span>;</span><br><span class="line">    exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(property_set_fd,<span class="number">8</span>); <span class="comment">//2</span></span><br><span class="line">  register_epoll_handler(property_set_fd,handle_property_set_fd); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处创建<strong>非阻塞的Socket</strong>。在注释2处调用listen函数对property_set_fd进行监听，这样创建的Socket就成为Server，也就是属性服务；listen函数的第二个参数设置为8，意味着属性服务最多可以同时为8个<font color="#dd0000"><strong>视图设置属性的用户</strong></font>提供服务。</p>
<h3 id="2-2-1-Zygote概述"><a href="#2-2-1-Zygote概述" class="headerlink" title="2.2.1 Zygote概述"></a>2.2.1 Zygote概述</h3><p><font color="#dd0000"><strong>在Android系统中，Dalvik和ART、应用程序进程以及运行系统的关键服务的SystemServer进程都是有Zygote进程创建的</strong></font>，Zygote进程通过fork(复制进程）的形式来创建<strong>应用程序进程</strong>和<strong>SystemServer进程</strong>，由于Zygote进程在启动时会创建Dalvik和ART，因此通过fork创建的应用程序进程和SystemServer进程可以在内部获取一个Dalvik或ART的虚拟机实例副本。</p>
<h3 id="2-2-3-Zygote进程启动过程介绍"><a href="#2-2-3-Zygote进程启动过程介绍" class="headerlink" title="2.2.3 Zygote进程启动过程介绍"></a>2.2.3 Zygote进程启动过程介绍</h3><p><strong>P34</strong>：ZygoteInit的main方法主要做了4件事：</p>
<ol>
<li>创建一个Server端的Socket(个人理解：因为此时连SystemServer进程都还没创建，没有Binder，所以进程间通信先通过Socket)</li>
<li>预加载类和资源</li>
<li>启动SystemServer进程</li>
<li>等待AMS请求创建新的应用程序进程（P35-&gt;还是通过Socket来实现的）</li>
</ol>
<p><strong>P35</strong>：在Zygote进程将SystemServer进程启动后，就会在这个服务器端的Socket上等待AMS请求Zygote进程来创建新的应用程序进程。</p>
<h3 id="4-1-根Activity的启动过程"><a href="#4-1-根Activity的启动过程" class="headerlink" title="4.1 根Activity的启动过程"></a>4.1 根Activity的启动过程</h3><p>根Activity的启动过程主要分为3步，分别是Launcher请求AMS、AMS到ApplicationThread的调用过程、ActivityThread启动Activity。</p>
<h3 id="4-1-1-Launcher-请求AMS过程"><a href="#4-1-1-Launcher-请求AMS过程" class="headerlink" title="4.1.1 Launcher 请求AMS过程"></a>4.1.1 Launcher 请求AMS过程</h3><p><img src="http://47.110.40.63:8080/img/blog/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_Launcher%E8%AF%B7%E6%B1%82AMS.png" alt="img"></p>
<p><strong>扩展</strong></p>
<ol>
<li><p>为什么从Application/Service的Context启动Activity，需要指定Intent.FLAG_ACTIVITY_NEW_TASK？</p>
<p><strong>因为非Activity的Context没有所谓的任务栈(这里可以在扩展出Context的继承关系）</strong>，而Activity的存在需要任务栈来承载。所以指定NEW_TASK的Flag用于为Activity指定一个新的任务栈。</p>
</li>
<li><p>ApplicationThread虽然看上去是个Thread，但其实它是ActivityThread的内部类，<font color="#dd0000"><strong>继承自IApplicationThread.Stub</strong></font>，其中包含了很多scheduleXxx方法用于操作Service和BroadcastReceiver，具体可以参考这篇博文：<a href="https://blog.csdn.net/xu_song/article/details/81983724" target="_blank" rel="noopener">Android主线程(ActivityThread)源代码分析</a></p>
</li>
<li><p>Instrumentation可以看做是ActivityThread的管家</p>
</li>
</ol>
<p><strong>P85</strong>：Android8.0之前并没有采用AIDL，而是采用了类似AIDL的形式，用AMS的代理对象ActivityManagerProxy来与AMS进行进程间通信，Android8.0使用IActivityManager替代了ActivityManagerProxy，<strong>它是AMS在本地的代理。</strong>execStartActivity方法最终调用的是AMS的startActivity方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = <span class="keyword">new</span> </span><br><span class="line">  Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b); <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> am;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###4.12 AMS到ApplicationThread的调用过程</p>
<p><img src="http://47.110.40.63:8080/img/blog/AMS%E5%88%B0ApplicationThread%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="img"></p>
<p><strong>P93</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r,ProcessRecord app,<span class="keyword">boolean</span> andResume,<span class="keyword">boolean</span> checkConfi)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent),r.appToken,System.identityHashCode(r) .....)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的app指的是Process（要启动Activity的应用程序进程），<strong>app.thread指的是IApplicationThread，它的实现是ActivityThread的内部类ApplicationThread，其中ApplicaitonThread继承了IApplicaitonThread.Stub</strong>。通过ApplicationThreadL来与应用程序进行Binder通信，换句话说，<font color="#dd0000"><strong>ApplicationThread是AMS所在进程（SystemServer进程）和应用程序进程的通信桥梁</strong></font>。</p>
<p>###4.1.3 ActivityThread启动Activity过程</p>
<p><img src="http://47.110.40.63:8080/img/blog/ActivityThread%E5%90%AF%E5%8A%A8Activity%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="img"></p>
<p><strong>P96</strong>：因为ApplicationThread是一个Binder，它的调用逻辑运行在Binder线程池中，所以需要用H将代码的逻辑切换到主线程中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/app/AndroidThread.java</span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r,Intent customIntent)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">//创建要启动Activity的上下文环境</span></span><br><span class="line">  ContextImpl appContext = createBaseContextForActivity(r); </span><br><span class="line">  java.lang.ClassLoader cl = appContext.getClassLoader(); </span><br><span class="line">  activity = mInstrumentation.newActivity(cl,component.getClassName(),r.intent); <span class="comment">//1</span></span><br><span class="line">  ...</span><br><span class="line">  activity.attach(...); <span class="comment">//2</span></span><br><span class="line">  ...</span><br><span class="line">  mInstrumentation.callActivityOnCreate(activity,r.state,r.persistentState); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1-&gt; 调用Instrumentation的newActivity创建Activity，<font color="#dd0000"><strong>有些需求可以通过hook Instrumentation来实现一些功能，就是基于newActivity创建Activity的机制。</strong></font></p>
<p>2-&gt; 在attach中初始化Activity，<font color="#dd0000"><strong>在attach方法中会创建Window对象，并与Activity自身进行关联。</strong></font></p>
<p>扩展：</p>
<p>摘自：<a href="https://blog.csdn.net/huaxun66/article/details/78151361" target="_blank" rel="noopener">https://blog.csdn.net/huaxun66/article/details/78151361</a></p>
<p><font color="#dd0000"><strong>总体流程</strong></font><br>1.Launcher通过Binder机制通知AMS启动一个Activity.<br>2.AMS使Launcher栈最顶端Activity进入onPause状态.<br>3.AMS通知Process使用Socket和Zygote进程通信，请求创建一个新进程.<br>4.Zygote收到Socket请求，fork出一个进程，并调用ActivityThread#main().<br>5.ActivityThread通过Binder通知SystemServer进程中的AMS启动应用程序.<br>6.AMS通知ActivityStackSupervisor真正的启动Activity.<br>7.ActivityStackSupervisor通知ApplicationThread启动Activity.<br>8.ApplicationThread发消息给ActivityThread，需要启动一个Activity.<br>9.ActivityThread收到消息之后，通知LoadedApk创建Applicaition，并且调用其onCteate()方法.<br>10.ActivityThread装载目标Activity类，并调用Activity#attach().<br>11.ActivityThread通知Instrumentation调用Activity#onCreate().<br>12.Instrumentation调用Activity#performCreate()，在Activity#performCreate()中调用自身onCreate()方法.</p>
<h3 id="4-2Service的启动过程"><a href="#4-2Service的启动过程" class="headerlink" title="4.2Service的启动过程"></a>4.2Service的启动过程</h3><p>图片来源：</p>
<p><a href="https://blog.csdn.net/huaxun66/article/details/78151361" target="_blank" rel="noopener">https://blog.csdn.net/huaxun66/article/details/78151361</a></p>
<h2 id="第七章-理解WindowManager"><a href="#第七章-理解WindowManager" class="headerlink" title="第七章 理解WindowManager"></a>第七章 理解WindowManager</h2><h3 id="7-1Window、WindowManager和WMS"><a href="#7-1Window、WindowManager和WMS" class="headerlink" title="7.1Window、WindowManager和WMS"></a>7.1Window、WindowManager和WMS</h3><p><strong>P187</strong>：Window是一个抽象类，实现类为PhoneWindow，它对View进行管理。WindowManager是一个接口类，继承自接口ViewManager，从名字可以知道它是用来管理Window的，它的实现类为WindowManagerImpl。WindowManager和AMS通过Binder来进行跨进程通信。</p>
<p>###7.2 WindowManager的关联类</p>
<p><strong>P189</strong>：PhoneWindow的创建时机在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context,ActivityThread aThread,...)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>,window,activityConfigCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P191</strong>：WindowManagerImpl虽然是WindowManager的实现类，但是它把功能的实现委托给了WindowManagerGlobal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view,ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">  mGlobal.addView(view,params,mContext.getDisplay(),mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P192</strong>：WindowManagerGlobal是一个<font color="#dd0000"><strong>单例</strong></font>，一个进程中只有一个WIndowManagerGlobal实例。</p>
<p>PhoneWindow继承自Window，Window通过setWindowManager与WindowManager进行关联。WindowManager继承ViewManager接口，WindowManagerImpl是WindowManager的实现类，但是具体的功能由WindowManagerGlobal来实现。</p>
<p><img src="http://47.110.40.63:8080/img/blog/WindowManager%E7%B1%BB%E5%9B%BE.png" alt="img"></p>
<p>图片来源：<a href="https://www.jianshu.com/p/1c4059d3865b?utm_campaign=maleskine" target="_blank" rel="noopener">https://www.jianshu.com/p/1c4059d3865b?utm_campaign=maleskine</a></p>
<h3 id="7-3-1-Window的类型和显示次序"><a href="#7-3-1-Window的类型和显示次序" class="headerlink" title="7.3.1 Window的类型和显示次序"></a>7.3.1 Window的类型和显示次序</h3><p><strong>P194</strong>：应用程序窗口的Type值范围为1<del>99；子窗口的Type值范围为1000</del>1999；系统窗口为2000~2999，数值越大离用户越近(屏幕Z轴)。 </p>
<h3 id="7-4-1-系统窗口的添加过程"><a href="#7-4-1-系统窗口的添加过程" class="headerlink" title="7.4.1 系统窗口的添加过程"></a>7.4.1 系统窗口的添加过程</h3><p><strong>P196</strong>：</p>
<p>1.调用WindowManagerImpl的addView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/WindowManagerImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view,ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">  mGlobal.addView(view,params,mContext.getDisplay(),mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.WindowManagerGlobal的addView</p>
<p>在窗体添加、更新、删除的过程中涉及3个列表，<strong>View列表(ArrayList<View> mViews)、布局参数列表(ArrayList&lt;WindowManager.LayoutParams&gt; mParams)和ViewRootImpl列表（ArrayList<ViewRootImpl> mRoots)</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view,ViewGroup.LayoutParams params,Display display,Window parentWindow)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  root = <span class="keyword">new</span> ViewRootImpl(view.getContext,display);</span><br><span class="line">  mViews.add(view); <span class="comment">//添加到view列表</span></span><br><span class="line">  mRoots.add(root); <span class="comment">//添加到ViewRootImpl列表</span></span><br><span class="line">  mParams.add(wparams); <span class="comment">//添加到布局参数列表</span></span><br><span class="line">  root.setView(View,wparams,panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewRootImpl有很多功能，主要有以下几点</p>
<ol>
<li>View树的根并管理View树</li>
<li><strong>触发View的测量、布局和绘制</strong></li>
<li>输入事件的中转站</li>
<li>管理Surface</li>
<li><font color="#dd0000"><strong>负责与WMS进行进程间通信</strong></font></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view,WindowManager.LayoutParams attrs,View panelParentView)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  res = mWindowSession.addToDisplay(mWindow,mSeq,...);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mWindowSession是IWindowSession类型的，它是一个Binder对象，用于进程间通信，IWindowSession是Client端的代理，它的Server端为Session，此前的代码逻辑都是运行在本地进程的，而Session的addToDisplay方法则是运行在WMS所在的进程（SystemServer进程）中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/Session.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window,<span class="keyword">int</span> seq,WindowManager.LayoutParams attrs,...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>,window,seq,attrs...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>在addToDisplay方法中调用了WMS的addWindow方法，并将自身也就是Session作为参数传进去，每个应用程序进程都会对应一个Session，WMS会用ArrayList来保存这些Session。</strong></font>剩下的工作由WMS完成，在WMS中会为这个添加的窗口分配surface，并确定窗口的显示次序，可见负责显示界面的画布Surface，而不是窗口本身。<font color="#dd0000"><strong>WMS会将它管理的Surface交由SurfaceFlinger处理，SurfaceFlinger会将这些Surface混合并绘制在屏幕上</strong></font>。</p>
<h3 id="7-4-3-Window的更新过程"><a href="#7-4-3-Window的更新过程" class="headerlink" title="7.4.3 Window的更新过程"></a>7.4.3 Window的更新过程</h3><p><strong>P203</strong>：</p>
<p>1.Window的更新过程调用ViewManager接口中的updateViewLayout，在WindowManagerGlobal的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view,ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  root.setLayoutParams(wparams,<span class="keyword">false</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.跟进去，ViewRootImpl的setLayoutParams最后会滴啊用ViewRootImpl的scheduleTraversals</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(WindowManager.LayoutParams attrs, <span class="keyword">boolean</span> newView)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    scheduleTraversals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<font color="#dd0000"><strong>scheduleTraversals通过Choreographer设置了下一帧的回调mTraversalRunnable</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  mChoreographer.postCallback(</span><br><span class="line">    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.TraversalRunnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doTraversal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.doTraversal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">    ...</span><br><span class="line">    performTraversals();</span><br><span class="line">		...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.最后是我们熟悉的performTraversals，在里面执行measure/layout/darw过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">    ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八章-理解WindowManagerService"><a href="#第八章-理解WindowManagerService" class="headerlink" title="第八章 理解WindowManagerService"></a>第八章 理解WindowManagerService</h2><p><strong>P215</strong>：Watchdog用来监控系统的一些关键服务的运行状况（比如传入的WMS的运行状况），这些被监控的服务都会实现Watchdog.Monitor接口。<font color="#dd0000"><strong>Watchdog每分钟都会对被监控的系统服务进行检查，如果被监控的系统服务出现死锁，则会杀死Watchdog所在的进程，也就是SystemServer进程</strong></font>。</p>
<p><strong>P224</strong>：addWindow方法总结</p>
<ul>
<li>对所要添加到窗口进行检查，如果窗口不满足一些条件，就不会执行下面段代码逻辑。</li>
<li>WindowToken相关的处理，比如有的窗口类型需要提供WindowToken，没有提供的话就不会执行下面的代码逻辑，有的窗口类型则需要由WMS隐式创建WindowToken。</li>
<li>WindowState的创建和相关处理，将WindowToken和WindowState相关联。</li>
<li>创建和配置DisplayContent，完成窗口添加到系统前的准备工作。</li>
</ul>
<p><strong>P230</strong>：删除Window过程总结</p>
<ul>
<li>检查删除线程的正确性，如果不正确就抛出异常。</li>
<li><strong>从ViewRootImple列表、布局参数列表和View列表中删除与V对应的元素。</strong></li>
<li>判断是否可以直接执行删除操作，如果不能就推迟删除操作。</li>
<li>执行删除操作，清理和释放与V相关的一切资源。</li>
</ul>
<h2 id="第九章-JNI原理"><a href="#第九章-JNI原理" class="headerlink" title="第九章 JNI原理"></a>第九章 JNI原理</h2><p><strong>P235</strong>：Native方法注册分为静态注册和动态注册，其中静态注册多用于NDK开发，而动态注册多用于Framework开发。</p>
<p><strong>扩展</strong>：<a href="https://www.jianshu.com/p/1d6ec5068d05" target="_blank" rel="noopener">Android JNI 函数注册的两种方式</a></p>
<p><strong>P242</strong>：JNI的方法签名格式为</p>
<p>​    (参数签名格式…) 返回值签名格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_setup</span><span class="params">(Object meidarecorder_this,String fileName,String opPackageName)</span> </span>=&gt;它在JNI中方法签名为：</span><br><span class="line">(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>



<p><strong>P244</strong>：JNIEnv是Native世界中Java环境的代表，通过JNIEnv<em>指针就可以在Native世界中访问Java世界的代码进行操作，<font color="#dd0000">*</em>它只在创建它的线程中有效，不能跨线程传递**</font>，因此不同线程的JNIEnv是彼此独立的。</p>
<p><strong>P249</strong>：JNI也有引用类型，它们分别是本地引用(Local References)、全局引用(Global References)和弱全局引用(Weak Global References)</p>
<p>本地引用</p>
<ul>
<li><p>当Nativa函数返回时，这个本地引用就会被自动释放。</p>
</li>
<li><p>只在创建它的线程中有效，不能跨线程使用。</p>
</li>
<li><p>局部引用是JVM负责的引用类型，受JVM管理。</p>
</li>
</ul>
<p>全局引用</p>
<ul>
<li>在native函数返回时不会被自动释放，因此全局引用需要手动来进行释放。并且不会被GC回收。</li>
<li>全局引用是可以跨线程使用的。</li>
<li>全局引用不受到JVM管理。</li>
</ul>
<p>弱全局引用</p>
<ul>
<li>是一种特殊的全局引用，不同点在于弱全局引用是可以被GC回收的，弱全局引用被GC回收之后会指向NULL</li>
</ul>
<h2 id="第十章-Java虚拟机"><a href="#第十章-Java虚拟机" class="headerlink" title="第十章 Java虚拟机"></a>第十章 Java虚拟机</h2><p><strong>P256</strong>：classfile格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//u1/u2/u4/u8分别表示1，2，4，8个字节的无符号类型。</span></span><br><span class="line">ClassFile &#123;</span><br><span class="line">  u4 magic: <span class="comment">//魔数，OxCAFEBABE</span></span><br><span class="line">  u2 minor_version; <span class="comment">//副版本</span></span><br><span class="line">  u2 major_version; <span class="comment">//主版本</span></span><br><span class="line">  u2 constant_pool_count; <span class="comment">//常量池计数器</span></span><br><span class="line">  cp_info constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">//常量池</span></span><br><span class="line">  u2 access_flags; <span class="comment">//类和接口层次的访问标志</span></span><br><span class="line">  u2 this_class; <span class="comment">//类索引</span></span><br><span class="line">  u2 super_class; <span class="comment">//父类索引</span></span><br><span class="line">  u2 interfaces_count; <span class="comment">//接口计数器</span></span><br><span class="line">  u2 interfaces[interfaces_count]; <span class="comment">//接口表</span></span><br><span class="line">  u2 fields_count; <span class="comment">//字段计数器</span></span><br><span class="line">  field_info_fields[fields_count]; <span class="comment">//字段表</span></span><br><span class="line">  u2 methods_count; <span class="comment">//方法计数器</span></span><br><span class="line">  method_info_methods[methods_count]; <span class="comment">//方法表</span></span><br><span class="line">  u2 attributes_count; <span class="comment">//属性计数器</span></span><br><span class="line">  attribute_info attributes[attributes_count]; <span class="comment">//属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P257</strong>：类加载子系统</p>
<ol>
<li><p>BootStrap ClassLoader(引导类加载器)</p>
<p>用C/C++代码实现的加载器，用于加载指定的JDK的核心库，比如java.lang，java.util等。</p>
</li>
<li><p>Extensions ClassLoader(扩展类加载器)</p>
<p>用于加载Java的扩展类，提供除了系统类之外的额外功能。</p>
</li>
<li><p>Application ClassLoader(应用程序加载器)</p>
<p>这个类加载器可以通过ClassLoader的getSystemLoader获取到，也成为系统类加载器。</p>
</li>
</ol>
<p><strong>P258-P260</strong>：运行时数据区域</p>
<p>在<a href="[https://jitmaos.github.io/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/](https://jitmaos.github.io/2020/04/19/读书笔记『深入理解Java虚拟机』/)">读书笔记『深入理解Java虚拟机』</a>有记录过，不再重复记录。</p>
<p><strong>P261</strong>：对象的创建</p>
<ol>
<li><p>判断对象对应的类是否加载、链接和初始化</p>
</li>
<li><p>为对象分配内存</p>
</li>
<li><p>处理并发安全问题</p>
</li>
<li><p>初始化分配到的内存空间</p>
<p>出对象头外，都初始化为零。</p>
</li>
<li><p>设置对象的对象头</p>
<p>将对象的所属类、对象的HashCode和对象的GC分代年龄等数据存储在对象头中。</p>
</li>
<li><p>执行init方法进行初始化</p>
</li>
</ol>
<p><strong>P262</strong>：对象的堆内布局主要分为三部分：对象头、实例数据、对齐填充(不一定存在，没有特殊意义)</p>
<p>对象头：</p>
<p>​    hash：对象的哈希码</p>
<p>​    age：<font color="#dd0000"><strong>对象的分代年龄</strong></font>。</p>
<p>​    biased_lock：<font color="#dd0000"><strong>偏向锁标志位</strong></font>。</p>
<p>​    lock：锁状态标志位。</p>
<p>​    JavaThread<em>：<font color="#dd0000">*</em>持有偏向锁的线程ID**</font>。</p>
<p>​    epoch：<strong>偏向时间戳</strong></p>
<p><strong>P266-P275</strong>：垃圾回收算法</p>
<p>在<a href="[https://jitmaos.github.io/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/](https://jitmaos.github.io/2020/04/19/读书笔记『深入理解Java虚拟机』/)">读书笔记『深入理解Java虚拟机』</a>有记录过，不再重复记录。</p>
<h2 id="第十一章-Dalvik和ART"><a href="#第十一章-Dalvik和ART" class="headerlink" title="第十一章 Dalvik和ART"></a>第十一章 Dalvik和ART</h2><p><strong>P276</strong>：<font color="#dd0000"><strong>Dalvik并不是一个Java虚拟机</strong></font>，因为Dalvik没有遵循Java虚拟机规范，Dalvik是基于寄存器的，而Java虚拟机是基于栈的。<strong>基于寄存器的Dalvik，减少了出入栈的指令，更紧凑、简洁</strong>。</p>
<p><strong>P277</strong>：Dex文件将所包含的class文件的信息整合在一起，去除冗余信息，更紧凑。</p>
<p><strong>P282</strong>：Dalvik和ART的区别</p>
<ol>
<li>在ART中，系统在安装时会进行一次AOT（Ahead of time compilation，预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要进行编译了，程序的运行效率得以提高，耗电量也会减少。ART在7.0前是全编译的，但是这样导致安装时间过长，且占据更大的存储空间。<font color="#dd0000"><strong>在7.0以后，ART加入了即时编译器JIT，在安装时不会将字节码全部编译成机器码，而是在运行中将热点代码编译成机器码（据说是在屏幕息屏，或者设备空闲的时候执行的)，存储在本地，从而取得一个平衡</strong></font>。</li>
<li>Dalvik是基于32位CPU设计的，而ART支持64位并兼容32位CPU，这是Dalvik被淘汰的主要原因之一。</li>
<li>ART对垃圾回收机制进行了改进，比如更频繁地执行并行垃圾回收，将GC暂停有2次减少为1次。</li>
<li>ART的运行时堆空间划分和Dalvik不同。</li>
</ol>
<p><strong>P288</strong>：Zygote进程创建了Dalvik或ART虚拟机的实例，之后fork出来的进程都同样带有Dalvik或ART虚拟机的实例。</p>
<h2 id="第十二章-理解ClassLoader"><a href="#第十二章-理解ClassLoader" class="headerlink" title="第十二章 理解ClassLoader"></a>第十二章 理解ClassLoader</h2><p><strong>P295</strong>：ClassLoader双亲委托加载机制的好处</p>
<ul>
<li>防止重复加载，已经加载过得Class，直接使用就可以了。</li>
<li>更加安全，防止被自定义类已经加载的类。</li>
</ul>
<p>自定义ClassLoader</p>
<ol>
<li>定义一个自定义ClassLoader类</li>
<li>复写findClass方法，并在findClass方法中调用defineClass方法</li>
</ol>
<p><strong>P299</strong>：Android中的ClassLoader</p>
<p>Android中的ClassLoader和Java中的ClassLoader有些类似，也分为系统类加载器和自定义类加载器，其中系统类加载器分为：BootClassLoader、PathClassLoader、DexClassLoader。</p>
<p><strong>BootClassLoader</strong>：是ClassLoader的<strong>内部类</strong>，并继承自ClassLoader。<font color="#dd0000"><strong>BootClassLoader是一个单例类，需要注意的是BootClassLoader的访问修饰符是默认的，只有在同一个包中才能访问，因此我们在应用程序中是无法直接调用的。</strong></font></p>
<p><strong>DexClassLoader</strong>：可以加载dex文件以及包含dex的压缩文件(apk和jar文件)，<font color="#dd0000"><strong>DexClassLoader继承自BaseDexClassLoader，方法都在BaseDexClassLoader中实现。</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath,String optimizedDirectory,String 			  		    librarySearchPath,ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(dexPath,<span class="keyword">new</span> File(optimizedDirectory),librarySearchPath,parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DexClassLoader构造函数包含4个参数</p>
<ul>
<li>dexPath：dex相关文件路径集合，多个路径用文件分隔符分隔默认文件分隔符为”:”；</li>
<li>optimizedDirectory：解压的dex文件的存储路径，这个路径必须是一个内部存储路径，在一般情况下，使用当前应用程序的私有路径：/data/data/<Package Name>/…</li>
<li>librarySearchPath：包含C/C++库的路径集合，多个路径用文件分隔符分隔，可以为null</li>
<li>Parent：父加载器</li>
</ul>
<p><strong>PathClassLoader</strong>：Android系统使用PathClassLoader来加载<strong>系统类和应用程序的类</strong>。和DexClassLoader一样继承自BaseDexClassLoader，也在BaseDexClassLoader中实现。</p>
<p>在PathClassLoader的构造方法中没有optimizedDirectory，<strong>这是因为PathClasLoader的optimizedDirectory已经被指定为/data/data/dalvik-cache</strong>，该目录用于存放已经加载过得dex，<font color="#dd0000"><strong>因此PathClassLoader通常用来加载已经安装的apk的dex文件</strong></font>。</p>
<p>![img](<a href="http://47.110.40.63:8080/img/blog/Android" target="_blank" rel="noopener">http://47.110.40.63:8080/img/blog/Android</a> 8.0ClassLoader继承关系.png)</p>
<ul>
<li>ClassLoader是一个抽象类，其中定义了ClassLoader的主要功能。<strong>BootClassLoader是它的内部类</strong>。</li>
<li>SecureClassLoader类和JDK 8中的SecureClassLoader的代码是一样的，它继承了抽象类ClassLoader。SecureClassLoader并不是ClassLoader的实现类，而是<font color="#dd0000"><strong>拓展了ClassLoader类加入了权限方面的功能，加强了ClassLoader的安全性</strong></font>。</li>
<li>URLClassLoader类和JDK 8中的URLClassLoader是一样的，<font color="#dd0000"><strong>它继承自SecureClassLoader，用来通过URL路径从jar文件和文件夹中加载类和资源</strong></font>。</li>
<li>InMemoryDexClassLoader是Android 8.0新增的类加载器，继承自BaseDexClassLoader，<font color="#dd0000"><strong>用来加载内存中的dex文件</strong></font>。</li>
<li>BaseDexClassLoader继承自ClassLoader，是抽象类ClassLoader的具体实现类，PathClassLoader、DexClassLoader、InMemoryDexClassLoader都继承自它。</li>
</ul>
<p><strong>ClassLoader的加载流程</strong></p>
<p>![img](<a href="http://47.110.40.63:8080/img/blog/Android" target="_blank" rel="noopener">http://47.110.40.63:8080/img/blog/Android</a> 类加载流程示例.png)</p>
<h2 id="第十三章-热修复原理"><a href="#第十三章-热修复原理" class="headerlink" title="第十三章 热修复原理"></a>第十三章 热修复原理</h2><p><strong>P313</strong>：热修复的核心技术包括三类，分别是<strong>代码修复</strong>，<strong>资源修复</strong>，<strong>动态链接库修复</strong>。</p>
<h3 id="13-3-1-Instant-Run概述"><a href="#13-3-1-Instant-Run概述" class="headerlink" title="13.3.1 Instant Run概述"></a>13.3.1 Instant Run概述</h3><p><img src="http://47.110.40.63:8080/img/blog/InstantRun%E7%BC%96%E8%AF%91%E9%83%A8%E7%BD%B2.png" alt="img"></p>
<p><strong>Hot Swap</strong>：不需要重启程序，不需要重启Activity，如：修改一个现有方法。</p>
<p><strong>Warm Swap</strong>：需要Activity重启，如：修改或删除一个现有的资源文件。</p>
<p><strong>Code Swap</strong>：App需要重启，但是不需要重新安装，如：添加、删除一个字段和方法、添加一个类等。</p>
<p>图片来源：<a href="https://www.jianshu.com/p/fe2f739928ec" target="_blank" rel="noopener">https://www.jianshu.com/p/fe2f739928ec</a></p>
<p><strong>P318</strong>：InstantRun中资源热修复的原理</p>
<ol>
<li>创建新的AssetManager，通过<strong>反射</strong>调用addAssetPath方法加载外部的资源，这样新创建的AssetManager就含有了外部资源。</li>
<li>将AssetManager类型的mAssets字段的引用全部替换为新创建的AssetManager。</li>
</ol>
<p>###13.4 代码修复</p>
<p>代码修复主要有3个方案，分别是<font color="#dd0000"><strong>底层替换方案、类加载方案和Instant Run方案</strong></font>。</p>
<h3 id="13-4-1-类加载方案"><a href="#13-4-1-类加载方案" class="headerlink" title="13.4.1 类加载方案"></a>13.4.1 类加载方案</h3><p><strong>P319</strong>：</p>
<p><strong>65536限制</strong>：<strong>类加载方案基于Dex分包方案</strong>，<font color="#dd0000"><strong>DVM指令集的方法调用指令invoke-kind索引为16bits，最多能引用65536个方法</strong></font>。</p>
<p><strong>LinearAlloc限制</strong>：DVM中LinearAlloc是一个固定的缓存区，当方法数超过了缓存区的大小时会报错。</p>
<p><strong>Dex分包方案</strong>：将程序启动必须要用到的方法的类放到<strong>主Dex</strong>中，其余代码放置到<strong>次Dex</strong>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name,List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">  <span class="keyword">for</span>(Element element:dexElements) &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = element.findClass(name,definingContext,suppressed);</span><br><span class="line">    <span class="keyword">if</span>(clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">    suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Element内部封装了DexFile，DexFile用于加载dex文件，因此每个dex文件对应衣蛾Element。多个Element组成了有序的Element数组dexElements。当要查找类时，会遍历Element数组dexElements(相当于遍历dex文件数组），调用Element的findClass方法，其内部调用DexFile的loadClassBinaryName方法，<strong>如果在当前Element中找到了目标Class，就返回。否则接着找下一个Element</strong>。</p>
<p>根据加载顺序，我们可以将有问题的代码修复好以后，打成一个dex，<font color="#dd0000"><strong>将其放置在dexElements数组的首位</strong></font>，这样可以是虚拟机加载到修复后的Class。</p>
<p>为什么需要重启呢？<font color="#dd0000"><strong>因为已经加载过的类是无法卸载的，只能重新走一遍类加载流程加载修复过的Class</strong></font>。</p>
<p>QQ空间的超级补丁和Nuwa按上面说的将补丁包放在Element数组的第一个元素以优先加载；微信Tinker将新旧APK做diff，得到patch.dex，再将patch.dex与手机中APK的classes.dex合并，生成新的classes.dex，<font color="#dd0000"><strong>然后在运行时通过反射将classes.dex放到Elements数组的第一位</strong></font>；饿了么的Amigo则是将补丁包中每个dex对应的Element取出来，之后组成新的Element数组，<strong>在运行时通过反射用新的Element数组替换掉现在的Element数组</strong>。</p>
<h3 id="13-4-2-底层替换方案"><a href="#13-4-2-底层替换方案" class="headerlink" title="13.4.2 底层替换方案"></a>13.4.2 底层替换方案</h3><p><strong>P322</strong>：</p>
<p>底层替换方案不需要再次加载类，而是直接在Native层修改原有类，<strong>由于在原有类进行修改限制会比较多，且不能增减原有类的方法和字段，如果我们增加了方法数，那么方法索引数也会增加，这样访问方法时无法通过索引找到正确的方法，同样的字段也有类似的情况。</strong></p>
<p><font color="#dd0000"><strong>替换ArtMethod结构体中的字段或者替换整个ArtMethod结构体，这就是底层替换方案。</strong></font>AndFix采用替换ArtMethod结构体中的字段，这样会有兼容问题，因为厂商可能修改ArtMethod结构体，导致方法替换失败。<strong>Sophix采用的是替换整个ArtMethod结构体，这样不会存在兼容问题</strong>。</p>
<h3 id="13-4-3-Instant-Run方案"><a href="#13-4-3-Instant-Run方案" class="headerlink" title="13.4.3 Instant Run方案"></a>13.4.3 Instant Run方案</h3><p><strong>P323</strong>：</p>
<p><font color="#dd0000"><strong>Instant Run在第一次构建APK时，使用ASM在每一个方法中注入了类似如下的代码</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IncrementalChange localIncrementalChange = $change;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span>(localIncrementalChange != <span class="keyword">null</span>) &#123; <span class="comment">//2</span></span><br><span class="line">  localIncrementalChange.access$dispatch(</span><br><span class="line">  	<span class="string">"onCreate.(Landroid/os/bundle;)V"</span>,<span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>,paramBundle&#125;);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们点击InstantRun时，如果方法没有变化则$change为null；就调用return如果方法有变化，就生成替代类，这里我们假设MainActiivity的onCreate做了修改，就会生成MainActivity#override，这个类实现了IncrementalChange接口。</p>
<h3 id="13-5-动态链接库的修复"><a href="#13-5-动态链接库的修复" class="headerlink" title="13.5 动态链接库的修复"></a>13.5 动态链接库的修复</h3><p><strong>p323</strong>：热修复框架的so修复主要更新so，因此so的修复的基础原理是加载so。</p>
<p><strong>P324</strong>：<font color="#dd0000"><strong>System的load方法传入的参数是so在磁盘的完整路径，用于加载指定路径的so。System的loadLibrary传入的参数是so的名称，用于加载App安装后自动从apk包中复制到/data/data/packangename/lib下的so.</strong></font></p>
<p><strong>P332</strong>：修复SO文件的两个方案</p>
<ol>
<li>将SO补丁插入到NativeLibraryElement数组的前部，让SO补丁的路径先被返回和加载（类似代码dex修复)。</li>
<li>调用System的load方法来接管So的加载入口。</li>
</ol>
<h2 id="第十四章-Hook技术"><a href="#第十四章-Hook技术" class="headerlink" title="第十四章 Hook技术"></a>第十四章 Hook技术</h2><p><strong>P335</strong>：被劫持的对象，称作Hook点，为了保证Hook的稳定性，Hook点一般选择<strong>容易找到且不易变化</strong> 的对象，<strong>静态变量和单例</strong>就符合这一条件。</p>
<p><strong>P336</strong>：根据Hook的实现方式可以分为两种</p>
<ul>
<li>通过<strong>反射和代理</strong>实现，只能Hook当前的应用程序进程。</li>
<li>通过<strong>Hook框架</strong>来实现，比如Xposed，可以实现全局Hook(Zygote进程)，但是<font color="#dd0000"><strong>需要root</strong></font>。</li>
</ul>
<p><strong>P343</strong>：一个进程中只有一个ActivityThread，ActivityThread是主线程的管理类。</p>
<p><font color="#dd0000"><strong>扩展：ActivityThread</strong></font></p>
<p>安卓应用程序的入口是什么呢？我想不少人可能回答说:application的onCreate方法，其实并不是的，即使是application，<strong>也有一个方法比onCreate先执行，这个方法就是attachBaseContext(Context context)方法:一般情况下，可以在这个方法中进行多dex的分包注入</strong>，比如下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        MultiDex.install(base);</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        try &#123;</span><br><span class="line">            HandlerInject.hookHandler(base);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>application并不是安卓程序的入口，跟Java程序类似，都是有一个入口的，而这个入口就是ActivityThread，<font color="#dd0000"><strong>ActiviyThread也有一个main方法，这个main方法是安卓应用程序真正的入口</strong></font>。</p>
<p><strong>ActivityThread的作用很多，但最主要的作用是根据AMS(ActivityManagerService的要求，通过IApplicationTHread的接口)负责调度和执行activities、broadcasts和其它操作</strong>。</p>
<h2 id="第十五章-插件化原理"><a href="#第十五章-插件化原理" class="headerlink" title="第十五章 插件化原理"></a>第十五章 插件化原理</h2><p><strong>P352</strong>：如果加载的插件不需要和宿主有任何耦合，也无须和宿主进行通信，比如加载第三方APP，那么推荐使用RePlugin，其他情况推荐使用VirtualApk。</p>
<p>###15.4 Activiyt插件化</p>
<p>三种实现方式：反射、接口、Hook。主流的采用Hook的方式，Hook的实现有两种方案：</p>
<ul>
<li>通过Hook  IActivityManager实现</li>
<li>通过Hook Instrumentation实现</li>
</ul>
<h2 id="第十六章-绘制优化"><a href="#第十六章-绘制优化" class="headerlink" title="第十六章 绘制优化"></a>第十六章 绘制优化</h2><h3 id="16-1-1绘制原理"><a href="#16-1-1绘制原理" class="headerlink" title="16.1.1绘制原理"></a>16.1.1绘制原理</h3><p><strong>P395</strong>：View的绘制流程有3个步骤，分别是measure、layout和draw，它们主要运行在系统的应用架构层，<font color="#dd0000"><strong>而真正将数据渲染到屏幕上的则是系统Native层的SurfaceFlinger服务来完成的。</strong></font></p>
<p>绘制过程主要由CPU来进行Measure、Layout、Record、Execute的数据计算工作，GPU负责栅格化、渲染。<strong>CPU和GPU是通过图形驱动层来进行连接的，图形驱动层维护了一个队列，CPU将display list添加到改队列中，这样GPU就可以从这个队列中取出数据进行绘制</strong>。</p>
<p>Android系统每16ms发出VSYNC(垂直同步型号)信号，触发UI进行渲染，VSYNC是一种<font color="#dd0000"><strong>定时中断</strong></font>，一旦收到VSYNC信号，CPU就开始处理各帧数据。</p>
<p>产生卡顿的原因：</p>
<ul>
<li>布局Layout过于复杂，无法在16ms内完成渲染。</li>
<li>同一时间动画执行的次数过多，导致CPU和GPU负载过重。</li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次。</li>
<li>在UI线程中做了稍微耗时的操作。</li>
<li>GC回收时暂停时间过长或频繁的GC产生了大量暂停时间。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EAndroid%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86%E3%80%8F/" data-id="ckal0v29c004nl926drmrfspj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android『电量监测及优化使用』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/" class="article-date">
  <time datetime="2020-05-12T02:38:44.422Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/">Android『电量检测及优化使用』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="本地电量检测"><a href="#本地电量检测" class="headerlink" title="本地电量检测"></a>本地电量检测</h1><p>做电量优化第一步，首先需要知道当前APP的耗电情况，大概步骤：</p>
<ol>
<li>使用Monkey、Appium、MonkeyRunner等自动化工具产生测试数据，本文基于Monkey进行讨论。</li>
<li>采集耗电信息，本方案基于系统自带的命令，生成电池使用记录文本batterystats.txt文件。</li>
<li>之后导出该文件</li>
<li>最后使用第三方工具分析数据，本文使用。</li>
</ol>
<h2 id="Monkey命令介绍"><a href="#Monkey命令介绍" class="headerlink" title="Monkey命令介绍"></a>Monkey命令介绍</h2><p>参考：<a href="https://blog.csdn.net/qq_30993595/article/details/80748559" target="_blank" rel="noopener">https://blog.csdn.net/qq_30993595/article/details/80748559</a></p>
<p><img src="http://47.110.40.63:8080/img/blog/%E9%9D%9E%E6%9E%B6%E6%9E%84/Monkey%E5%91%BD%E4%BB%A4help.png" alt="img"></p>
<ol>
<li><p><font color="#dd0000"><strong>-p 用于约束限制，用此参数指定一个包</strong></font>，指定包后Monkey将被允许启动指定应用；<strong>如果不指定包，  Monkey将被允许随机启动设备中的应用</strong>（主Activity有android.intent.category.LAUNCHER 或android.intent.category.MONKEY类别 ）</p>
<p>比如 adb shell monkey -p <strong>xxx.xxx.xxx</strong> 1  ; xxx.xxx.xxx 表示应用包名，1 表示monkey模拟用户随机事件参数，最低1，这样就能把应用启动起来</p>
</li>
<li><p>-c 指定Activity的category类别，如果不指定，默认是CATEGORY_LAUNCHER 或者 Intent.CATEGORY_MONKEY；不太常用的一个参数</p>
</li>
<li><p><strong>-v 用于指定反馈信息级别，也就是日志的详细程度</strong>，分Level1、Level2、Level3；-v 默认值，仅提供启动提示，操作结果等少量信息 ，也就是Level1，比如adb shell monkey -p  xxx.xxx.xxx -v 1 ；-v -v 提供比较详细信息，比如启动的每个activity信息 ，也就是Level2，比如adb shell monkey -p xxx.xxx.xxx -v -v 1 ；-v -v -v 提供最详细的信息 ，比如adb shell monkey -p xxx.xxx.xxx -v -v -v 1 </p>
</li>
<li><p><font color="#dd0000"><strong>-s 伪随机数生成器的种子值，如果我们两次monkey测试事件使用相同的种子值，会产生相同的事件序列</strong></font>；如果不指定种子值，系统会产生一个随机值。种子值对我们复现bug很重要。使用如下adb shell monkey -p xxx.xxx.xxx -s 11111 10；这也是伪随机事件的原因，因为这些事件可以通过种子值进行复现</p>
</li>
<li><p><font color="#dd0000"><strong>–ignore-crashes 忽略异常崩溃，如果不指定，那么在monkey测试的时候，应用发生崩溃时就会停止运行</strong></font>；如果加上了这个参数，monkey就会运行到指定事件数才停止。比如adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-crashes 10 </p>
</li>
<li><p><font color="#dd0000"><strong>–ignore-timeouts 忽略ANR</strong></font>，情况与4类似，当发送ANR时候，让monkey继续运行。比如adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-timeouts 10</p>
</li>
<li><p><font color="#dd0000"><strong>–ignore-native-crashes 忽略native层代码的崩溃</strong></font>，情况与4类似，比如adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-native-crashes 10</p>
</li>
<li><p>–ignore-security-exceptions 忽略一些许可错误，比如证书许可，网络许可，adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-security-exceptions 10</p>
</li>
<li><p>–monitor-native-crashes 是否监视并报告native层发送的崩溃代码，adb shell monkey -p xxx.xxx.xxx -v -v -v  –monitor-native-crashes 10</p>
</li>
<li><p>–kill-procress-after-error 用于在发送错误后杀死进程</p>
</li>
<li><p>–hprof  设置后，在Monkey事件序列之前和之后立即生产分析报告，保存于data/mic目录，不过将会生成大量几兆文件，谨慎使用</p>
</li>
<li><p><font color="#dd0000"><strong>–throttle 设置每个事件结束后延迟多少时间再继续下一个事件，降低cpu压力</strong></font>；如果不设置，事件与事件之间将不会延迟，事件将会尽快生成；一般设置300ms，因为人最快300ms左右一个动作，比如 adb shell monkey -p xxx.xxx.xxx -v -v -v  –throttle 300 10</p>
</li>
<li><p>–pct-touch 设置触摸事件的百分比，即手指对屏幕进行点击抬起(down-up)的动作；不做设置情况下系统将随机分配各种事件的百分比。比如adb shell monkey -p xxx.xxxx.xxx –pct-touch 50 -v -v 100 ，这就表示100次事件里有50%事件是触摸事件</p>
</li>
<li><p>–pct-motion 设置移动事件百分比，这种事件类型是由屏幕上某处的一个down事件-一系列伪随机的移动事件-一个up事件，即点击屏幕，然后直线运动，最后抬起这种运动。</p>
</li>
<li><p>–pct-trackball 设置轨迹球事件百分比，这种事件类型是一个或者多个随机移动，包含点击事件，这里可以是曲线运动，不过现在手机很多不支持，这个参数不常用</p>
</li>
<li><p>–pct-syskeys 设置系统物理按键事件百分比，比如home键，音量键，返回键，拨打电话键，挂电话键等</p>
</li>
<li><p>–pct-nav 设置基本的导航按键事件百分比，比如输入设备上的上下左右四个方向键</p>
</li>
<li><p>–pct-appswitch 设置monkey使用startActivity进行activity跳转事件的百分比，保证界面的覆盖情况</p>
</li>
<li><p>–ptc-anyevent 设置其它事件百分比</p>
</li>
<li><p>–ptc-majornav 设置主导航事件的百分比</p>
</li>
<li><p>保存dos窗口打印的monkey信息，在monkey命令后面补上输出地址，如adb shell monkey -p xxx.xxxx.xxx  -v -v 100 &gt; D:\monkey.txt；这样monkey测试结束后，所有打印的信息都会输出到这个文件里</p>
</li>
<li><p><font color="#dd0000"><strong>通过adb bugreport 命令可以获取整个android系统在运行过程中所有app的内存使用情况，cpu使用情况，activity运行信息等，包括出现异常等信息。使用方法 adb bugreport &gt; bugreport.txt ;这样在当前目录就会产生一个txt文件和一个压缩包，具体信息可在压缩包查看，txt文件只会记录压缩包的生成过程信息</strong></font></p>
</li>
<li><p>-f 加载monkey脚本文件进行测试，比如 adb shell monkey -f sdcard/monkey.txt -v -v 500</p>
</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/" data-id="ckal0v28m003il926cfrsa6ss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/" rel="tag">Android，性能优化，电量优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Flutter实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-05-11T23:27:03.067Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Flutter实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##第一章 起步</p>
<h3 id="1-2：初识Flutter"><a href="#1-2：初识Flutter" class="headerlink" title="1.2：初识Flutter"></a>1.2：初识Flutter</h3><p><strong>静态编译与动态解释</strong>：<font color="#dd0000"><strong>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”</strong></font>。<strong>是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT</strong>。</p>
<p><strong>为什么Flutter选择Dart作为开发语言？</strong></p>
<ol>
<li><p>Dart运行时和编译器支持Flutter的两个关键特性的组合：</p>
<p><strong>基于JIT的快速开发周期</strong>：<font color="#dd0000"><strong>Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间</strong></font>；</p>
<p><strong>基于AOT的发布包</strong>:<font color="#dd0000">Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能</font>。而JavaScript则不具有这个能力。</p>
</li>
<li><p><strong>高性能</strong></p>
<p>Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。</p>
</li>
<li><p><strong>快速内存分配</strong></p>
<p>Flutter框架<strong>使用函数式流</strong>，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。</p>
</li>
<li><p><strong>类型安全</strong></p>
<p><strong>由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力</strong>。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。</p>
</li>
<li><p><strong>Dart团队就在你身边</strong></p>
<p>看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。”</p>
</li>
</ol>
<h3 id="1-4-Dart语言简介"><a href="#1-4-Dart语言简介" class="headerlink" title="1.4 Dart语言简介"></a>1.4 Dart语言简介</h3><h4 id="1-4-2-函数"><a href="#1-4-2-函数" class="headerlink" title="1.4.2 函数"></a>1.4.2 函数</h4><ol>
<li>Dart函数声明如果没有显式声明返回值类型时会默认当做dynamic处理，<strong>注意，函数返回值没有类型推断</strong>：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> CALLBACK();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不指定返回类型，此时默认为dynamic，不是bool</span></span><br><span class="line">isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test(CALLBACK cb)&#123;</span><br><span class="line">   <span class="built_in">print</span>(cb()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错，isNoble不是bool类型</span></span><br><span class="line">test(isNoble);</span><br></pre></td></tr></table></figure>

<p>2.对于只包含一个表达式的函数，可以使用简写语法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases [ atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>3.函数作为变量</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> say = (str) &#123;</span><br><span class="line">  <span class="built_in">print</span>(str);</span><br><span class="line">&#125;;</span><br><span class="line">say(<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure>

<p>4.函数作为参数传递</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> execute(<span class="keyword">var</span> callback) &#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line">execute(() =&gt; <span class="built_in">print</span>(<span class="string">"xxx"</span>)); <span class="comment">//参数为() =&gt; print("xxx")</span></span><br></pre></td></tr></table></figure>

<p>5.可选的位置参数</p>
<p>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个不带可选参数调用这个函数的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>); <span class="comment">//结果是： Bob says Howdy</span></span><br></pre></td></tr></table></figure>

<p>下面是用第三个参数调用这个函数的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>); <span class="comment">//结果是：Bob says Howdy with a smoke signal</span></span><br></pre></td></tr></table></figure>

<p>6.可选的命名参数</p>
<p>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置[bold]和[hidden]标志</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数时，可以使用指定命名参数。例如：paramName: value</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>可选命名参数在Flutter中使用非常多。</p>
<p><font color="#dd0000"><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></font></p>
        
          <p class="article-more-link">
            <a href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ckal0v2aa0062l926bmj33zsj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Flutter从0到1构建大前端应用』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/" class="article-date">
  <time datetime="2020-05-06T04:29:29.217Z" itemprop="datePublished">2020-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/">读书笔记『Flutter从0到1构建大前端应用』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-Flutter简介"><a href="#第一章-Flutter简介" class="headerlink" title="第一章 Flutter简介"></a>第一章 Flutter简介</h3><p><strong>P4</strong>：Flutter Engine</p>
<ul>
<li>Skia：2D渲染引擎(Android系统自带，<strong>iOS系统不自带，因此iOS包所占用的存储空间更大</strong>)</li>
<li>Dart：Dart运行时</li>
<li>Text：文本排版引擎</li>
</ul>
<h3 id="第二章-Dart-语言入门"><a href="#第二章-Dart-语言入门" class="headerlink" title="第二章 Dart 语言入门"></a>第二章 Dart 语言入门</h3><p><strong>P18</strong>：Dart是一门强类型语言，在第一次赋值时，<strong>如果已经确定了是字符串类型，则不能更改为别的类型</strong>。如果真的想要改变，可以使用<strong>dynamic</strong>关键字。</p>
<p><strong>P19</strong>：num声明的变量可以加入的是int型，还可以被改成double型，但是反过来int声明的变量不能再赋值为double。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">30.2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>P23</strong>：使用bool表示布尔值，布尔值只有true和false；可以在debug模式下通过assert断言判断布尔值</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(a.isEmpty);</span><br></pre></td></tr></table></figure>

<p>创建一个不可变数组，使用const[…]</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><strong>P25</strong>：<font color="#dd0000"><strong>使用dynamic时会告诉编译器，我们不用做类型检测，并且知道自己在做什么。</strong></font></p>
<p><strong>P26</strong>：可以使用as，is关键字对类型进行检测</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> obj = &lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt;) &#123;</span><br><span class="line">  obj[<span class="string">'age'</span>] = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>~/ 除法，返回一个整数结果</strong></font></p>
        
          <p class="article-more-link">
            <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/" data-id="ckal0v29d004pl92603dxcuh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『深入理解Java虚拟机』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/" class="article-date">
  <time datetime="2020-04-19T14:29:40.479Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/">读书笔记『深入理解Java虚拟机』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##第一部分 走进Java</p>
<h3 id="第1章-走进Java"><a href="#第1章-走进Java" class="headerlink" title="第1章 走进Java"></a>第1章 走进Java</h3><p><strong>P11</strong>：HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以<code>方法</code>为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别处罚标准编译和OSR(栈上替换)编译动作。(这点在第11章关于热点代码的描述中有再次提到)</p>
<p><strong>P15</strong>：Dalvik VM并不是一个Java虚拟机，<strong>它没有遵循Java虚拟机规范，不能直接执行Java的Class文件</strong>，使用的是<code>寄存器架构</code>而不是JVM中常见的<code>栈架构</code>。但它执行的dex文件可以通过Class文件转化而来。在Android2.2上已提供即时编译器实现(JIT)，在执行性能上有了很大的提高。</p>
<h2 id="第二部分-自动内存管理机制"><a href="#第二部分-自动内存管理机制" class="headerlink" title="第二部分 自动内存管理机制"></a>第二部分 自动内存管理机制</h2><h3 id="第2章-Java内存区域与内存溢出异常"><a href="#第2章-Java内存区域与内存溢出异常" class="headerlink" title="第2章 Java内存区域与内存溢出异常"></a>第2章 Java内存区域与内存溢出异常</h3><p>运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、方法区(非堆)、堆。其中前三个为线程私有的。</p>
<p><strong>P39</strong>：程序计数器</p>
<p>程序计数器是一块较小的内存空间，可以看作是<code>当前线程</code>所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变之歌计数器的值来选取下一条需要执行的字节码指令的。<strong>程序计数器是线程私有的</strong>，这很容易理解。如果正在执行的是Native方法，这个计数器值则为空。<code>程序计数器是内存区域中唯一Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</code>(可能是因为它本身占据的内存很小吧)</p>
        
          <p class="article-more-link">
            <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/" data-id="ckal0v29j0054l926ao6n2r05" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android基础『V1V2V3签名』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" class="article-date">
  <time datetime="2020-04-10T07:24:34.404Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>基础概念</p>
<p>签名：在 APK 中写入一个「指纹」。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。</p>
<p>摘要算法：<font color="#dd0000"><strong>使用一段简单的看上去随机的不可逆向的固定长度的字符串来表示一个文件的唯一性。</strong></font>常见的摘要算法如MD5(128个比特位)、SHA-1算法(160/192/256个比特位)。</p>
<p>公钥密码体制：也称非对称算法，特点是<strong>公钥是公开的</strong>，私钥是保密的。常见的如：RSA。</p>
<p>展开讨论一下RSA：</p>
<ol>
<li>加密：公钥加密，私钥解密的过程，称为「加密」。</li>
<li><strong>签名：私钥加密，公钥解密的过程，称为「签名」。</strong>加签用来证明这段密文是有公钥对应的私钥拥有者发出的。</li>
</ol>
<p>网络传输一般不会对整个文件进行签名，因为非对称加密效率比较低。所以一般使用<font color="#dd0000"><strong>摘要算法+RSA算法</strong></font>实现，传输使用RSA的私钥对文件的摘要信息进行加密作为摘要；接受者接收到文件后，对文件使用相同的摘要算法对文件求摘要值，然后再使用公钥解密加密过得摘要，比较两个摘要值判断文件是否合法。</p>
<p>数字证书：尽管使用RSA +摘要算法可以实现文件的可靠性检测。但是仍然存在问题，<font color="#dd0000"><strong>问题在于公钥是公开的，</strong></font>比如某些钓鱼网站，直接下发一个他自己的公钥，那么用户就算验证了文件的合法性。依然会进圈套，因为用户不知道和他交互的是否是正确的对象。</p>
<p>所以需要一个权威的CA机构，用来<font color="#dd0000"><strong>颁发数字证书，用以认证用户手上公开的公钥</strong></font>，这些权威的CA机构将他们的证书先预置在机器里，然后使用他们的私钥对申请数字证书的公钥以及其他信息(有效期、签名算法、数字签名blalala)进行加密，从而得到一个数字证书。用来验证自己所访问的对象是否是正确的。</p>
<hr>
<p>Android中的签名方案</p>
<p><font color="#dd0000"><strong>V1</strong></font>：基于jarsigner(JDK自带工具，使用keystore文件进行签名) 或 apksigner(Android专门提供的，使用pk8、x509.pem进行签名)。keystore和pk8/x509.pem可以相互转换。</p>
<p>签名原理：首先keystore文件包含一个MD5和一个SHA1摘要。<strong>这也是很多开放平台需要我们上传的摘要数据</strong>。</p>
<p>签名APK后会在META-INF文件夹下生产CERT.RSA、CERT.SF、MANIFEST.MF三个文件。</p>
<p>在apk中，/META-INF文件夹中保存着apk的签名信息，一般至少包含三个文件，[CERT].RSA，[CERT].SF和MANIFEIST.MF文件。这三个文件就是对apk的签名信息。</p>
        
          <p class="article-more-link">
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" data-id="ckal0v28s003jl926705fh0o3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Java并发编程实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.097Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h3><p><strong>P1</strong>：在不同的<strong>进程</strong>之间可以通过一些<strong>粗粒度</strong>的通讯机制来完成交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。</p>
<p><strong>P7</strong>：安全性的含义是”永远不发生糟糕的事情”，而<strong>活跃性</strong>则关注于另一个目标，即<strong>某件正确的事情最终会发生</strong>。当某个操作无法继续执行下去时，就会发生活跃性问题。</p>
<p><strong>P8</strong>：在Servlet规范中，Servlet同样需要满足被多个线程同事调用，换句话说，<strong>Servlet需要是线程安全的。</strong></p>
<h3 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h3><p><strong>P11</strong>：要编写线程安全的代码，其核心在于<strong>要对状态访问操作进行管理</strong>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p>
<p><strong>P13</strong>：在线程安全性的定义中，最核心的概念就是<strong>正确性</strong>。正确性的含义是，<font color="#dd0000"><strong>某个类的行为与其规范完全一致</strong></font>。</p>
<p><strong>P15</strong>：当某个计算的正确性取决于多个线程<strong>交替执行时序</strong>时，那么久就会发生<font color="#dd0000"><strong>竞态条件</strong></font>。</p>
<p><strong>P16</strong>：竞态条件的本质——<strong>基于</strong>一种可能<font color="#dd0000"><strong>失效的观察结果</strong></font>来做出判断或者执行某个计算。</p>
<p><strong>P18</strong>：在java.util.concurrent.atomic包中包含了一些<strong>原子变量类</strong>，用于实现在<strong>数值</strong>和<font color="#dd0000"><strong>对象引用</strong></font>上的原子状态转换。如：<strong>AtomicLong</strong>，<strong>AtomicReference</strong>。</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ckal0v29i0050l926dqy04sx7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目『腾讯MMKV存储框架』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.095Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MMKV的介绍"><a href="#MMKV的介绍" class="headerlink" title="MMKV的介绍"></a>MMKV的介绍</h2><p>MMKV 是基于 <font color="#dd0000"><strong>mmap 内存映射</strong></font>的 key-value 组件，<strong>底层序列化/反序列化使用 protobuf 实现</strong>，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>高性能 实时写入</strong></li>
<li><strong>稳定 防crash</strong></li>
<li><strong>多进程访问</strong><br> 通过与 Android 开发同学的沟通，了解到系统自带的 SharedPreferences 对多进程的支持不好。<br> 现有基于 ContentProvider 封装的实现，虽然多进程是支持了，但是性能低下，经常导致 ANR。<br> 考虑到 mmap 共享内存本质上的多进程共享的，我们在这个基础上，深入挖掘了 Android 系统的能力，提供了可能是业界最高效的多进程数据共享组件。</li>
<li><strong>匿名内存</strong><br> 在多进程共享的基础上，考虑到某些敏感数据(例如密码)需要进程间共享，但是不方便落地存储到文件上，直接用 mmap 不合适。<br> 我们了解到 Android 系统提供了 Ashmem 匿名共享内存的能力，发现它在进程退出后就会消失，不会落地到文件上，非常适合这个场景。<br> 我们很愉快地提供了 Ashmem MMKV 的功能。</li>
<li><strong>数据加密</strong><br> 不像 iOS 提供了硬件层级的加密机制，在 Android 环境里，数据加密是非常必须的。<br> MMKV 使用了 AES CFB-128 算法来加密/解密。我们选择 CFB 而不是常见的 CBC 算法，<br> 主要是因为 MMKV 使用 append-only 实现插入/更新操作，流式加密算法更加合适。</li>
<li><strong>数据有效性</strong></li>
</ul>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" data-id="ckal0v29a004gl92620ta24et" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目——OkHttp『源码学习』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.091Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OKHttp是个优秀的开源项目，值得学习。但是代码量比EventBus、Retrofit之类的大多了。想要一下子没有遗漏的都搞清楚不是一件容易的事情。这篇博客，是我在学习过程中的一些问题，有些自觉找到了答案，有些还不知道如何回答，留待以后补充吧。</p>
<h2 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h2><ol>
<li><p>异步，同步队列共用线程池吗？共用请求数量限制(maxRequests和maxRequestsPerHost)吗？</p>
<p>答：<code>请求数量限制只对异步队列有效</code>，对于同步任务不做限制，只管添加执行就得了。</p>
</li>
<li><p>为什么不直接使用线程池，而是自己另外维护了工作队列？</p>
<p>答：首先这里使用了的线程池是基于同步队列的，而同步队列本身是不支持工作队列的，所以需要一个额外的工作队列来维护任务的提交工作。</p>
</li>
<li><p>为什么OkHttp的异步任务选择使用两个队列维护？而不是使用一个工作队列实现？</p>
<p>答：说下我自己的看法，首先为什么需要两个队列，因为在提交异步任务是需要统计当前的运行中的任务数量，使用一个队列的话，还需要遍历队列中的任务状态，而将等待运行和运行中分离开来可以避免这种困扰，减少问题发生的可能性。</p>
</li>
<li><p>等待队列中的任务何时触发运行？</p>
<p>答：不管是异步任务还是同步任务，任务的执行代码都包含在一个try…catch代码块中，该代码块的finally中执行dispatcher.finished(this)，在finished()方法中首先会从异步运行中队列中移除代表当前任务的Call对象，然后会去异步等待就绪队列中拿任务放到异步运行中队列中，并执行任务。看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.finished()</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//首先从运行队列中移除当前已完成的Call对象</span></span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      <span class="comment">//这个promoteCalls()方法中，会从异步就绪等待队列中拿取任务放到异步运行队列并执行</span></span><br><span class="line">      <span class="keyword">if</span> (promoteCalls) promoteCalls(); </span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有任务在运行时，触发回调，暂时不知道使用场景</span></span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下调度等待就绪任务的promoteCalls()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.promoteCalls()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//从当前等待就绪队列中移除当前Call对象</span></span><br><span class="line">        i.remove();</span><br><span class="line">        <span class="comment">//添加Call到运行队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果okhttpclient不作为单例使用，那么线程池是否就有多个了，Dispatcher呢？</p>
<p><strong>答</strong>：每个OkHttpClient对象实例对应一个Dispatcher，因此也就意味着多个OkHttpClient对应着多个线程池。</p>
</li>
<li><p>RetryAndFollowUpInterceptor中的重试指的是什么？是重试连接还是跳转？还是包含了这两个动作：重连次数和跳转数限制？</p>
<p><strong>答</strong>：</p>
</li>
<li><p>缓存需要手动指定才能生效吗？缓存机制是什么？</p>
</li>
<li><p>DiskLruCache算法的具体细节是什么？缓存清理线程的工作原理是什么？</p>
</li>
<li><p>为什么要把AsyncCall定义成RealCall的内部类？有什么好处吗？</p>
</li>
<li><p>为什么缓存管理需要另外一个日志文件？</p>
</li>
<li><p>为什么DiskLruCache的内部类Entry需要一个cleanFiles文件数组和一个dirtyFiles文件数组？</p>
</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" data-id="ckal0v2a90061l926fwjvbzd0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java进阶『Javassist学习笔记』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.088Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.javassist.org/" target="_blank" rel="noopener">http://www.javassist.org/</a></p>
<h3 id="文档翻译"><a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h3><ol>
<li><p>读取和写入字节码</p>
<p>Javassist是一个用于处理Java字节码的类库。Java字节码被存储在class文件中，每个class文件包含一个Java类或者接口。</p>
<p>Javassist.CtClass是一个class文件的抽象代表。一个CtClass对象可以(在编译期)用来处理一个class文件。以下面代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段代码首先获得一个ClassPool对象，ClassPool是CtClass所代表的class文件的容器。ClassPool会在构造CtClass对象时去读取class文件，并且持有构造好的CtClass对象以便之后使用。想要修改一个class，首先需要通过ClassPool获取到一个CtClass对象。ClassPool对象的get()方法可以用来实现这个目的。</p>
<p>从实现细节来说，ClassPool是一个以class的名字为key用来存储CtClass对象的哈希表，get()会从哈希表中根据传入的key查找CtClass对象。如果未能查找到缓存对象，get()方法会创建一个新的CtClass对象，并将这个新建的对象保存到哈希表中，然后返回给调用方。</p>
<p>从ClassPool中获取到的CtClass对象可以被修改，在上面的代码中，cc的superclass被修改成了test.Point。</p>
<p>writeFile()实现了从CtClass对象到class文件的转换，并将他写入到了本地磁盘。Javassist也提供了一种直接获取修改过的二进制代码的方法toBytecode()。除此之外，还可以直接载入CtClass：</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" data-id="ckal0v2960048l926cxec482k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/" rel="tag">Android，性能优化，电量优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JetPack/" rel="tag">JetPack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paging/" rel="tag">Paging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Room/" rel="tag">Room</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava2/" rel="tag">RxJava2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" rel="tag">开源项目学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Android%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/" style="font-size: 10px;">Android，性能优化，电量优化</a> <a href="/tags/Flutter/" style="font-size: 12.5px;">Flutter</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JetPack/" style="font-size: 12.5px;">JetPack</a> <a href="/tags/Kotlin/" style="font-size: 12.5px;">Kotlin</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Paging/" style="font-size: 10px;">Paging</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Room/" style="font-size: 10px;">Room</a> <a href="/tags/RxJava2/" style="font-size: 12.5px;">RxJava2</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">开源项目学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">源码学习</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 10px;">组件化</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EAndroid%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86%E3%80%8F/">Android『进阶解密』</a>
          </li>
        
          <li>
            <a href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/">Android『电量检测及优化使用』</a>
          </li>
        
          <li>
            <a href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Flutter实战』</a>
          </li>
        
          <li>
            <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/">读书笔记『Flutter从0到1构建大前端应用』</a>
          </li>
        
          <li>
            <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/">读书笔记『深入理解Java虚拟机』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ > </script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>