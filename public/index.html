<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android『电量监测及优化使用』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/" class="article-date">
  <time datetime="2020-05-12T02:38:44.422Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/">Android『电量检测及优化使用』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="本地电量检测"><a href="#本地电量检测" class="headerlink" title="本地电量检测"></a>本地电量检测</h1><p>做电量优化第一步，首先需要知道当前APP的耗电情况，大概步骤：</p>
<ol>
<li>使用Monkey、Appium、MonkeyRunner等自动化工具产生测试数据，本文基于Monkey进行讨论。</li>
<li>采集耗电信息，本方案基于系统自带的命令，生成电池使用记录文本batterystats.txt文件。</li>
<li>之后导出该文件</li>
<li>最后使用第三方工具分析数据，本文使用。</li>
</ol>
<h2 id="Monkey命令介绍"><a href="#Monkey命令介绍" class="headerlink" title="Monkey命令介绍"></a>Monkey命令介绍</h2><p>参考：<a href="https://blog.csdn.net/qq_30993595/article/details/80748559" target="_blank" rel="noopener">https://blog.csdn.net/qq_30993595/article/details/80748559</a></p>
<p><img src="http://47.110.40.63:8080/img/blog/%E9%9D%9E%E6%9E%B6%E6%9E%84/Monkey%E5%91%BD%E4%BB%A4help.png" alt="img"></p>
<ol>
<li><p><font color="#dd0000"><strong>-p 用于约束限制，用此参数指定一个包</strong></font>，指定包后Monkey将被允许启动指定应用；<strong>如果不指定包，  Monkey将被允许随机启动设备中的应用</strong>（主Activity有android.intent.category.LAUNCHER 或android.intent.category.MONKEY类别 ）</p>
<p>比如 adb shell monkey -p <strong>xxx.xxx.xxx</strong> 1  ; xxx.xxx.xxx 表示应用包名，1 表示monkey模拟用户随机事件参数，最低1，这样就能把应用启动起来</p>
</li>
<li><p>-c 指定Activity的category类别，如果不指定，默认是CATEGORY_LAUNCHER 或者 Intent.CATEGORY_MONKEY；不太常用的一个参数</p>
</li>
<li><p><strong>-v 用于指定反馈信息级别，也就是日志的详细程度</strong>，分Level1、Level2、Level3；-v 默认值，仅提供启动提示，操作结果等少量信息 ，也就是Level1，比如adb shell monkey -p  xxx.xxx.xxx -v 1 ；-v -v 提供比较详细信息，比如启动的每个activity信息 ，也就是Level2，比如adb shell monkey -p xxx.xxx.xxx -v -v 1 ；-v -v -v 提供最详细的信息 ，比如adb shell monkey -p xxx.xxx.xxx -v -v -v 1 </p>
</li>
<li><p><font color="#dd0000"><strong>-s 伪随机数生成器的种子值，如果我们两次monkey测试事件使用相同的种子值，会产生相同的事件序列</strong></font>；如果不指定种子值，系统会产生一个随机值。种子值对我们复现bug很重要。使用如下adb shell monkey -p xxx.xxx.xxx -s 11111 10；这也是伪随机事件的原因，因为这些事件可以通过种子值进行复现</p>
</li>
<li><p><font color="#dd0000"><strong>–ignore-crashes 忽略异常崩溃，如果不指定，那么在monkey测试的时候，应用发生崩溃时就会停止运行</strong></font>；如果加上了这个参数，monkey就会运行到指定事件数才停止。比如adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-crashes 10 </p>
</li>
<li><p><font color="#dd0000"><strong>–ignore-timeouts 忽略ANR</strong></font>，情况与4类似，当发送ANR时候，让monkey继续运行。比如adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-timeouts 10</p>
</li>
<li><p><font color="#dd0000"><strong>–ignore-native-crashes 忽略native层代码的崩溃</strong></font>，情况与4类似，比如adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-native-crashes 10</p>
</li>
<li><p>–ignore-security-exceptions 忽略一些许可错误，比如证书许可，网络许可，adb shell monkey -p xxx.xxx.xxx -v -v -v  –ignore-security-exceptions 10</p>
</li>
<li><p>–monitor-native-crashes 是否监视并报告native层发送的崩溃代码，adb shell monkey -p xxx.xxx.xxx -v -v -v  –monitor-native-crashes 10</p>
</li>
<li><p>–kill-procress-after-error 用于在发送错误后杀死进程</p>
</li>
<li><p>–hprof  设置后，在Monkey事件序列之前和之后立即生产分析报告，保存于data/mic目录，不过将会生成大量几兆文件，谨慎使用</p>
</li>
<li><p><font color="#dd0000"><strong>–throttle 设置每个事件结束后延迟多少时间再继续下一个事件，降低cpu压力</strong></font>；如果不设置，事件与事件之间将不会延迟，事件将会尽快生成；一般设置300ms，因为人最快300ms左右一个动作，比如 adb shell monkey -p xxx.xxx.xxx -v -v -v  –throttle 300 10</p>
</li>
<li><p>–pct-touch 设置触摸事件的百分比，即手指对屏幕进行点击抬起(down-up)的动作；不做设置情况下系统将随机分配各种事件的百分比。比如adb shell monkey -p xxx.xxxx.xxx –pct-touch 50 -v -v 100 ，这就表示100次事件里有50%事件是触摸事件</p>
</li>
<li><p>–pct-motion 设置移动事件百分比，这种事件类型是由屏幕上某处的一个down事件-一系列伪随机的移动事件-一个up事件，即点击屏幕，然后直线运动，最后抬起这种运动。</p>
</li>
<li><p>–pct-trackball 设置轨迹球事件百分比，这种事件类型是一个或者多个随机移动，包含点击事件，这里可以是曲线运动，不过现在手机很多不支持，这个参数不常用</p>
</li>
<li><p>–pct-syskeys 设置系统物理按键事件百分比，比如home键，音量键，返回键，拨打电话键，挂电话键等</p>
</li>
<li><p>–pct-nav 设置基本的导航按键事件百分比，比如输入设备上的上下左右四个方向键</p>
</li>
<li><p>–pct-appswitch 设置monkey使用startActivity进行activity跳转事件的百分比，保证界面的覆盖情况</p>
</li>
<li><p>–ptc-anyevent 设置其它事件百分比</p>
</li>
<li><p>–ptc-majornav 设置主导航事件的百分比</p>
</li>
<li><p>保存dos窗口打印的monkey信息，在monkey命令后面补上输出地址，如adb shell monkey -p xxx.xxxx.xxx  -v -v 100 &gt; D:\monkey.txt；这样monkey测试结束后，所有打印的信息都会输出到这个文件里</p>
</li>
<li><p><font color="#dd0000"><strong>通过adb bugreport 命令可以获取整个android系统在运行过程中所有app的内存使用情况，cpu使用情况，activity运行信息等，包括出现异常等信息。使用方法 adb bugreport &gt; bugreport.txt ;这样在当前目录就会产生一个txt文件和一个压缩包，具体信息可在压缩包查看，txt文件只会记录压缩包的生成过程信息</strong></font></p>
</li>
<li><p>-f 加载monkey脚本文件进行测试，比如 adb shell monkey -f sdcard/monkey.txt -v -v 500</p>
</li>
</ol>
<p>##Monkey使用</p>
<p>1.进入adb目录</p>
<p>2.通过adb install apk名字</p>
<p>3.<font color="#dd0000"><strong>输入adb shell monkey -p xxx.xxxx.xxx  -s 123123 –throttle 300 -v -v 20 &gt; d:\monkey.txt，这里指定了seed值，每个事件之间休息300ms，执行了20个事件，然后将日志信息保存在了monkey.txt文件中</strong></font></p>
<p>4.打开文件，查看信息如下:</p>
<blockquote>
<p> Monkey: seed=123123 count=20 //<font color="#dd0000"><strong>本次事件序列seed值是指定的123123，方便出现bug后再复现 执行事件次数是20</strong></font><br>:AllowPackage: com.android.mangodialog // 被测试的应用包名<br>:IncludeCategory: android.intent.category.LAUNCHER //启动的主activity的两种类别<br>:IncludeCategory: android.intent.category.MONKEY<br>// Selecting main activities from category android.intent.category.LAUNCHER<br>//   + Using main activity com.android.mangodialog.MainActivity (from package com.android.mangodialog) //该应用符合这种类别的activity<br>// Selecting main activities from category android.intent.category.MONKEY<br>// Seeded: 123123<br>// Event percentages://各种事件的百分比，不同厂家设备可能有所不同<br>//   0: 15.0%  //可通过–pct-touch 参数设置的事件的百分比 常用<br>//   1: 10.0%  //可通过–pct-motion 参数设置的事件的百分比 常用<br>//   2: 2.0%   //可通过–pct-pinchzoom 参数设置的事件的百分比<br>//   3: 15.0%  //可通过–pct-trackball 参数设置的事件的百分比<br>//   4: -0.0%<br>//   5: -0.0%<br>//   6: 25.0%  //可通过–pct-nav 参数设置的事件的百分比<br>//   7: 15.0%  //可通过–pct-majornav 参数设置的事件的百分比<br>//   8: 2.0%   //可通过–pct-syskeys 参数设置的事件的百分比 常用<br>//   9: 2.0%   //可通过–pct-appswitch 参数设置的事件的百分比 常用<br>//   10: 1.0%  //可通过–pct-flip 参数设置的事件的百分比<br>//   11: 13.0% //可通过–pct-anyevent 参数设置的事件的百分比<br>//启动应用的activity<br>:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.android.mangodialog/.MainActivity;end<br>    // Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.android.mangodialog/.MainActivity } in package com.android.mangodialog<br>Sleeping for 300 milliseconds //设置的事件之间间隔300ms 下面就是执行点击事件<br>:Sending Key (ACTION_DOWN): 82    // KEYCODE_MENU<br>:Sending Key (ACTION_UP): 82    // KEYCODE_MENU<br>Sleeping for 300 milliseconds<br>:Sending Key (ACTION_DOWN): 23    // KEYCODE_DPAD_CENTER<br>:Sending Key (ACTION_UP): 23    // KEYCODE_DPAD_CENTER<br>Sleeping for 300 milliseconds<br>    // Allowing start of Intent { cmp=com.android.mangodialog/.MainActivity2 } in package com.android.mangodialog<br>:Sending Key (ACTION_DOWN): 22    // KEYCODE_DPAD_RIGHT<br>:Sending Key (ACTION_UP): 22    // KEYCODE_DPAD_RIGHT<br>Sleeping for 300 milliseconds<br>:Sending Key (ACTION_DOWN): 21    // KEYCODE_DPAD_LEFT<br>:Sending Key (ACTION_UP): 21    // KEYCODE_DPAD_LEFT<br>Sleeping for 300 milliseconds<br>:Sending Touch (ACTION_DOWN): 0:(1017.0,280.0)<br>:Sending Touch (ACTION_UP): 0:(1021.8751,281.12732)<br>Sleeping for 300 milliseconds<br>:Sending Touch (ACTION_DOWN): 0:(1005.0,1599.0)<br>:Sending Touch (ACTION_UP): 0:(994.4962,1589.7715)<br>Sleeping for 300 milliseconds<br>:Sending Key (ACTION_DOWN): 2    // KEYCODE_SOFT_RIGHT<br>:Sending Key (ACTION_UP): 2    // KEYCODE_SOFT_RIGHT<br>Sleeping for 300 milliseconds<br>:Sending Key (ACTION_DOWN): 20    // KEYCODE_DPAD_DOWN<br>:Sending Key (ACTION_UP): 20    // KEYCODE_DPAD_DOWN<br>Sleeping for 300 milliseconds<br>:Sending Key (ACTION_DOWN): 22    // KEYCODE_DPAD_RIGHT<br>:Sending Key (ACTION_UP): 22    // KEYCODE_DPAD_RIGHT<br>Sleeping for 300 milliseconds //轨迹球运动<br>:Sending Trackball (ACTION_MOVE): 0:(4.0,-5.0)//手机屏幕上的坐标<br>Events injected: 20 //monkey共执行了20次事件<br>:Sending rotation degree=0, persist=false<br>:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0<br>//<font color="#dd0000"><strong>测试过程中的网络状态，花费了3064ms连接，既没有连接上手机网络，也没有连接上wifi</strong></font></p>
<p>Network stats: elapsed time=3064ms (0ms mobile, 0ms wifi, 3064ms not connected) </p>
<p>// Monkey finished //monkey测试结束</p>
</blockquote>
<p>5.平时会使用比较复杂的参数去测试，如下</p>
<p>adb shell monkey -v -v -v -s 123123 –throttle 300 –pct-touch 40 –pct-motion 25 –pct-appswitch 25 –pct-syskeys 10 –pct-majornav 0 –pct-nav 0 –pct-trackball 0 –ignore-crashes –ignore-timeouts –ignore-native-crashes -p xxx.xxx.xxx 100000 &gt; d:\monkey.txt</p>
<p>具体什么意思就不再一一解释了。</p>
<p>6.其实我们比较关注的是app在使用过程中出现的错误信息，像上面我们选择忽略掉错误情况，这样当monkey执行结束后，相关的信息会被写入到monkey文件中，但是错误信息比如crash，anr等信息会打印在dos窗口，这些错误信息会明确的指出哪里发生的错误；<font color="#dd0000"><strong>如果需要复现，我们可以把忽略参数去掉，然后通过相同的seed值再次进行monkey测试，直到发生错误跳出monkey测试，我们再查看</strong></font>，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.act_main2);</span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我这第二个activity的oncreate方法中写这个会报错的代码，然后在第一个activity的一个按钮中进行跳转进入这个activity，接下来进行monkey测试来复现这个bug</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p xxx.xxx.xxx -s 123456 -v -v 2000  &gt; d:\monkey.txt</span><br></pre></td></tr></table></figure>

<p>我们看这个文件</p>
<blockquote>
<p>:Sending Trackball (ACTION_MOVE): 0:(4.0,-3.0)<br>:Sending Trackball (ACTION_MOVE): 0:(-2.0,1.0)<br>:Sending Trackball (ACTION_DOWN): 0:(0.0,0.0)<br>:Sending Trackball (ACTION_UP): 0:(0.0,0.0)<br>Sleeping for 300 milliseconds<br>    // Allowing start of Intent { cmp=com.android.mangodialog/.MainActivity2 } in package com.android.mangodialog<br>** Monkey aborted due to error.</p>
<p>Events injected: 190</p>
</blockquote>
<p>这里可以看到是当打开MainActivity2的时候monkey发生错误退出，只执行了190个事件。至于错误信息打印在了dos窗口。</p>
<p><font color="#dd0000"><strong>这里我们也可以通过adb bugreport命令将手机运行日志导出来查看，这里面的信息更详细，包括出错信息</strong></font>。</p>
<blockquote>
<p>//6.0及以下设备<br>adb bugreport &gt; bugreport.txt<br>//7.0及以上设备<br>adb bugreport bugreport.zip</p>
</blockquote>
<p>###其他常用命令</p>
<p>测试冷启动耗时</p>
<p>adb shell am start -W -n PACKAGE/ACTIVITY</p>
<p>测试热启动耗时</p>
<p>adb shell am start -W -n PACKAGE/ACTIVITY</p>
<p>停止：</p>
<p>adb shell am force-stop PACKAGE</p>
<p>随机事件 </p>
<p>adb shell monkey -v -p PACKAGE –pct-touch 100 100</p>
<p>##数据准备</p>
<p>battery-historian工具需要使用bugreport中的Battery History</p>
<p>先断开adb服务，然后开启adb服务<br>adb kill-server 这一步很重要，因为当我们开发时做电量记录时会打开很多可能造成冲突的东西。为了保险起见我们重启adb。<br>adb devices就会自动连接查找手机。当然也可以</p>
<p>adb start-server<br><strong>重置电池数据收集</strong><br>数据，我们在开始的时候需要通过以下命令来打开电池数据的获取以及重置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys batterystats --enable full-wake-history</span><br><span class="line">adb shell dumpsys batterystats --reset</span><br></pre></td></tr></table></figure>

<p><strong>获取电量报告</strong></p>
<p>这里要<strong>注意手机版本</strong>，不然后期向Battery Historian导入bugreport.txt文件时会提示“bugreport.txt does not contain a valid bugreport file”</p>
<ol>
<li><p>从Android 7.0和更高版本的开发设备中获得bug报告:</p>
<p><code>cd /Users/weixiangyang/Desktop/</code></p>
<p><code>adb bugreport bugreport.zip</code></p>
</li>
<li><p>从设备6.0和更低版本的开发设备中获得bug报告:</p>
<ol>
<li>获取bugreport信息（记录了从开机之后详细的dumpsys,dumpstate和logcat信息）：<br><code>adb bugreport &gt; 存放的电脑地址/bugreport.txt</code></li>
<li>获取dumpsys信息（获取系统信息：比如内存，CPU，accounts，activities，wifi等信息）<br><code>adb shell dumpsys batterystats &gt; 存放的电脑地址/batterystats.txt</code><br>或者获取指定的应用程序的dumpsys信息：<br><code>adb shell dumpsys batterystats &gt; 包名 &gt; 存放的电脑地址/batterystats.txt</code></li>
</ol>
</li>
</ol>
<p>##分析数据</p>
<h3 id="准备分析工具环境"><a href="#准备分析工具环境" class="headerlink" title="准备分析工具环境"></a>准备分析工具环境</h3><p>本文使用Google的-battery-historian，本文基于Docker搭建环境</p>
<p><strong>通过安装Docker环境来安装（这种简单方便）</strong></p>
<ol>
<li>Docker官方下载地址： Mac：<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/</a> Windows：<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/</a></li>
<li>查看是否安装成功： 执行：<code>docker version</code></li>
</ol>
<p><img src="http://47.110.40.63:8080/img/blog/%E9%9D%9E%E6%9E%B6%E6%9E%84/docker%E7%89%88%E6%9C%AC.png" alt="img"></p>
<ol start="3">
<li>将docker添加到环境变量</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1.打开.bash_profile</span><br><span class="line">vi .bash_profile</span><br><span class="line">//2.插入Docker到环境变量</span><br><span class="line">export DOCKER_PATH="/Applications/Docker.app/Contents/Resources/bin"</span><br><span class="line">export PATH=".$PATH:$DOCKER_PATH"</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过docker run启动分析页面（<font color="#dd0000"><strong>这一步需要翻墙!!</strong></font>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P gcr.io/android-battery-historian/stable:3.0 --port 9999</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>上传分析文件进行数据分析</li>
</ol>
<p>在浏览器打开：<a href="http://localhost:9999页面，上传得到的数据文件，进行分析">http://localhost:9999页面，上传得到的数据文件，进行分析</a></p>
<p><img src="http://47.110.40.63:8080/img/blog/%E9%9D%9E%E6%9E%B6%E6%9E%84/%E7%94%B5%E9%87%8F%E5%88%86%E6%9E%90%E6%88%AA%E5%9B%BE.png" alt="img"></p>
<p>#如何进行电量优化?</p>
<p>了解手机关键耗电的地方及分析耗电的工具后。接下来就是我们的核心，如何来进行电量的优 化?首先我们先简单总结汇总一下耗电的相关因素</p>
<ul>
<li>屏幕亮暗相关</li>
<li>设备 awake,sleep 的切换,尤其是唤醒.</li>
<li>CPU 运行相关</li>
<li>网络</li>
<li>传感器</li>
</ul>
<p>我们都知道屏幕的渲染及 CPU 的运行是耗电的主要因素之一。所以当我们在做内存优化、渲染优化、计算优化的时候，就已然在做电量优化。所以在平时的开发中，我们要注意点滴性能 的优化积累，实际上当我们来做电量分析的时候，也是在找自己挖的坑。所以尽量有意识在项 目的开发过程中尽量少挖坑，这一点是我们在分析其他优化项首先要提到的一个点。</p>
<h1 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h1><h2 id="监听手机充电状态"><a href="#监听手机充电状态" class="headerlink" title="监听手机充电状态"></a>监听手机充电状态</h2><p>我们可以通过下面的代码来获取手机的当前充电状态:</p>
<p>这里我们就需要思考，根据具体的业务，<font color="#dd0000"><strong>考虑将一些不需要及时地和用户交互的操作放到充电的时候去做</strong></font>。比如：360 手机助手，当充上电的时候，才会自动清理手机垃圾，自动备份上传图片、联系人 等到云端，从而避免当用户手机低电量时，任然继续进行耗电操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前是否正在充电</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCharging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IntentFilter filter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">  Intent batteryStatus = <span class="keyword">this</span>.registerReceiver(<span class="keyword">null</span>,filter);</span><br><span class="line">  <span class="keyword">int</span> chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED,-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">boolean</span> usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB);</span><br><span class="line">  <span class="keyword">boolean</span> acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);</span><br><span class="line">  <span class="keyword">boolean</span> wirelessCharge = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">    wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (usbCharge || acCharge || wirelessCharge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，我们可以判断当前是否为充电器充电(acCharge)，从而选择性的进行一些耗时动作。</p>
<h2 id="屏幕唤醒"><a href="#屏幕唤醒" class="headerlink" title="屏幕唤醒"></a>屏幕唤醒</h2><p>当 Android 设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止 CPU 的运行，这样可以防 止电池电量掉的快。但有些时候我们需要改变 Android 系统默认的这种状态:比如玩游戏时我 们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要 CPU 一直运行直到任务完成。</p>
<p>保持屏幕常亮比较好的方式是在 Activity 中使用 FLAG_KEEP_SCREEN_ON 的 Flag。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br></pre></td></tr></table></figure>

<p>这个方法的好处是不像唤醒锁(wake locks)，需要一些特定的权限(permission)。并且能 正确管理不同 app 之间的切换，不用担心无用资源的释放问题。另一个方式是在布局文件中使用 android:keepScreenOn 属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:keepScreenOn=<span class="string">"true"</span></span><br></pre></td></tr></table></figure>

<p>所以这里我们需要根据自己的 APP 实际情况，根据业务来控制好是否保持屏幕常量。比如 APP 需要支持视频播放。那么在播放的界面需要控制好不熄屏，当退出播放时，当然就没有了 这个设置。</p>
<h2 id="WakeLock"><a href="#WakeLock" class="headerlink" title="WakeLock"></a>WakeLock</h2><p><font color="#dd0000"><strong>wakelock是一种锁的机制，只要有应用拿着这个锁，CPU就无法进入休眠状态，一直处于工作状态</strong></font>。比如，手机屏幕在屏幕关闭的时候，有些应用依然可以唤醒屏幕提示用户消息，这里就是用到了wakelock锁机制，虽然手机屏幕关闭了，但是这些应用依然在运行着。手机耗电的问题，大部分是开发人员没有正确使用这个锁，成为”待机杀手”。</p>
<p>Android手机有两个处理器，一个叫Application Processor（AP），一个叫Baseband Processor（BP）。<strong>AP是ARM架构的处理器，用于运行Linux+Android系统；BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高</strong>。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP、LCD、WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。</p>
<p><strong>Android为了确保应用程序中关键代码的正确执行，提供了Wake Lock的API，使得应用程序有权限通过代码阻止AP进入休眠状态</strong>。但如果不领会Android设计者的意图而滥用Wake Lock API，为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，就会成为待机电池杀手。</p>
<p><strong>WakeLock的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); </span><br><span class="line">WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, <span class="string">"MyWakelockTag"</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">标记值</th>
<th align="left">CPU</th>
<th align="left">屏幕</th>
<th align="left">键盘</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PARTIAL_WAKE_LOCK</td>
<td align="left">开启</td>
<td align="left">关闭</td>
<td align="left">关闭</td>
</tr>
<tr>
<td align="left">SCREEN_DIM_WAKE_LOCK</td>
<td align="left">开启</td>
<td align="left">变暗</td>
<td align="left">关闭</td>
</tr>
<tr>
<td align="left">SCREEN_BRIGHT_WAKE_LOCK</td>
<td align="left">开启</td>
<td align="left">变亮</td>
<td align="left">关闭</td>
</tr>
<tr>
<td align="left">FULL_WAKE_LOCK</td>
<td align="left">开启</td>
<td align="left">变亮</td>
<td align="left">变亮</td>
</tr>
</tbody></table>
<p>自API等级17开始，FULL_WAKE_LOCK将被弃用。应用应使用<strong>FLAG_KEEP_SCREEN_ON</strong>。</p>
<p>WakeLock类可以用来控制设备的工作状态。使用该类中的acquire可以使CPU一直处于工作的状态，如果不需要使CPU处于工作状态就调用release来关闭。</p>
<p>(1)、自动release</p>
<p>如果我们调用的是acquire(long timeout)那么就无需我们自己手动调用release()来释放锁，系统会帮助我们在timeout时间后释放。</p>
<p>(2)、手动release</p>
<p>如果我们调用的是acquire()那么就需要我们自己手动调用release()来释放锁。</p>
<p>最后使用WakeLock类记得加上如下权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WAKE_LOCK"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>注意:自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。</p>
<p>注意:<font color="#dd0000"><strong>在使用该类的时候，必须保证 acquire 和 release 是成对出现的</strong></font>。不然当我们业务已经不需要时， 当 CPU 处于唤醒状态，这个时候就会损耗多余的电量。</p>
<h2 id="JobScheduler"><a href="#JobScheduler" class="headerlink" title="JobScheduler"></a>JobScheduler</h2><p>自 Android 5.0 发布以来，JobScheduler已成为执行后台工作的很好的方式，其工作方式有利于用户在适当的时机执行正确的事情。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。<strong>JobSchedule 的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理</strong>。这样做有两个好处:</p>
<ul>
<li><strong>避免频繁的唤醒硬件模块，造成不必要的电量消耗</strong>。</li>
<li><strong>避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量</strong>。</li>
</ul>
<h2 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h2><p><strong>选择合适的 Location Provider</strong></p>
<p>Android 系统支持多个 Location Provider:</p>
<ul>
<li><strong>GPS_PROVIDER:</strong> GPS 定位，利用 GPS 芯片通过卫星获得自己的位置信息。定位精准度高，一般在 10 米左右， 耗电量大;但是在室内，GPS 定位基本没用。</li>
<li><strong>NETWORK_PROVIDER:</strong> 网络定位，利用手机基站和 WIFI 节点的地址来大致定位位置，这种定位方式取决于服务器，即取决于将基站或 WIF 节点信息翻译成位置信息的服务器的能力。</li>
<li><strong>PASSIVE_PROVIDER:</strong> <font color="#dd0000"><strong>被动定位，就是用现成的，当其他应用使用定位更新了定位信息，系统会保存下来，该应用接 收到消息后直接读取就可以了</strong></font>。</li>
</ul>
<p><strong>及时注销定位监听</strong></p>
<p>在获取到定位之后或者程序处于后台时，注销定位监听，此时监听 GPS 传感器相当于执行 no- op(无操作指令)，用户不会有感知但是却耗电。</p>
<p><strong>多模块使用定位尽量复</strong></p>
<p>多个模块使用定位，尽量复用上一次的结果，而不是都重新走定位的过程，节省电量损耗;例 如:在应用启动的时候获取一次定位，保存结果，之后再用到定位的地方都直接去取。</p>
<p>##传感器</p>
<p><strong>使用传感器，选择合适的采样率，越高的采样率类型则越费电</strong>。</p>
<ul>
<li>SENSOR_DELAY_NOMAL (200000 微秒)</li>
<li>SENSOR_DELAY_UI (60000 微秒)</li>
<li>SENSOR_DELAY_GAME (20000 微秒)</li>
<li>SENSOR_DELAY_FASTEST (0 微秒)</li>
</ul>
<p>参考：<a href="https://www.jianshu.com/p/c86021fe958d" target="_blank" rel="noopener">https://www.jianshu.com/p/c86021fe958d</a></p>
<p><a href="https://blog.csdn.net/wdx_1136346879/article/details/86493355" target="_blank" rel="noopener">https://blog.csdn.net/wdx_1136346879/article/details/86493355</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/" data-id="ckacju80d0032f226f4qmde9t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/" rel="tag">Android，性能优化，电量优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Flutter实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-05-11T23:27:03.067Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Flutter实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##第一章 起步</p>
<h3 id="1-2：初识Flutter"><a href="#1-2：初识Flutter" class="headerlink" title="1.2：初识Flutter"></a>1.2：初识Flutter</h3><p><strong>静态编译与动态解释</strong>：<font color="#dd0000"><strong>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”</strong></font>。<strong>是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT</strong>。</p>
<p><strong>为什么Flutter选择Dart作为开发语言？</strong></p>
<ol>
<li><p>Dart运行时和编译器支持Flutter的两个关键特性的组合：</p>
<p><strong>基于JIT的快速开发周期</strong>：<font color="#dd0000"><strong>Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间</strong></font>；</p>
<p><strong>基于AOT的发布包</strong>:<font color="#dd0000">Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能</font>。而JavaScript则不具有这个能力。</p>
</li>
<li><p><strong>高性能</strong></p>
<p>Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。</p>
</li>
<li><p><strong>快速内存分配</strong></p>
<p>Flutter框架<strong>使用函数式流</strong>，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。</p>
</li>
<li><p><strong>类型安全</strong></p>
<p><strong>由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力</strong>。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。</p>
</li>
<li><p><strong>Dart团队就在你身边</strong></p>
<p>看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。”</p>
</li>
</ol>
<h3 id="1-4-Dart语言简介"><a href="#1-4-Dart语言简介" class="headerlink" title="1.4 Dart语言简介"></a>1.4 Dart语言简介</h3><h4 id="1-4-2-函数"><a href="#1-4-2-函数" class="headerlink" title="1.4.2 函数"></a>1.4.2 函数</h4><ol>
<li>Dart函数声明如果没有显式声明返回值类型时会默认当做dynamic处理，<strong>注意，函数返回值没有类型推断</strong>：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> CALLBACK();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不指定返回类型，此时默认为dynamic，不是bool</span></span><br><span class="line">isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test(CALLBACK cb)&#123;</span><br><span class="line">   <span class="built_in">print</span>(cb()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错，isNoble不是bool类型</span></span><br><span class="line">test(isNoble);</span><br></pre></td></tr></table></figure>

<p>2.对于只包含一个表达式的函数，可以使用简写语法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases [ atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>3.函数作为变量</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> say = (str) &#123;</span><br><span class="line">  <span class="built_in">print</span>(str);</span><br><span class="line">&#125;;</span><br><span class="line">say(<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure>

<p>4.函数作为参数传递</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> execute(<span class="keyword">var</span> callback) &#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line">execute(() =&gt; <span class="built_in">print</span>(<span class="string">"xxx"</span>)); <span class="comment">//参数为() =&gt; print("xxx")</span></span><br></pre></td></tr></table></figure>

<p>5.可选的位置参数</p>
<p>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个不带可选参数调用这个函数的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>); <span class="comment">//结果是： Bob says Howdy</span></span><br></pre></td></tr></table></figure>

<p>下面是用第三个参数调用这个函数的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>); <span class="comment">//结果是：Bob says Howdy with a smoke signal</span></span><br></pre></td></tr></table></figure>

<p>6.可选的命名参数</p>
<p>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置[bold]和[hidden]标志</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数时，可以使用指定命名参数。例如：paramName: value</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>可选命名参数在Flutter中使用非常多。</p>
<p><font color="#dd0000"><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></font></p>
<p><strong>Future.wait</strong></p>
<p>它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Future.wait([</span><br><span class="line">  <span class="comment">//2秒后返回结果</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds:<span class="number">2</span>),()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">  Futuren.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds:<span class="number">4</span>),()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then((results)&#123;</span><br><span class="line">  <span class="built_in">print</span>(result[<span class="number">0</span>] + result[<span class="number">1</span>]);</span><br><span class="line">&#125;).catchError((e)&#123;</span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Stream</strong></p>
<p>Stream 也是用于接收异步事件数据，和Future不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stream.fromFutures([</span><br><span class="line">  <span class="comment">//1秒后返回</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds:<span class="number">1</span>),()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello 1"</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">//抛出一个异常</span></span><br><span class="line">  Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds:<span class="number">3</span>),()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello 3"</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">]).listen((data)&#123;</span><br><span class="line">  <span class="built_in">print</span>(data);</span><br><span class="line">&#125;).onError:(e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(e.message);</span><br><span class="line">&#125;.onDone()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (<span class="number">17666</span>): hello <span class="number">1</span></span><br><span class="line">I/flutter (<span class="number">17666</span>): Error</span><br><span class="line">I/flutter (<span class="number">17666</span>): hello <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="第二章-第一个Flutter应用"><a href="#第二章-第一个Flutter应用" class="headerlink" title="第二章 第一个Flutter应用"></a>第二章 第一个Flutter应用</h2><h3 id="2-4-资源管理"><a href="#2-4-资源管理" class="headerlink" title="2.4 资源管理"></a>2.4 资源管理</h3><p><strong>加载 assets</strong></p>
<p>您的应用可以通过<a href="https://docs.flutter.io/flutter/services/AssetBundle-class.html" target="_blank" rel="noopener">AssetBundle</a>对象访问其asset 。有两种主要方法允许从Asset bundle中加载字符串或图片（二进制）文件。</p>
<p><strong>加载文本assets</strong></p>
<ul>
<li>通过<a href="https://docs.flutter.io/flutter/services/rootBundle.html" target="_blank" rel="noopener">rootBundle</a> 对象加载：每个Flutter应用程序都有一个<a href="https://docs.flutter.io/flutter/services/rootBundle.html" target="_blank" rel="noopener">rootBundle</a>对象， 通过它可以轻松访问<strong>主资源包</strong>，直接使用package:flutter/services.dart中全局静态的rootBundle对象来加载asset即可。</li>
<li>通过 <a href="https://docs.flutter.io/flutter/widgets/DefaultAssetBundle-class.html" target="_blank" rel="noopener">DefaultAssetBundle</a> 加载：建议使用 <a href="https://docs.flutter.io/flutter/widgets/DefaultAssetBundle-class.html" target="_blank" rel="noopener">DefaultAssetBundle</a> 来获取当前BuildContext的AssetBundle。 这种方法不是使用应用程序构建的默认asset bundle，而是使父级widget在运行时动态替换的不同的AssetBundle，这对于本地化或测试场景很有用。</li>
</ul>
<p>通常，可以使用DefaultAssetBundle.of()在应用运行时来间接加载asset（例如JSON文件），而在widget上下文之外，或其它AssetBundle句柄不可用时，可以使用rootBundle直接加载这些asset，例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span> <span class="keyword">show</span> Future;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span> <span class="keyword">show</span> rootBundle;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; loadAsset() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> rootBundle.loadString(<span class="string">'assets/config.json'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设备像素比率为1.8的设备上，…/2.0x/my_icon.png 将被选择。对于2.7的设备像素比率，…/3.0x/my_icon.png将被选择。</p>
<p>当主资源缺少某个资源时，会按分辨率从低到高的顺序去选择 ，也就是说1x中没有的话会在2x中找，2x中还没有的话就在3x中找。</p>
<p><strong>加载图片</strong></p>
<p>要加载图片，可以使用 <a href="https://docs.flutter.io/flutter/painting/AssetImage-class.html" target="_blank" rel="noopener">AssetImage</a>类。例如，我们可以从上面的asset声明中加载背景图片：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DecoratedBox(</span><br><span class="line">    decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">      image: <span class="keyword">new</span> DecorationImage(</span><br><span class="line">        image: <span class="keyword">new</span> AssetImage(<span class="string">'graphics/background.png'</span>),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，AssetImage 并非是一个widget， 它实际上是一个ImageProvider，有些时候你可能期望直接得到一个显示图片的widget，那么你可以使用Image.asset()方法，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Image.asset(<span class="string">'graphics/background.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认的 asset bundle 加载资源时，内部会自动处理分辨率等，这些处理对开发者来说是无感知的。 (如果使用一些更低级别的类，如 <a href="https://docs.flutter.io/flutter/painting/ImageStream-class.html" target="_blank" rel="noopener">ImageStream</a>或 <a href="https://docs.flutter.io/flutter/painting/ImageCache-class.html" target="_blank" rel="noopener">ImageCache</a> 时你会注意到有与缩放相关的参数)</p>
<h2 id="第三章-基础组件"><a href="#第三章-基础组件" class="headerlink" title="第三章 基础组件"></a>第三章 基础组件</h2><h3 id="3-3-3-TextSpan"><a href="#3-3-3-TextSpan" class="headerlink" title="3.3.3 TextSpan"></a>3.3.3 TextSpan</h3><p>通过TextSpan实现了一个基础文本片段和一个链接片段，然后通过Text.rich 方法将TextSpan 添加到Text中，之所以可以这样做，是因为Text其实就是RichText的一个包装，而RichText是可以显示多种样式(富文本)的widget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Text.rich(TextSpan(</span><br><span class="line">    children: [</span><br><span class="line">     TextSpan(</span><br><span class="line">       text: <span class="string">"Home: "</span></span><br><span class="line">     ),</span><br><span class="line">     TextSpan(</span><br><span class="line">       text: <span class="string">"https://flutterchina.club"</span>,</span><br><span class="line">       style: TextStyle(</span><br><span class="line">         color: Colors.blue</span><br><span class="line">       ),  </span><br><span class="line">       recognizer: _tapRecognizer</span><br><span class="line">     ),</span><br><span class="line">    ]</span><br><span class="line">))</span><br></pre></td></tr></table></figure>

<h3 id="3-4-1-Material组件库中的按钮"><a href="#3-4-1-Material组件库中的按钮" class="headerlink" title="3.4.1 Material组件库中的按钮"></a>3.4.1 Material组件库中的按钮</h3><p>Material 组件库中提供了多种按钮组件如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton组件的包装定制，所以他们大多数属性都和RawMaterialButton一样。</p>
<p>所有Material 库中的按钮都有如下相同点：</p>
<ol>
<li>按下时都会有“水波动画”（又称“涟漪动画”，就是点击时按钮上会出现水波荡漾的动画）。</li>
<li>有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。</li>
</ol>
<p><strong>RaisedButton</strong></p>
<p>RaisedButton 即”漂浮”按钮，它默认带有阴影和灰色背景。按下后，阴影会变大。</p>
<p><strong>FlatButton</strong></p>
<p>FlatButton即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色。</p>
<p><strong>OutlineButton</strong></p>
<p>OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)。</p>
<p><strong>IconButton</strong></p>
<p>IconButton是一个可点击的Icon，不包括文字，默认没有背景，点击后会出现背景</p>
<h3 id="3-5-1图片"><a href="#3-5-1图片" class="headerlink" title="3.5.1图片"></a>3.5.1图片</h3><p><strong>ImageProvider</strong></p>
<p>ImageProvider 是一个抽象类，主要定义了图片数据获取的接口load()，<strong>从不同的数据源获取图片需要实现不同的ImageProvider ，如AssetImage是实现了从Asset中加载图片的ImageProvider，而NetworkImage实现了从网络加载图片的ImageProvider</strong>。</p>
<p><strong>Image</strong></p>
<p>Image widget有一个必选的image参数，<font color="#dd0000"><strong>它对应一个ImageProvider</strong></font>。下面我们分别演示一下如何从asset和网络加载图片。</p>
<p><strong>从asset中加载图片</strong></p>
<ol>
<li><p>在工程根目录下创建一个images目录，并将图片avatar.png拷贝到该目录。</p>
</li>
<li><p>在pubspec.yaml中的flutter部分添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">assets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">images/avatar.png</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 由于 yaml 文件对缩进严格，所以必须严格按照每一层两个空格的方式进行缩进，此处assets前面应有两个空格。</p>
</blockquote>
</li>
<li><p>加载该图片</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">  image: AssetImage(<span class="string">"images/avatar.png"</span>),</span><br><span class="line">  width: <span class="number">100.0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>Image也提供了一个快捷的构造函数Image.asset用于从asset中加载、显示图片</strong></font>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(<span class="string">"images/avatar.png"</span>,</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>从网络加载图片</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">  image: NetworkImage(</span><br><span class="line">      <span class="string">"https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4"</span>),</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>Image也提供了一个快捷的构造函数Image.network用于从网络加载、显示图片</strong></font>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image.network(</span><br><span class="line">  <span class="string">"https://avatars2.githubusercontent.com/u/20411648?s=460&amp;v=4"</span>,</span><br><span class="line">  width: <span class="number">100.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>Image缓存</strong></p>
<p><font color="#dd0000"><strong>Flutter框架对加载过的图片是有缓存的（内存），默认最大缓存数量是1000，最大缓存空间为100M</strong></font>。</p>
<p>###3.5.2 ICON</p>
<p>在Flutter开发中，iconfont和图片相比有如下优势：</p>
<ol>
<li>体积小：可以减小安装包大小。</li>
<li>矢量的：iconfont都是矢量图标，放大不会影响其清晰度。</li>
<li>可以应用文本样式：可以像文本一样改变字体图标的颜色、大小对齐等。</li>
<li>可以通过TextSpan和文本混用。</li>
</ol>
<h3 id="3-6-单选开关和复选框"><a href="#3-6-单选开关和复选框" class="headerlink" title="3.6 单选开关和复选框"></a>3.6 单选开关和复选框</h3><p>Material 组件库中提供了Material风格的单选开关Switch和复选框Checkbox，<font color="#dd0000"><strong>虽然它们都是继承自StatefulWidget，但它们本身不会保存当前选中状态，选中状态都是由父组件来管理的</strong></font>。当Switch或Checkbox被点击时，会触发它们的onChanged回调，我们可以在此回调中处理选中状态改变逻辑。</p>
<h3 id="3-7-1-TextField"><a href="#3-7-1-TextField" class="headerlink" title="3.7.1 TextField"></a>3.7.1 TextField</h3><p>controller：编辑框的控制器，通过它可以设置/获取编辑框的内容、选择编辑内容、监听编辑文本改变事件。大多数情况下我们都需要显式提供一个controller来与文本框交互。如果没有提供controller，则TextField内部会自动创建一个。</p>
<p>focusNode：用于控制TextField是否占有当前键盘的输入焦点。它是我们和键盘交互的一个句柄（handle）。</p>
<p>InputDecoration：用于控制TextField的外观显示，如提示文本、背景颜色、边框等。</p>
<p>obscureText：是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。</p>
<p>onChange：输入框内容改变时的回调函数；注：内容改变事件也可以通过controller来监听。</p>
<p>###3.7.2 表单Form</p>
<p>实际业务中，在正式向服务器提交数据前，都会对各个输入框数据进行合法性校验，但是对每一个TextField都分别进行校验将会是一件很麻烦的事。还有，如果用户想清除一组TextField的内容，除了一个一个清除有没有什么更好的办法呢？为此，Flutter提供了一个Form 组件，<font color="#dd0000"><strong>它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存</strong></font>。</p>
<h2 id="第四章-布局类组件"><a href="#第四章-布局类组件" class="headerlink" title="第四章 布局类组件"></a>第四章 布局类组件</h2><p>###4.1 布局类组件简介</p>
<p>布局类组件都会包含一个或多个子组件，不同的布局类组件对子组件排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过Widget树来创建的（通过Widget.createElement()），Widget其实就是Element的配置数据。在Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表：</p>
<table>
<thead>
<tr>
<th>Widget</th>
<th>对应的Element</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>LeafRenderObjectWidget</td>
<td>LeafRenderObjectElement</td>
<td><font color="#dd0000"><strong>Widget树的叶子节点，用于没有子节点的widget，通常基础组件都属于这一类，如Image。</strong></font></td>
</tr>
<tr>
<td>SingleChildRenderObjectWidget</td>
<td>SingleChildRenderObjectElement</td>
<td><font color="#dd0000"><strong>包含一个子Widget，如：ConstrainedBox、DecoratedBox等</strong></font></td>
</tr>
<tr>
<td>MultiChildRenderObjectWidget</td>
<td>MultiChildRenderObjectElement</td>
<td><font color="#dd0000"><strong>包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等</strong></font></td>
</tr>
</tbody></table>
<blockquote>
<p>注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自MultiChildRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于MultiChildRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实<strong>StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）</strong>。</p>
</blockquote>
<p>布局类组件就是指直接或间接继承(包含)MultiChildRenderObjectWidget的Widget，它们一般都会有一个children属性用于接收子Widget。我们看一下继承关系 Widget &gt; RenderObjectWidget &gt; (Leaf/SingleChild/MultiChild)RenderObjectWidget 。</p>
<p>RenderObjectWidget类中定义了创建、更新RenderObject的方法，子类必须实现他们，关于RenderObject我们现在只需要知道它是最终布局、渲染UI界面的对象即可，也就是说，对于布局类组件来说，其布局算法都是通过对应的RenderObject对象来实现的，所以读者如果对接下来介绍的某个布局类组件的原理感兴趣，可以查看其对应的RenderObject的实现，比如Stack（层叠布局）对应的RenderObject对象就是RenderStack，而层叠布局的实现就在RenderStack中。</p>
<h3 id="4-3-弹性布局（Flex）"><a href="#4-3-弹性布局（Flex）" class="headerlink" title="4.3 弹性布局（Flex）"></a>4.3 弹性布局（Flex）</h3><p>弹性布局允许子组件按照一定比例来分配父容器空间。弹性布局的概念在其它UI系统中也都存在，如H5中的弹性盒子布局，Android中的FlexboxLayout等。Flutter中的弹性布局主要通过Flex和Expanded来配合实现。</p>
<p><strong>Flex</strong></p>
<p>Flex组件可以沿着水平或垂直方向排列子组件，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方基本上都可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded组件配合实现弹性布局。</p>
<p><strong>Expanded</strong></p>
<p>可以按比例“扩伸” Row、Column和Flex子组件所占用的空间。</p>
<h3 id="4-4-流式布局"><a href="#4-4-流式布局" class="headerlink" title="4.4 流式布局"></a>4.4 流式布局</h3><p><font color="#dd0000"><strong>Row默认只有一行，如果超出屏幕不会折行，超出屏幕会报错。我们把超出屏幕显示范围会自动折行的布局称为流式布局</strong></font>。Flutter中通过<strong>Wrap和Flow</strong>来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行</p>
<p>###4.4.1 Wrap</p>
<p>Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。</p>
<p>###4.4.2 Flow</p>
<p>一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。</p>
<p>Flow有如下优点：</p>
<ul>
<li>性能好；Flow是一个对子组件尺寸以及位置调整非常高效的控件，Flow用转换矩阵在对子组件进行位置调整的时候进行了优化：在Flow定位过后，如果子组件的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵，并没有实际调整组件位置。</li>
<li>灵活；由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个组件的位置，因此，可以自定义布局策略。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用复杂。</li>
<li>不能自适应子组件大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。</li>
</ul>
<h3 id="4-5-层叠布局-Stack、Positioned"><a href="#4-5-层叠布局-Stack、Positioned" class="headerlink" title="4.5 层叠布局 Stack、Positioned"></a>4.5 层叠布局 Stack、Positioned</h3><p>Flutter中使用Stack和Positioned这两个组件来配合实现绝对定位。Stack允许子组件堆叠，而Positioned用于根据Stack的四个角来确定子组件的位置。</p>
<p>###4.6 对齐与相对定位（Align）</p>
<p>如果我们只想简单的调整<strong>一个</strong>子元素在父元素中的位置的话，使用Align组件会更简单一些。</p>
<p>###4.6.2 Align和Stack对比</p>
<p>可以看到，Align和Stack/Positioned都可以用于指定子元素相对于父元素的偏移，但它们还是有两个主要区别：</p>
<ol>
<li>定位参考系统不同；Stack/Positioned定位的的参考系可以是父容器矩形的四个顶点；而Align则需要先通过alignment 参数来确定坐标原点，不同的alignment会对应不同原点，最终的偏移是需要通过alignment的转换公式来计算出。</li>
<li>Stack可以有多个子元素，并且子元素可以堆叠，而Align只能有一个子元素，不存在堆叠。</li>
</ol>
<h2 id="第五章-容器类组件"><a href="#第五章-容器类组件" class="headerlink" title="第五章 容器类组件"></a>第五章 容器类组件</h2><p>容器类Widget和布局类Widget都作用于其子Widget，不同的是：</p>
<ul>
<li>布局类Widget一般都需要接收一个<font color="#dd0000"><strong>widget数组（children）</strong></font>，他们直接或间接继承自（或包含）MultiChildRenderObjectWidget ；而容器类Widget一般只需要接收一个<font color="#dd0000"><strong>子Widget（child）</strong></font>，他们直接或间接继承自（或包含）SingleChildRenderObjectWidget。</li>
<li>布局类Widget是按照一定的排列方式来对其子Widget进行排列；而容器类Widget一般只是包装其子Widget，对其添加一些修饰（补白或背景色等）、变换(旋转或剪裁等)、或限制(大小等)。</li>
</ul>
<p>###5.1 填充（Padding）</p>
<p>Padding可以给其子节点添加填充（留白），和边距效果类似。我们在前面很多示例中都已经使用过它了，现在来看看它的定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Padding(&#123;</span><br><span class="line">  ...</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets类，它是EdgeInsetsGeometry的一个子类，定义了一些设置填充的便捷方法。</p>
<h3 id="EdgeInsets"><a href="#EdgeInsets" class="headerlink" title="EdgeInsets"></a>EdgeInsets</h3><p>我们看看EdgeInsets提供的便捷方法：</p>
<ul>
<li>fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的填充。</li>
<li>all(double value) : 所有方向均使用相同数值的填充。</li>
<li>only({left, top, right ,bottom })：可以设置具体某个方向的填充(可以同时指定多个方向)。</li>
<li>symmetric({ vertical, horizontal })：用于设置对称方向的填充，vertical指top和bottom，horizontal指left和right。</li>
</ul>
<p>###5.2 尺寸限制类容器</p>
<p>尺寸限制类容器用于限制容器大小，Flutter中提供了多种这样的容器，如ConstrainedBox、SizedBox、UnconstrainedBox、AspectRatio等，本节将介绍一些常用的。</p>
<p>###5.2.1 ConstrainedBox</p>
<p><font color="#dd0000"><strong>onstrainedBox用于对子组件添加额外的约束</strong></font>。例如，如果你想让子组件的最小高度是80像素，你可以使用const BoxConstraints(minHeight: 80.0)作为子组件的约束。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>我们先定义一个redBox，它是一个背景颜色为红色的盒子，不指定它的宽度和高度：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget redBox=DecoratedBox(</span><br><span class="line">  decoration: BoxDecoration(color: Colors.red),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>BoxConstraints</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints(&#123;</span><br><span class="line">  <span class="keyword">this</span>.minWidth = <span class="number">0.0</span>, <span class="comment">//最小宽度</span></span><br><span class="line">  <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity, <span class="comment">//最大宽度</span></span><br><span class="line">  <span class="keyword">this</span>.minHeight = <span class="number">0.0</span>, <span class="comment">//最小高度</span></span><br><span class="line">  <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity <span class="comment">//最大高度</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-SizedBox"><a href="#5-2-2-SizedBox" class="headerlink" title="5.2.2 SizedBox"></a>5.2.2 SizedBox</h3><p>实际上SizedBox只是ConstrainedBox的一个定制，上面代码等价于：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints.tightFor(width: <span class="number">80.0</span>,height: <span class="number">80.0</span>),</span><br><span class="line">  child: redBox, </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoxConstraints(minHeight: <span class="number">80.0</span>,maxHeight: <span class="number">80.0</span>,minWidth: <span class="number">80.0</span>,maxWidth: <span class="number">80.0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-多重限制"><a href="#5-2-3-多重限制" class="headerlink" title="5.2.3 多重限制"></a>5.2.3 多重限制</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConstrainedBox(</span><br><span class="line">    constraints: BoxConstraints(minWidth: <span class="number">90.0</span>, minHeight: <span class="number">20.0</span>),</span><br><span class="line">    child: ConstrainedBox(</span><br><span class="line">      constraints: BoxConstraints(minWidth: <span class="number">60.0</span>, minHeight: <span class="number">60.0</span>),</span><br><span class="line">      child: redBox,</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。</p>
<p>###5.2.4 UnconstrainedBox</p>
<p>UnconstrainedBox不会对子组件产生任何限制，它允许其子组件按照其本身大小绘制。一般情况下，我们会很少直接使用此组件，但在”去除”多重限制的时候也许会有帮助</p>
<p>###5.3 装饰容器DecoratedBox</p>
<p><font color="#dd0000"><strong>可以在其子组件绘制前(或后)绘制一些装饰（Decoration），如背景、边框、渐变等。</strong></font></p>
<p>DecoratedBox定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DecoratedBox(&#123;</span><br><span class="line">  Decoration decoration,</span><br><span class="line">  DecorationPosition position = DecorationPosition.background,</span><br><span class="line">  Widget child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>decoration：代表将要绘制的装饰，它的类型为Decoration。Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。</li>
<li>position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类有两个值：<ul>
<li>background：在子组件之后绘制，即背景装饰。</li>
<li>foreground：在子组件之上绘制，即前景。</li>
</ul>
</li>
</ul>
<p><strong>BoxDecoration</strong></p>
<p>我们通常会直接使用BoxDecoration类，它是一个Decoration的子类，实现了常用的装饰元素的绘制。</p>
<h3 id="5-4-变换（Transform）"><a href="#5-4-变换（Transform）" class="headerlink" title="5.4 变换（Transform）"></a>5.4 变换（Transform）</h3><p>Transform可以在其子组件绘制时对其应用一些矩阵变换来实现一些特效。</p>
<p>Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作，下面是一个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  color: Colors.black,</span><br><span class="line">  child: <span class="keyword">new</span> Transform(</span><br><span class="line">    alignment: Alignment.topRight, <span class="comment">//相对于坐标系原点的对齐方式</span></span><br><span class="line">    transform: <span class="keyword">new</span> Matrix4.skewY(<span class="number">0.3</span>), <span class="comment">//沿Y轴倾斜0.3弧度</span></span><br><span class="line">    child: <span class="keyword">new</span> Container(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      color: Colors.deepOrange,</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">'Apartment for rent!'</span>),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>RotatedBox</strong></p>
<p>RotatedBox和Transform.rotate功能相似，它们都可以对子组件进行旋转变换，但是有一点不同：<font color="#dd0000"><strong>RotatedBox的变换是在layout阶段，会影响在子组件的位置和大小</strong></font>。</p>
<p>###5.5 Container</p>
<p>我们在前面的章节示例中多次用到过Container组件，本节我们就详细介绍一下Container组件。Container是一个组合类容器，它本身不对应具体的RenderObject，<font color="#dd0000"><strong>它是DecoratedBox、ConstrainedBox、Transform、Padding、Align等组件组合的一个多功能容器，所以我们只需通过一个Container组件可以实现同时需要装饰、变换、限制的场景</strong></font>。</p>
<p>Container的大多数属性在介绍其它容器时都已经介绍过了，不再赘述，但有两点需要说明：</p>
<ul>
<li>容器的大小可以通过width、height属性来指定，也可以通过constraints来指定；<font color="#dd0000"><strong>如果它们同时存在时，width、height优先</strong></font>。实际上Container内部会根据width、height来生成一个constraints。</li>
<li><font color="#dd0000"><strong>color和decoration是互斥的</strong></font>，如果同时设置它们则会报错！实际上，当指定color时，Container内会自动创建一个decoration。</li>
</ul>
<p>##第六章 可滚动组件</p>
<p>###6.1 可滚动组件简介</p>
<p>可滚动组件都直接或间接包含一个Scrollable组件，因此它们包括一些共同的属性，为了避免重复介绍，我们在此统一介绍一下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scrollable(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.axisDirection = AxisDirection.down,</span><br><span class="line">  <span class="keyword">this</span>.controller,</span><br><span class="line">  <span class="keyword">this</span>.physics,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.viewportBuilder, <span class="comment">//后面介绍</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>axisDirection滚动方向。</li>
<li>physics：此属性接受一个ScrollPhysics类型的对象，它决定可滚动组件如何响应用户操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。默认情况下，Flutter会根据具体平台分别使用不同的ScrollPhysics对象，应用不同的显示效果，如当滑动到边界时，继续拖动的话，在iOS上会出现弹性效果，而在Android上会出现微光效果。如果你想在所有平台下使用同一种效果，可以显式指定一个固定的ScrollPhysics，Flutter SDK中包含了两个ScrollPhysics的子类，他们可以直接使用：<ul>
<li>ClampingScrollPhysics：Android下微光效果。</li>
<li>BouncingScrollPhysics：iOS下弹性效果。</li>
</ul>
</li>
<li>controller：此属性接受一个ScrollController对象。<strong>ScrollController的主要作用是控制滚动位置和监听滚动事件</strong>。默认情况下，Widget树中会有一个默认的PrimaryScrollController，如果子树中的可滚动组件没有显式的指定controller，并且primary属性值为true时（默认就为true），可滚动组件会使用这个默认的PrimaryScrollController。</li>
</ul>
<p><strong>Scrollbar</strong></p>
<p>Scrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动组件添加滚动条，只需将Scrollbar作为可滚动组件的任意一个父级组件即可，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scrollbar(</span><br><span class="line">  child: SingleChildScrollView(</span><br><span class="line">    ...</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>ViewPort视口</strong></p>
<p>在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。</p>
<p><strong>基于Sliver的延迟构建</strong></p>
<p>通常可滚动组件的子组件可能会非常多、占用的总高度也会非常大；如果要一次性将子组件全部构建出将会非常昂贵！为此，Flutter中提出一个Sliver（中文为“薄片”的意思）概念，如果一个可滚动组件支持Sliver模型，那么该滚动可以将子组件分成好多个“薄片”（Sliver），<font color="#dd0000"><strong>只有当Sliver出现在视口中时才会去构建它，这种模型也称为“基于Sliver的延迟构建模型”</strong></font>。可滚动组件中有很多都支持基于Sliver的延迟构建模型，如ListView、GridView，但是也有不支持该模型的，如SingleChildScrollView。</p>
<p>###6.2 SingleChildScrollView</p>
<p>SingleChildScrollView类似于Android中的ScrollView，<strong>它只能接收一个子组件</strong>。</p>
<p>需要注意的是，通常SingleChildScrollView只应在期望的内容不会超过屏幕太多时使用，这是<font color="#dd0000"><strong>因为SingleChildScrollView不支持基于Sliver的延迟实例化模型，所以如果预计视口可能包含超出屏幕尺寸太多的内容时，那么使用SingleChildScrollView将会非常昂贵（性能差）</strong></font>，此时应该使用一些支持Sliver延迟加载的可滚动组件，如ListView。</p>
<p>###6.3 ListView</p>
<p>ListView是最常用的可滚动组件之一，它可以沿一个方向线性排布所有子组件，并且它也支持基于Sliver的延迟构建模型。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListView(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="comment">//可滚动widget公共参数</span></span><br><span class="line">  Axis scrollDirection = Axis.vertical,</span><br><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">  ScrollController controller,</span><br><span class="line">  <span class="built_in">bool</span> primary,</span><br><span class="line">  ScrollPhysics physics,</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ListView各个构造函数的共同参数  </span></span><br><span class="line">  <span class="built_in">double</span> itemExtent,</span><br><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">  <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">double</span> cacheExtent,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//子widget列表</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面参数分为两组：第一组是可滚动组件的公共参数，本章第一节中已经介绍过，不再赘述；第二组是ListView各个构造函数（ListView有多个构造函数）的共同参数，我们重点来看看这些参数，：</p>
<ul>
<li>itemExtent：<font color="#dd0000"><strong>该参数如果不为null，则会强制children的“长度”为itemExtent的值</strong></font>；这里的“长度”是指滚动方向上子组件的长度，也就是说如果滚动方向是垂直方向，则itemExtent代表子组件的高度；如果滚动方向为水平方向，则itemExtent就代表子组件的宽度。<font color="#dd0000"><strong>在ListView中，指定itemExtent比让子组件自己决定自身长度会更高效</strong></font>，这是因为指定itemExtent后，滚动系统可以提前知道列表的长度，而无需每次构建子组件时都去再计算一下，尤其是在滚动位置频繁变化时（滚动系统需要频繁去计算列表高度）。</li>
<li>shrinkWrap：*<em>该属性表示是否根据子组件的总长度来设置ListView的长度，默认值为false *</em>。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。</li>
<li>addAutomaticKeepAlives：该属性表示是否将列表项（子组件）包裹在AutomaticKeepAlive 组件中；典型地，<strong>在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时它也不会被GC（垃圾回收）</strong>，它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。</li>
<li>addRepaintBoundaries：该属性表示是否将列表项（子组件）包裹在RepaintBoundary组件中。<strong>当可滚动组件滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘</strong>，<font color="#dd0000"><strong>但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效</strong></font>。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。</li>
</ul>
<blockquote>
<p>注意：上面这些参数并非ListView特有，在本章后面介绍的其它可滚动组件也可能会拥有这些参数，它们的含义是相同的。</p>
</blockquote>
<p><strong>默认构造函数</strong></p>
<p>默认构造函数有一个children参数，它接受一个Widget列表（List）。<font color="#dd0000"><strong>这种方式适合只有少量的子组件的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作）</strong></font>，而不是等到子widget真正显示的时候再创建，也就是说通过默认构造函数构建的ListView没有应用基于Sliver的懒加载模型。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">  shrinkWrap: <span class="keyword">true</span>, </span><br><span class="line">  padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">'I\'m dedicating every day to you'</span>),</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">'Domestic life was never quite my style'</span>),</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">'When you smile, you knock me out, I fall apart'</span>),</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">'And I thought I was so smart'</span>),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>ListView.builder</strong></p>
<p><font color="#dd0000"><strong>ListView.builder适合列表项比较多（或者无限）的情况，因为只有当子组件真正显示的时候才会被创建，也就说通过该构造函数创建的ListView是支持基于Sliver的懒加载模型的。</strong></font></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(&#123;</span><br><span class="line">  <span class="comment">// ListView公共参数已省略  </span></span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">  <span class="built_in">int</span> itemCount,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>itemBuilder：它是列表项的构建器，类型为IndexedWidgetBuilder，返回值为一个widget。<strong>当列表滚动到具体的index位置时，会调用该构建器构建列表项</strong>。</li>
<li>itemCount：列表项的数量，<strong>如果为null，则为无限列表</strong>。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">    itemCount: <span class="number">100</span>,</span><br><span class="line">    itemExtent: <span class="number">50.0</span>, <span class="comment">//强制高度为50.0</span></span><br><span class="line">    itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">      <span class="keyword">return</span> ListTile(title: Text(<span class="string">"<span class="subst">$index</span>"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>ListView.separated</strong></p>
<p>ListView.separated可以在生成的列表项之间添加一个分割组件，<font color="#dd0000"><strong>它比ListView.builder多了一个separatorBuilder参数，该参数是一个分割组件生成器。</strong></font></p>
<p>###6.4 GridView</p>
<p>GridView和ListView的大多数参数都是相同的，<strong>唯一需要关注的是gridDelegate参数，类型是SliverGridDelegate，它的作用是控制GridView子组件如何排列(layout)</strong>。</p>
<p>SliverGridDelegate是一个抽象类，定义了GridView Layout相关接口，<font color="#dd0000"><strong>子类需要通过实现它们来实现具体的布局算法</strong></font>。Flutter中提供了两个SliverGridDelegate的子类SliverGridDelegateWithFixedCrossAxisCount和SliverGridDelegateWithMaxCrossAxisExtent。</p>
<p><strong>SliverGridDelegateWithFixedCrossAxisCount</strong></p>
<p>该子类实现了一个<font color="#dd0000"><strong>横轴为固定数量</strong></font>子元素的layout算法</p>
<p><strong>SliverGridDelegateWithMaxCrossAxisExtent</strong></p>
<p>该子类实现了一个<font color="#dd0000"><strong>横轴子元素为固定最大长度</strong></font>的layout算法</p>
<p>###6.5 CustomScrollView</p>
<p>CustomScrollView是可以使用Sliver来自定义滚动模型（效果）的组件。它可以包含多种滚动模型，举个例子，假设有一个页面，顶部需要一个GridView，底部需要一个ListView，而要求整个页面的滑动效果是统一的，即它们看起来是一个整体。如果使用GridView+ListView来实现的话，就不能保证一致的滑动效果，因为它们的滚动效果是分离的，所以这时就需要一个”胶水”，把这些彼此独立的可滚动组件”粘”起来，而CustomScrollView的功能就相当于“胶水”。</p>
<p><strong>可滚动组件的Sliver版</strong></p>
<p>Sliver在前面讲过，有细片、薄片之意，在Flutter中，Sliver通常指可滚动组件子元素（就像一个个薄片一样）。但是在CustomScrollView中，需要粘起来的可滚动组件就是CustomScrollView的Sliver了，<strong>如果直接将ListView、GridView作为CustomScrollView是不行的，因为它们本身是可滚动组件而并不是Sliver</strong>！因此，为了能让可滚动组件能和CustomScrollView配合使用，Flutter提供了一些可滚动组件的Sliver版，如SliverList、SliverGrid等。实际上Sliver版的可滚动组件和非Sliver版的可滚动组件最大的区别就是<strong>前者不包含滚动模型（自身不能再滚动），而后者包含滚动模型</strong> ，也正因如此，CustomScrollView才可以将多个Sliver”粘”在一起，这些Sliver共用CustomScrollView的Scrollable，所以最终才实现了统一的滑动效果。</p>
<h2 id="第七章-功能型组件"><a href="#第七章-功能型组件" class="headerlink" title="第七章 功能型组件"></a>第七章 功能型组件</h2><h1 id="7-1-导航返回拦截（WillPopScope）"><a href="#7-1-导航返回拦截（WillPopScope）" class="headerlink" title="7.1 导航返回拦截（WillPopScope）"></a>7.1 导航返回拦截（WillPopScope）</h1><p>为了避免用户误触返回按钮而导致APP退出，在很多APP中都拦截了用户点击返回键的按钮，然后进行一些防误触判断，比如当用户在某一个时间段内点击两次时，才会认为用户是要退出（而非误触）。<font color="#dd0000"><strong>Flutter中可以通过WillPopScope来实现返回按钮拦截</strong></font></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WillPopScope(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@required</span> WillPopCallback onWillPop,</span><br><span class="line">  <span class="meta">@required</span> Widget child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>onWillPop是一个回调函数，当用户点击返回按钮时被调用（包括导航返回按钮及Android物理返回按钮）。该回调需要<font color="#dd0000"><strong>返回一个Future对象</strong></font>，<strong>如果返回的Future最终值为false时，则当前路由不出栈(不会返回)；最终值为true时，当前路由出栈退出</strong>。我们需要提供这个回调来决定是否退出。</p>
<p>###7.2 数据共享（InheritedWidget）</p>
<p>InheritedWidget是Flutter中非常重要的一个功能型组件，它提供了一种数据在widget树中从上到下传递、共享的方式，比如我们在应用的根widget中通过InheritedWidget共享了一个数据，那么我们便可以在任意子widget中来获取该共享的数据！这个特性在一些需要在widget树中共享数据的场景中非常方便！</p>
<blockquote>
<p><font color="#dd0000"><strong>InheritedWidget和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在widget树中数据传递方向是从上到下的，这和通知Notification（将在下一章中介绍）的传递方向正好相反。</strong></font></p>
</blockquote>
<p><strong>didChangeDependencies</strong></p>
<p>在之前介绍StatefulWidget时，我们提到State对象有一个didChangeDependencies回调，它会在“依赖”发生变化时被Flutter Framework调用。<strong>而这个“依赖”指的就是子widget是否使用了父widget中InheritedWidget的数据</strong>！<font color="#dd0000"><strong>如果使用了，则代表子widget依赖有依赖InheritedWidget</strong></font>；如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的InheritedWidget变化时来更新自身！比如当主题、locale(语言)等发生变化时，依赖其的子widget的didChangeDependencies方法将会被调用。</p>
<p><strong>深入了解InheritedWidget</strong></p>
<p><strong>调用dependOnInheritedWidgetOfExactType() 和 getElementForInheritedWidgetOfExactType()的区别就是前者会注册依赖关系，而后者不会</strong></p>
<p>###7.3 跨组件状态共享（Provider）</p>
<p>在Flutter开发中，状态管理是一个永恒的话题。一般的原则是：<strong>如果状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理</strong>。</p>
<p>在Flutter当中有没有更好的跨组件状态管理方式了呢？答案是肯定的，那怎么做的？我们想想前面介绍的InheritedWidget，<strong>它的天生特性就是能绑定InheritedWidget与依赖它的子孙组件的依赖关系，并且当InheritedWidget数据发生变化时，可以自动更新依赖的子孙组件</strong>！利用这个特性，我们可以将需要跨组件共享的状态保存在InheritedWidget中，然后在子组件中引用InheritedWidget即可，Flutter社区著名的<font color="#dd0000"><strong>Provider包</strong></font>正是基于这个思想实现的一套跨组件状态共享解决方案，接下来我们便详细介绍一下Provider的用法及原理。</p>
<p>###7.5 异步UI更新（FutureBuilder、StreamBuilder）</p>
<p>很多时候我们会依赖一些异步数据来动态更新UI，比如在打开一个页面时我们需要先从互联网上获取数据，在获取数据的过程中我们显示一个加载框，等获取到数据时我们再渲染页面；又比如我们想展示Stream（比如文件流、互联网数据接收流）的进度。<strong>Flutter专门提供了FutureBuilder和StreamBuilder两个组件来快速实现这种功能</strong>。</p>
<h2 id="7-5-1-FutureBuilder"><a href="#7-5-1-FutureBuilder" class="headerlink" title="7.5.1 FutureBuilder"></a>7.5.1 FutureBuilder</h2><p>FutureBuilder会依赖一个Future，<font color="#dd0000"><strong>它会根据所依赖的Future的状态来动态构建自身</strong></font>。我们看一下FutureBuilder构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureBuilder(&#123;</span><br><span class="line">  <span class="keyword">this</span>.future,</span><br><span class="line">  <span class="keyword">this</span>.initialData,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>future：FutureBuilder依赖的Future，<strong>通常是一个异步耗时任务</strong>。</p>
</li>
<li><p>initialData：初始数据，用户设置默认数据。</p>
</li>
<li><p>builder：Widget构建器；该构建器会在Future执行的不同阶段被多次调用，构建器签名如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> (BuildContext context, AsyncSnapshot snapshot)</span><br></pre></td></tr></table></figure>

<p><strong>snapshot会包含当前异步任务的状态信息及结果信息</strong> ，比如我们可以通过snapshot.connectionState获取异步任务的状态信息、通过snapshot.hasError判断异步任务是否有错误等等，完整的定义读者可以查看AsyncSnapshot类定义。</p>
<p>另外，FutureBuilder的builder函数签名和StreamBuilder的builder是相同的。</p>
</li>
</ul>
<h2 id="第八章-事件处理和通知"><a href="#第八章-事件处理和通知" class="headerlink" title="第八章 事件处理和通知"></a>第八章 事件处理和通知</h2><h3 id="8-4-Notification"><a href="#8-4-Notification" class="headerlink" title="8.4 Notification"></a>8.4 Notification</h3><p>通知（Notification）是Flutter中一个重要的机制，在widget树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父节点都可以通过NotificationListener来监听通知。Flutter中将这种由子向父的传递通知的机制称为<strong>通知冒泡</strong>（Notification Bubbling）。通知冒泡和用户触摸事件冒泡是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。</p>
<blockquote>
<p>通知冒泡和Web开发中浏览器事件冒泡原理是相似的，都是事件从出发源逐层向上传递，我们可以在上层节点任意位置来监听通知/事件，也可以终止冒泡过程，终止冒泡后，通知将不会再向上传递。</p>
</blockquote>
<h2 id="第九章-动画"><a href="#第九章-动画" class="headerlink" title="第九章 动画"></a>第九章 动画</h2><p>###9.1 Flutter动画简介</p>
<p><strong>Flutter中动画抽象</strong></p>
<p>Flutter中也对动画进行了抽象，主要涉及Animation、Curve、Controller、Tween这四个角色。</p>
<p><strong>Animation</strong></p>
<p><strong>Animation是一个抽象类，它本身和UI渲染没有任何关系，而它主要的功能是保存动画的插值和状态</strong>；Animation对象是一个在一段时间内依次生成一个区间(Tween)之间值的类。Animation对象在整个动画执行过程中输出的值可以是线性的、曲线的、一个步进函数或者任何其他曲线函数等等，这由Curve来决定。 </p>
<p><strong>动画通知</strong></p>
<p>我们可以通过Animation来监听动画每一帧以及执行状态的变化，Animation有如下两个方法：</p>
<ol>
<li>addListener()；它可以用于给Animation添加帧监听器，在每一帧都会被调用。帧监听器中最常见的行为是改变状态后调用setState()来触发UI重建。</li>
<li>addStatusListener()；它可以给Animation添加“动画状态改变”监听器；动画开始、结束、正向或反向（见AnimationStatus定义）时会调用状态改变的监听器。</li>
</ol>
<p>读者在此只需要知道帧监听器和状态监听器的区别，在后面的章节中我们将会举例说明。</p>
<p><strong>Curve</strong></p>
<p>动画过程可以是匀速的、匀加速的或者先加速后减速等。Flutter中通过Curve（曲线）来描述动画过程，我们把匀速动画称为线性的(Curves.linear)，而非匀速动画称为非线性的。</p>
<p>我们可以通过CurvedAnimation来指定动画的曲线，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CurvedAnimation curve =</span><br><span class="line">    <span class="keyword">new</span> CurvedAnimation(parent: controller, curve: Curves.easeIn);</span><br></pre></td></tr></table></figure>

<p>CurvedAnimation和AnimationController（下面介绍）都是Animation类型。CurvedAnimation可以通过包装AnimationController和Curve生成一个新的动画对象 ，我们正是通过这种方式来将动画和动画执行的曲线关联起来的。我们指定动画的曲线为Curves.easeIn，它表示动画开始时比较慢，结束时比较快。 <a href="https://docs.flutter.io/flutter/animation/Curves-class.html" target="_blank" rel="noopener">Curves</a> 类是一个预置的枚举类，定义了许多常用的曲线，下面列几种常用的：</p>
<table>
<thead>
<tr>
<th>Curves曲线</th>
<th>动画过程</th>
</tr>
</thead>
<tbody><tr>
<td>linear</td>
<td>匀速的</td>
</tr>
<tr>
<td>decelerate</td>
<td>匀减速</td>
</tr>
<tr>
<td>ease</td>
<td>开始加速，后面减速</td>
</tr>
<tr>
<td>easeIn</td>
<td>开始慢，后面快</td>
</tr>
<tr>
<td>easeOut</td>
<td>开始快，后面慢</td>
</tr>
<tr>
<td>easeInOut</td>
<td>开始慢，然后加速，最后再减速</td>
</tr>
</tbody></table>
<p>除了上面列举的， <a href="https://docs.flutter.io/flutter/animation/Curves-class.html" target="_blank" rel="noopener">Curves</a> 类中还定义了许多其它的曲线，在此便不一一介绍，读者可以自行查看Curves类定义。</p>
<p>当然我们也可以创建自己Curve，例如我们定义一个正弦曲线：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShakeCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">double</span> transform(<span class="built_in">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> math.sin(t * math.PI * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AnimationController</strong></p>
<p><strong>AnimationController用于控制动画，它包含动画的启动forward()、停止stop() 、反向播放 reverse()等方法</strong>。<font color="#dd0000"><strong>AnimationController会在动画的每一帧，就会生成一个新的值</strong></font>。默认情况下，AnimationController在给定的时间段内线性的生成从0.0到1.0（默认区间）的数字。 例如，下面代码创建一个Animation对象（但不会启动动画）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationController controller = <span class="keyword">new</span> AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>), vsync: <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>AnimationController生成数字的区间可以通过lowerBound和upperBound来指定，如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationController controller = <span class="keyword">new</span> AnimationController( </span><br><span class="line"> duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>), </span><br><span class="line"> lowerBound: <span class="number">10.0</span>,</span><br><span class="line"> upperBound: <span class="number">20.0</span>,</span><br><span class="line"> vsync: <span class="keyword">this</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>AnimationController派生自Animation，因此可以在需要Animation对象的任何地方使用。 但是，AnimationController具有控制动画的其他方法，例如forward()方法可以启动正向动画，reverse()可以启动反向动画。在动画开始执行后开始生成动画帧，屏幕每刷新一次就是一个动画帧，在动画的每一帧，会随着根据动画的曲线来生成当前的动画值（Animation.value），然后根据当前的动画值去构建UI，当所有动画帧依次触发时，动画值会依次改变，所以构建的UI也会依次变化，所以最终我们可以看到一个完成的动画。 另外在动画的每一帧，Animation对象会调用其帧监听器，等动画状态发生改变时（如动画结束）会调用状态改变监听器。</p>
<p>duration表示动画执行的时长，通过它我们可以控制动画的速度。</p>
<blockquote>
<p><strong>注意</strong>： 在某些情况下，动画值可能会超出AnimationController的[0.0，1.0]的范围，这取决于具体的曲线。例如，fling()函数可以根据我们手指滑动（甩出）的速度(velocity)、力量(force)等来模拟一个手指甩出动画，因此它的动画值可以在[0.0，1.0]范围之外 。也就是说，根据选择的曲线，CurvedAnimation的输出可以具有比输入更大的范围。例如，Curves.elasticIn等弹性曲线会生成大于或小于默认范围的值。</p>
</blockquote>
<p><strong>Ticker</strong></p>
<p>当创建一个AnimationController时，需要传递一个<font color="#dd0000"><strong>vsync参数，它接收一个TickerProvider类型的对象</strong></font>，它的主要职责是创建Ticker，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TickerProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过一个回调创建一个Ticker</span></span><br><span class="line">  Ticker createTicker(TickerCallback onTick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Flutter应用在启动时都会绑定一个SchedulerBinding，通过SchedulerBinding可以给每一次屏幕刷新添加回调，而Ticker就是通过SchedulerBinding来添加屏幕刷新回调，这样一来，每次屏幕刷新都会调用TickerCallback。使用Ticker(而不是Timer)来驱动动画会防止屏幕外动画（动画的UI不在当前屏幕时，如锁屏时）消耗不必要的资源，因为Flutter中屏幕刷新时会通知到绑定的SchedulerBinding，而Ticker是受SchedulerBinding驱动的，由于锁屏后屏幕会停止刷新，所以Ticker就不会再触发。</p>
<p>通常我们会将SingleTickerProviderStateMixin添加到State的定义中，然后将State对象作为vsync的值，这在后面的例子中可以见到。</p>
<p><strong>Tween</strong></p>
<p>默认情况下，AnimationController对象值的范围是[0.0，1.0]。如果我们需要构建UI的动画值在不同的范围或不同的数据类型，则可以使用Tween来添加映射以生成不同的范围或数据类型的值。例如，像下面示例，Tween生成[-200.0，0.0]的值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Tween doubleTween = <span class="keyword">new</span> Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">-200.0</span>, end: <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>

<p>Tween构造函数需要begin和end两个参数。Tween的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为[0.0，1.0]，但这不是必须的，我们可以自定义需要的范围。</p>
<p>Tween继承自Animatable，而不是继承自Animation，Animatable中主要定义动画值的映射规则。</p>
<p>下面我们看一个ColorTween将动画输入范围映射为两种颜色值之间过渡输出的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Tween colorTween =</span><br><span class="line">    <span class="keyword">new</span> ColorTween(begin: Colors.transparent, end: Colors.black54);</span><br></pre></td></tr></table></figure>

<p>Tween对象不存储任何状态，相反，它提供了evaluate(Animation animation)方法，它可以获取动画当前映射值。 Animation对象的当前值可以通过value()方法取到。evaluate函数还执行一些其它处理，例如分别确保在动画值为0.0和1.0时返回开始和结束状态。</p>
<p><strong>Tween.animate</strong></p>
<p>要使用Tween对象，需要调用其animate()方法，然后传入一个控制器对象。例如，以下代码在500毫秒内生成从0到255的整数值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationController controller = <span class="keyword">new</span> AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = <span class="keyword">new</span> IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(controller);</span><br></pre></td></tr></table></figure>

<p>注意animate()返回的是一个Animation，而不是一个Animatable。</p>
<p>以下示例构建了一个控制器、一条曲线和一个Tween：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AnimationController controller = <span class="keyword">new</span> AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> Animation curve =</span><br><span class="line">    <span class="keyword">new</span> CurvedAnimation(parent: controller, curve: Curves.easeOut);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = <span class="keyword">new</span> IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(curve);</span><br></pre></td></tr></table></figure>

<h2 id="第十章-自定义组件"><a href="#第十章-自定义组件" class="headerlink" title="第十章 自定义组件"></a>第十章 自定义组件</h2><p>###10.1 自定义组件方法简介</p>
<p><strong>组合其它Widget</strong></p>
<p><strong>这种方式是通过拼装其它组件来组合成一个新的组件</strong>。例如我们之前介绍的Container就是一个组合组件，它是由DecoratedBox、ConstrainedBox、Transform、Padding、Align等组件组成。</p>
<p><strong>自绘</strong></p>
<p>如果遇到无法通过现有的组件来实现需要的UI时，我们可以通过自绘组件的方式来实现。</p>
<p><strong>实现RenderObject</strong></p>
<p>Flutter提供的自身具有UI外观的组件，如文本Text、Image都是通过相应的RenderObject（我们将在“Flutter核心原理”一章中详细介绍RenderObject）渲染出来的，如Text是由RenderParagraph渲染；而Image是由RenderImage渲染。<strong>RenderObject是一个抽象类，它定义了一个抽象方法paint(…)</strong>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset)</span><br></pre></td></tr></table></figure>

<p><strong>PaintingContext代表组件的绘制上下文，通过PaintingContext.canvas可以获得Canvas，而绘制逻辑主要是通过Canvas API来实现</strong>。子类需要重写此方法以实现自身的绘制逻辑，如RenderParagraph需要实现文本绘制逻辑，而RenderImage需要实现图片绘制逻辑。</p>
<p>可以发现，RenderObject中最终也是通过Canvas API来绘制的，那么通过实现RenderObject的方式和上面介绍的通过CustomPaint和Canvas自绘的方式有什么区别？其实答案很简单，<strong>CustomPaint只是为了方便开发者封装的一个代理类</strong>，它直接继承自SingleChildRenderObjectWidget，通过RenderCustomPaint的paint方法将Canvas和画笔Painter(需要开发者实现，后面章节介绍)连接起来实现了最终的绘制（绘制逻辑在Painter中）。</p>
<p>###10.2 组合现有组件</p>
<p>在Flutter中页面UI通常都是由一些低阶别的组件组合而成，当我们需要封装一些通用组件时，应该首先考虑是否可以通过组合其它组件来实现，如果可以，则应优先使用组合，因为直接通过现有组件拼装会非常简单、灵活、高效。</p>
<p>###10.4 自绘组件 （CustomPaint与Canvas）</p>
<p>对于一些复杂或不规则的UI，我们可能无法通过组合其它组件的方式来实现，比如我们需要一个正六边形、一个渐变的圆形进度条、一个棋盘等。当然，有时候我们可以使用图片来实现，但在一些需要动态交互的场景静态图片也是实现不了的，比如要实现一个手写输入面板，这时，我们就需要来自己绘制UI外观。</p>
<p>几乎所有的UI系统都会提供一个自绘UI的接口，这个接口通常会提供一块2D画布Canvas，Canvas内部封装了一些基本绘制的API，开发者可以通过Canvas绘制各种自定义图形。在Flutter中，提供了一个CustomPaint 组件，它可以结合画笔CustomPainter来实现自定义图形绘制。</p>
<h3 id="第十一章-文件操作与网络请求"><a href="#第十一章-文件操作与网络请求" class="headerlink" title="第十一章 文件操作与网络请求"></a>第十一章 文件操作与网络请求</h3><p>###11.1 文件操作</p>
<h4 id="APP目录"><a href="#APP目录" class="headerlink" title="APP目录"></a>APP目录</h4><p>Android和iOS的应用存储目录不同，<a href="https://pub.dartlang.org/packages/path_provider" target="_blank" rel="noopener">PathProvider</a> 插件提供了一种<strong>平台透明</strong>的方式来访问设备文件系统上的常用位置。该类当前支持访问两个文件系统位置：</p>
<ul>
<li><strong>临时目录:</strong> 可以使用 getTemporaryDirectory() 来获取临时目录； 系统可随时清除的临时目录（缓存）。在iOS上，这对应于<a href="https://developer.apple.com/reference/foundation/1409211-nstemporarydirectory" target="_blank" rel="noopener">NSTemporaryDirectory()</a> 返回的值。在Android上，这是<a href="https://developer.android.com/reference/android/content/Context.html#getCacheDir()" target="_blank" rel="noopener">getCacheDir()</a>返回的值。</li>
<li><strong>文档目录:</strong> 可以使用getApplicationDocumentsDirectory()来获取应用程序的文档目录，该目录用于存储只有自己可以访问的文件。只有当应用程序被卸载时，系统才会清除该目录。在iOS上，这对应于NSDocumentDirectory。在Android上，这是AppData目录。</li>
<li><strong>外部存储目录</strong>：可以使用getExternalStorageDirectory()来获取外部存储目录，如SD卡；由于iOS不支持外部目录，<font color="#dd0000"><strong>所以在iOS下调用该方法会抛出UnsupportedError异常</strong></font>，而在Android下结果是android SDK中getExternalStorageDirectory的返回值。</li>
</ul>
<h2 id="第十二章-包与插件"><a href="#第十二章-包与插件" class="headerlink" title="第十二章 包与插件"></a>第十二章 包与插件</h2><h3 id="12-1-开发Package"><a href="#12-1-开发Package" class="headerlink" title="12.1 开发Package"></a>12.1 开发Package</h3><p><strong>package可以创建共享的模块化代码，一个最小的Package包括</strong>：</p>
<ul>
<li><strong>一个pubspec.yaml文件</strong>：声明了Package的名称、版本、作者等的元数据文件。</li>
<li><strong>一个 lib 文件夹</strong>：包括包中公开的(public)代码，最少应有一个.dart文件</li>
</ul>
<p>Flutter Packages分为两类：</p>
<ul>
<li>Dart包：其中一些可能包含Flutter的特定功能，因此<strong>对Flutter框架具有依赖性</strong>，这种包仅用于Flutter，例如<a href="https://pub.dartlang.org/packages/fluro" target="_blank" rel="noopener">fluro</a>包。</li>
<li>插件包：一种专用的Dart包，其中包含用Dart代码编写的API，以及针对Android（使用Java或Kotlin）和针对iOS（使用OC或Swift）平台的特定实现，<strong>也就是说插件包括原生代码</strong>，一个具体的例子是<a href="https://pub.dartlang.org/packages/battery" target="_blank" rel="noopener">battery</a>插件包。</li>
</ul>
<p>###12.2 插件开发：平台通道简介</p>
<p>Flutter中提供了一个平台通道（platform channel），用于Flutter和原生平台的通信。平台通道正是Flutter和原生之间通信的桥梁，它也是Flutter插件的底层基础设施。</p>
<p>Flutter使用了一个灵活的系统，允许您调用特定平台的API，无论在Android上的Java或Kotlin代码中，还是iOS上的ObjectiveC或Swift代码中均可用。</p>
<p><strong>Flutter与原生之间的通信依赖灵活的消息传递方式</strong>：</p>
<ul>
<li><font color="#dd0000"><strong>应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）应用（原生应用）</strong></font>。</li>
<li><font color="#dd0000"><strong>宿主监听平台通道，并接收该消息。然后它会调用该平台的API，并将响应发送回客户端，即应用程序的Flutter部分</strong></font>。</li>
</ul>
<p><strong>平台通道</strong></p>
<p>使用平台通道在Flutter(client)和原生(host)之间传递消息，如下图所示：</p>
<p><img src="http://47.110.40.63:8080/img/blog/Flutter%E5%8E%9F%E7%94%9F%E9%80%9A%E4%BF%A1%E9%80%9A%E9%81%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></p>
<p>当在Flutter中调用原生方法时，调用信息通过平台通道传递到原生，原生收到调用信息后方可执行指定的操作，如需返回数据，则原生会将数据再通过平台通道传递给Flutter。值得注意的是消息传递是异步的，这确保了用户界面在消息传递时不会被挂起。</p>
<p>在客户端，<a href="https://docs.flutter.io/flutter/services/MethodChannel-class.html" target="_blank" rel="noopener">MethodChannel API</a> 可以发送与方法调用相对应的消息。 在宿主平台上，MethodChannel 在<a href="https://docs.flutter.io/javadoc/io/flutter/plugin/common/MethodChannel.html" target="_blank" rel="noopener">Android API</a> 和 <a href="https://docs.flutter.io/objcdoc/Classes/FlutterMethodChannel.html" target="_blank" rel="noopener">FlutterMethodChannel iOS API</a>可以接收方法调用并返回结果。这些类可以帮助我们用很少的代码就能开发平台插件。</p>
<blockquote>
<p><strong>注意</strong>: 如果需要，方法调用(消息传递)可以是反向的，即宿主作为客户端调用Dart中实现的API。 <a href="https://pub.dartlang.org/packages/quick_actions" target="_blank" rel="noopener">quick_actions</a>插件就是一个具体的例子。</p>
</blockquote>
<p><strong>如何获取平台信息</strong></p>
<p>Flutter 中提供了一个全局变量defaultTargetPlatform来获取当前应用的平台信息，defaultTargetPlatform定义在”platform.dart”中，它的类型是TargetPlatform，这是一个枚举类，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TargetPlatform &#123;</span><br><span class="line">  android,</span><br><span class="line">  fuchsia,</span><br><span class="line">  iOS,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到目前Flutter只支持这三个平台。我们可以通过如下代码判断平台：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(defaultTargetPlatform==TargetPlatform.android)&#123;</span><br><span class="line">  <span class="comment">// 是安卓系统，do something</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>Flutter中提供了一种覆盖默认平台的机制，我们可以通过显式指定debugDefaultTargetPlatformOverride全局变量的值来指定应用平台</strong></font>。比如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugDefaultTargetPlatformOverride=TargetPlatform.iOS;</span><br><span class="line"><span class="built_in">print</span>(defaultTargetPlatform); <span class="comment">// 会输出TargetPlatform.iOS</span></span><br></pre></td></tr></table></figure>

<p>上面代码即在Android中运行后，Flutter APP就会认为是当前系统是iOS，Material组件库中所有组件交互方式都会和iOS平台对齐，defaultTargetPlatform的值也会变为TargetPlatform.iOS。</p>
<h3 id="12-3-开发Flutter插件"><a href="#12-3-开发Flutter插件" class="headerlink" title="12.3 开发Flutter插件"></a>12.3 开发Flutter插件</h3><p>下面我们通过一个<strong>获取电池电量的插件</strong>来介绍一下Flutter插件的开发流程。该插件中我们在Dart中通过getBatteryLevel 调用Android BatteryManager API和iOS device.batteryLevel API。</p>
<p><strong>创建一个新的应用程序项目</strong></p>
<p>首先创建一个新的应用程序:</p>
<ul>
<li>在终端中运行：<strong>flutter create batterylevel</strong></li>
</ul>
<p>默认情况下，模板支持使用Java编写Android代码，或使用Objective-C编写iOS代码。要使用Kotlin或Swift，请使用-i和/或-a标志:</p>
<ul>
<li>在终端中运行: flutter create -i swift -a kotlin batterylevel</li>
</ul>
<p><strong>创建Flutter平台客户端</strong></p>
<p>该应用的State类拥有当前的应用状态。我们需要延长这一点以保持当前的电量</p>
<p>首先，我们构建通道。我们使用MethodChannel调用一个方法来返回电池电量。</p>
<p>通道的客户端和宿主通过<strong>通道构造函数中传递的通道名称</strong>进行连接。<font color="#dd0000"><strong>单个应用中使用的所有通道名称必须是唯一的</strong></font>; 我们建议在通道名称前加一个唯一的“域名前缀”，例如samples.flutter.io/battery。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> platform = <span class="keyword">const</span> MethodChannel(<span class="string">'samples.flutter.io/battery'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get battery level.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们调用通道上的方法，指定通过字符串标识符调用方法getBatteryLevel。 该调用可能失败(平台不支持平台API，例如在模拟器中运行时)，所以我们将invokeMethod调用包装在try-catch语句中。</p>
<p>我们使用返回的结果，在setState中来更新用户界面状态batteryLevel。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get battery level.</span></span><br><span class="line"><span class="built_in">String</span> _batteryLevel = <span class="string">'Unknown battery level.'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">Null</span>&gt; _getBatteryLevel() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> batteryLevel;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> result = <span class="keyword">await</span> platform.invokeMethod(<span class="string">'getBatteryLevel'</span>);</span><br><span class="line">    batteryLevel = <span class="string">'Battery level at <span class="subst">$result</span> % .'</span>;</span><br><span class="line">  &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    batteryLevel = <span class="string">"Failed to get battery level: '<span class="subst">$&#123;e.message&#125;</span>'."</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _batteryLevel = batteryLevel;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们在build创建包含一个小字体显示电池状态和一个用于刷新值的按钮的用户界面。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Material(</span><br><span class="line">    child: <span class="keyword">new</span> Center(</span><br><span class="line">      child: <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: [</span><br><span class="line">          <span class="keyword">new</span> RaisedButton(</span><br><span class="line">            child: <span class="keyword">new</span> Text(<span class="string">'Get Battery Level'</span>),</span><br><span class="line">            onPressed: _getBatteryLevel,</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">new</span> Text(_batteryLevel),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此Flutter部分的测试代码写好了，接下来我们需要实现Android和iOS平台下的API，由于平台API实现部分篇幅较大，我们将在接下来的两节中，分别介绍Android和iOS端API的实现。</p>
<p>###12.4 插件开发：Android端API实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.flutter_app;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodCall;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel.MethodCallHandler;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel.Result;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> io.flutter.app.FlutterActivity;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugins.GeneratedPluginRegistrant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContextWrapper;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.os.BatteryManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Build.VERSION;</span><br><span class="line"><span class="keyword">import</span> android.os.Build.VERSION_CODES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHANNEL = <span class="string">"samples.flutter.io/battery"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    GeneratedPluginRegistrant.registerWith(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">new</span> MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(</span><br><span class="line">      <span class="keyword">new</span> MethodCallHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (call.method.equals(<span class="string">"getBatteryLevel"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> batteryLevel = getBatteryLevel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (batteryLevel != -<span class="number">1</span>) &#123;</span><br><span class="line">              result.success(batteryLevel);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              result.error(<span class="string">"UNAVAILABLE"</span>, <span class="string">"Battery level not available."</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.notImplemented();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBatteryLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> batteryLevel = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">      BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE);</span><br><span class="line">      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Intent intent = <span class="keyword">new</span> ContextWrapper(getApplicationContext()).</span><br><span class="line">              registerReceiver(<span class="keyword">null</span>, <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED));</span><br><span class="line">      batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -<span class="number">1</span>) * <span class="number">100</span>) /</span><br><span class="line">              intent.getIntExtra(BatteryManager.EXTRA_SCALE, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batteryLevel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###12.6 Texture和PlatformView</p>
<p>本节主要介绍原生和Flutter之间如何<strong>共享图像</strong>，以及如何在Flutter中嵌套原生组件。</p>
<p>###12.6.1 Texture（示例：使用摄像头）</p>
<p>Texture可以理解为GPU内保存将要绘制的图像数据的一个对象，Flutter engine会将Texture的数据在内存中直接进行映射（而无需在原生和Flutter之间再进行数据传递），Flutter会给每一个Texture分配一个id，同时Flutter中提供了一个Texture组件，Texture构造函数定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Texture(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.textureId,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Texture 组件正是通过textureId与Texture数据关联起来</strong>；<font color="#dd0000"><strong>在Texture组件绘制时，Flutter会自动从内存中找到相应id的Texture数据，然后进行绘制</strong></font>。可以总结一下整个流程：<strong>图像数据先在原生部分缓存，然后在Flutter部分再通过textureId和缓存关联起来，最后绘制由Flutter完成</strong>。</p>
<p>如果我们作为一个插件开发者，我们在原生代码中分配了textureId，那么在Flutter侧使用Texture组件时要如何获取textureId呢？这又回到了之前的内容了，textureId完全可以通过MethodChannel来传递。</p>
<p>另外，值得注意的是，当原生摄像头捕获的图像发生变化时，Texture 组件会自动重绘，这不需要我们写任何Dart 代码去控制。</p>
<h3 id="Texture用法"><a href="#Texture用法" class="headerlink" title="Texture用法"></a>Texture用法</h3><p>由于Flutter官方提供的相机（camera）插件和视频播放（video_player）插件都是使用Texture来实现的。</p>
<p>###12.6.2 PlatformView （示例：WebView）</p>
<p>如果我们在开发过程中需要使用一个原生组件，但这个原生组件在Flutter中很难实现时怎么办（如webview）？这时一个简单的方法就是将需要使用原生组件的页面全部用原生实现，在flutter中需要打开该页面时通过消息通道打开这个原生的页面。但是这种方法有一个最大的缺点，就是原生组件很难和Flutter组件进行组合。</p>
<p>在 Flutter 1.0版本中，Flutter SDK中新增了AndroidView和UIKitView 两个组件，<font color="#dd0000"><strong>这两个组件的主要功能就是将原生的Android组件和iOS组件嵌入到Flutter的组件树中</strong></font>，这个功能是非常重要的，尤其是对一些实现非常复杂的组件，比如webview，这些组件原生已经有了，如果Flutter中要用，重新实现的话成本将非常高，所以如果有一种机制能让Flutter共享原生组件，这将会非常有用，也正因如此，Flutter才提供了这两个组件。</p>
<p>由于AndroidView和UIKitView 是和具体平台相关的，所以称它们为PlatformView。</p>
<h2 id="第十四章-Flutter核心原理"><a href="#第十四章-Flutter核心原理" class="headerlink" title="第十四章 Flutter核心原理"></a>第十四章 Flutter核心原理</h2><p>###14.1 Flutter UI系统</p>
<p>当一帧图像绘制完毕后准备绘制下一帧时，显示器会发出一个垂直同步信号（如VSync）， 60Hz的屏幕就会一秒内发出 60次这样的信号。<strong>而这个信号主要是用于同步CPU、GPU和显示器的</strong>。一般地来说，计算机系统中，CPU、GPU和显示器以一种特定的方式协作：CPU将计算好的显示内容提交给 GPU，GPU渲染后放入帧缓冲区，然后视频控制器按照同步信号从帧缓冲区取帧数据传递给显示器显示。</p>
<p>###14.2.1 Element</p>
<p>UI树其实是由一个个独立的Element节点构成。我们也说过组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>
<p>Element就是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject，但还有一些Element会有多个子节点，如继承自RenderObjectElement的一些类，比如MultiChildRenderObjectElement。最终所有Element的RenderObject构成一棵树，我们称之为”Render Tree“即”渲染树“。总结一下，我们可以认为Flutter的UI系统包含三棵树：<strong>Widget树、Element树、渲染树。他们的依赖关系是：Element树根据Widget树生成，而渲染树又依赖于Element树</strong></p>
<p><img src="http://47.110.40.63:8080/img/blog/Flutter%E4%B8%89%E6%A3%B5%E6%A0%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="img"></p>
<p>现在我们重点看一下Element，Element的生命周期如下：</p>
<ol>
<li>Framework 调用Widget.createElement 创建一个Element实例，记为element</li>
<li>Framework 调用 element.mount(parentElement,newSlot) ，mount方法中首先调用element所对应Widget的createRenderObject方法创建与element相关联的RenderObject对象，然后调用element.attachRenderObject方法将element.renderObject添加到渲染树中插槽指定的位置（这一步不是必须的，一般发生在Element树结构发生变化时才需要重新attach）。插入到渲染树后的element就处于“active”状态，处于“active”状态后就可以显示在屏幕上了（可以隐藏）。</li>
<li>当有父Widget的配置数据改变时，同时其State.build返回的Widget结构与之前不同，此时就需要重新构建对应的Element树。为了进行Element复用，在Element重新构建前会先尝试是否可以复用旧树上相同位置的element，element节点在更新前都会调用其对应Widget的canUpdate方法，如果返回true，则复用旧Element，旧的Element会使用新Widget配置数据更新，反之则会创建一个新的Element。Widget.canUpdate主要是判断newWidget与oldWidget的runtimeType和key是否同时相等，如果同时相等就返回true，否则就会返回false。根据这个原理，当我们需要强制更新一个Widget时，可以通过指定不同的Key来避免复用。</li>
<li>当有祖先Element决定要移除element 时（如Widget树结构发生了变化，导致element对应的Widget被移除），这时该祖先Element就会调用deactivateChild 方法来移除它，移除后element.renderObject也会被从渲染树中移除，然后Framework会调用element.deactivate 方法，这时element状态变为“inactive”状态。</li>
<li>“inactive”态的element将不会再显示到屏幕。为了避免在一次动画执行过程中反复创建、移除某个特定element，“inactive”态的element在当前动画最后一帧结束前都会保留，如果在动画执行结束后它还未能重新变成“active”状态，Framework就会调用其unmount方法将其彻底移除，这时element的状态为defunct,它将永远不会再被插入到树中。</li>
<li>如果element要重新插入到Element树的其它位置，如element或element的祖先拥有一个GlobalKey（用于全局复用元素），那么Framework会先将element从现有位置移除，然后再调用其activate方法，并将其renderObject重新attach到渲染树。</li>
</ol>
<h3 id="14-2-2-BuildContext"><a href="#14-2-2-BuildContext" class="headerlink" title="14.2.2 BuildContext"></a>14.2.2 BuildContext</h3><p>BuildContext就是widget对应的Element，所以我们可以通过context在StatelessWidget和StatefulWidget的build方法中直接访问Element对象。</p>
<p>widget树只是Element树的映射，我们完全可以直接通过Element来搭建一个UI框架。</p>
<p>###14.3 RenderObject和RenderBox</p>
<p><strong>每个Element都对应一个RenderObject，我们可以通过Element.renderObject 来获取。并且我们也说过RenderObject的主要职责是Layout和绘制，所有的RenderObject会组成一棵渲染树Render Tree</strong>。</p>
<p><strong>RenderObject就是渲染树中的一个对象，它拥有一个parent和一个parentData 插槽（slot）</strong>，所谓插槽，就是指预留的一个接口或位置，这个接口和位置是由其它对象来接入或占据的，这个接口或位置在软件中通常用预留变量来表示，而parentData正是一个预留变量，它正是由parent 来赋值的，parent通常会通过子RenderObject的parentData存储一些和子元素相关的数据，如在Stack布局中，RenderStack就会将子元素的偏移数据存储在子元素的parentData中（具体可以查看Positioned实现）。</p>
<p><strong>RenderObject类本身实现了一套基础的layout和绘制协议</strong>，<font color="#dd0000"><strong>但是并没有定义子节点模型</strong></font>（如一个节点可以有几个子节点，没有子节点？一个？两个？或者更多？）。<font color="#dd0000"><strong>它也没有定义坐标系统</strong></font>（如子节点定位是在笛卡尔坐标中还是极坐标？）和<font color="#dd0000"><strong>具体的布局协议</strong></font>（是通过宽高还是通过constraint和size?，或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等）。为此，<strong>Flutter提供了一个RenderBox类，它继承自RenderObject，布局坐标系统采用笛卡尔坐标系，这和Android和iOS原生坐标系是一致的，都是屏幕的top、left是原点，然后分宽高两个轴</strong>，大多数情况下，我们直接使用RenderBox就可以了，除非遇到要自定义布局模型或坐标系统的情况，下面我们重点介绍一下RenderBox。</p>
<p>###14.5 图片加载原理与缓存</p>
<p>Flutter框架对加载过的图片是有缓存的（内存），默认最大缓存数量是1000，最大缓存空间为100M。</p>
<p>###14.5.1 ImageProvider</p>
<p>我们已经知道Image 组件的image 参数是一个<strong>必选参数，它是ImageProvider类型</strong>。ImageProvider是一个抽象类，定义了图片数据获取和加载的相关接口。它的主要职责有两个：</p>
<ol>
<li><strong>提供图片数据源</strong></li>
<li><font color="#dd0000"><strong>缓存图片</strong></font></li>
</ol>
<p>我们看看ImageProvider抽象类的详细定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ImageStream resolve(ImageConfiguration configuration) &#123;</span><br><span class="line">    <span class="comment">// 实现代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; evict(&#123; ImageCache cache,</span><br><span class="line">                      ImageConfiguration configuration = ImageConfiguration.empty &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 实现代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;T&gt; obtainKey(ImageConfiguration configuration); </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  ImageStreamCompleter load(T key); <span class="comment">// 需子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>load(T key)方法</strong></p>
<p>加载图片数据源的接口，不同的数据源的加载方法不同，每个ImageProvider的子类必须实现它。比如NetworkImage类和AssetImage类，它们都是ImageProvider的子类，但它们需要从不同的数据源来加载图片数据：NetworkImage是从网络来加载图片数据，而AssetImage则是从最终的应用包里来加载（加载打到应用安装包里的资源图片）。 我们以NetworkImage为例，看看其load方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">ImageStreamCompleter load(image_provider.NetworkImage key) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;ImageChunkEvent&gt; chunkEvents = StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MultiFrameImageStreamCompleter(</span><br><span class="line">    codec: _loadAsync(key, chunkEvents), <span class="comment">//调用</span></span><br><span class="line">    chunkEvents: chunkEvents.stream,</span><br><span class="line">    scale: key.scale,</span><br><span class="line">    ... <span class="comment">//省略无关代码</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，load方法的返回值类型是ImageStreamCompleter ，它是一个抽象类，<strong>定义了管理图片加载过程的一些接口</strong>，Image Widget中正是通过它来监听图片加载状态的。</p>
<p>MultiFrameImageStreamCompleter 是 ImageStreamCompleter的一个子类，是flutter sdk预置的类，通过该类，我们以方便、轻松地创建出一个ImageStreamCompleter实例来做为load方法的返回值。</p>
<p>我们可以看到，MultiFrameImageStreamCompleter 需要一个codec参数，该参数类型为Future。<strong>Codec 是处理图片编解码的类的一个handler，实际上，它只是一个flutter engine API 的包装类，也就是说图片的编解码逻辑不是在Dart 代码部分实现，而是在flutter engine中实现的</strong>。Codec类部分定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pragma</span>(<span class="string">'vm:entry-point'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> <span class="keyword">extends</span> <span class="title">NativeFieldWrapperClass2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此类由flutter engine创建，不应该手动实例化此类或直接继承此类。</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">'vm:entry-point'</span>)</span><br><span class="line">  Codec._();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">图片中的帧数(动态图会有多帧)</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> frameCount native <span class="string">'Codec_frameCount'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">动画重复的次数</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="bullet">* </span>0 表示只执行一次</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="bullet">* </span>-1 表示循环执行</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> repetitionCount native <span class="string">'Codec_repetitionCount'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">获取下一个动画帧</span></span></span><br><span class="line">  Future&lt;FrameInfo&gt; getNextFrame() &#123;</span><br><span class="line">    <span class="keyword">return</span> _futurize(_getNextFrame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> _getNextFrame(_Callback&lt;FrameInfo&gt; callback) native <span class="string">'Codec_getNextFrame'</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到Codec最终的结果是一个或多个（动图）帧，而这些帧最终会绘制到屏幕上。</p>
<p>MultiFrameImageStreamCompleter 的 codec参数值为_loadAsync方法的返回值，我们继续看_loadAsync方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;ui.Codec&gt; _loadAsync(</span><br><span class="line">   NetworkImage key,</span><br><span class="line">   StreamController&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line"> ) <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//下载图片</span></span><br><span class="line">     <span class="keyword">final</span> <span class="built_in">Uri</span> resolved = <span class="built_in">Uri</span>.base.resolve(key.url);</span><br><span class="line">     <span class="keyword">final</span> HttpClientRequest request = <span class="keyword">await</span> _httpClient.getUrl(resolved);</span><br><span class="line">     headers?.forEach((<span class="built_in">String</span> name, <span class="built_in">String</span> value) &#123;</span><br><span class="line">       request.headers.add(name, value);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">final</span> HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line">     <span class="keyword">if</span> (response.statusCode != HttpStatus.ok)</span><br><span class="line">       <span class="keyword">throw</span> Exception(...);</span><br><span class="line">     <span class="comment">// 接收图片数据 </span></span><br><span class="line">     <span class="keyword">final</span> Uint8List bytes = <span class="keyword">await</span> consolidateHttpClientResponseBytes(</span><br><span class="line">       response,</span><br><span class="line">       onBytesReceived: (<span class="built_in">int</span> cumulative, <span class="built_in">int</span> total) &#123;</span><br><span class="line">         chunkEvents.add(ImageChunkEvent(</span><br><span class="line">           cumulativeBytesLoaded: cumulative,</span><br><span class="line">           expectedTotalBytes: total,</span><br><span class="line">         ));</span><br><span class="line">       &#125;,</span><br><span class="line">     );</span><br><span class="line">     <span class="keyword">if</span> (bytes.lengthInBytes == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> Exception(<span class="string">'NetworkImage is an empty file: <span class="subst">$resolved</span>'</span>);</span><br><span class="line">     <span class="comment">// 对图片数据进行解码</span></span><br><span class="line">     <span class="keyword">return</span> PaintingBinding.instance.instantiateImageCodec(bytes);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     chunkEvents.close();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到_loadAsync方法主要做了两件事：</p>
<ol>
<li><strong>下载图片</strong>。</li>
<li><font color="#dd0000"><strong>对下载的图片数据进行解码</strong></font>。</li>
</ol>
<p>下载逻辑比较简单：通过HttpClient从网上下载图片，另外下载请求会设置一些自定义的header，开发者可以通过NetworkImage的headers命名参数来传递。</p>
<p>在图片下载完成后调用了PaintingBinding.instance.instantiateImageCodec(bytes)对图片进行解码，值得注意的是instantiateImageCodec(…)也是一个Native API的包装，实际上会调用Flutter engine的instantiateImageCodec方法，源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> _instantiateImageCodec(Uint8List list, _Callback&lt;Codec&gt; callback, _ImageInfo imageInfo, <span class="built_in">int</span> targetWidth, <span class="built_in">int</span> targetHeight)</span><br><span class="line">  native <span class="string">'instantiateImageCodec'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>obtainKey(ImageConfiguration)方法</strong></p>
<p>该接口主要是为了配合实现图片缓存，<font color="#dd0000"><strong>ImageProvider从数据源加载完数据后，会在全局的ImageCache中缓存图片数据，而图片数据缓存是一个Map</strong></font>，而Map的key便是调用此方法的返回值，不同的key代表不同的图片数据缓存。</p>
<p><strong>resolve(ImageConfiguration) 方法</strong></p>
<p>resolve方法是ImageProvider的暴露的给Image的主入口方法，它接受一个ImageConfiguration参数，返回ImageStream，即图片数据流。我们重点看一下resolve执行流程：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ImageStream resolve(ImageConfiguration configuration) &#123;</span><br><span class="line">  ... <span class="comment">//省略无关代码</span></span><br><span class="line">  <span class="keyword">final</span> ImageStream stream = ImageStream();</span><br><span class="line">  T obtainedKey; <span class="comment">//</span></span><br><span class="line">  <span class="comment">//定义错误处理函数</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; handleError(<span class="built_in">dynamic</span> exception, StackTrace stack) <span class="keyword">async</span> &#123;</span><br><span class="line">    ... <span class="comment">//省略无关代码</span></span><br><span class="line">    stream.setCompleter(imageCompleter);</span><br><span class="line">    imageCompleter.setError(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新Zone，主要是为了当发生错误时不会干扰MainZone</span></span><br><span class="line">  <span class="keyword">final</span> Zone dangerZone = Zone.current.fork(...);</span><br><span class="line"></span><br><span class="line">  dangerZone.runGuarded(() &#123;</span><br><span class="line">    Future&lt;T&gt; key;</span><br><span class="line">    <span class="comment">// 先验证是否已经有缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 生成缓存key，后面会根据此key来检测是否有缓存</span></span><br><span class="line">      key = obtainKey(configuration);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">      handleError(error, stackTrace);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key.then&lt;<span class="keyword">void</span>&gt;((T key) &#123;</span><br><span class="line">      obtainedKey = key;</span><br><span class="line">      <span class="comment">// 缓存的处理逻辑在这里，记为A，下面详细介绍</span></span><br><span class="line">      <span class="keyword">final</span> ImageStreamCompleter completer = PaintingBinding.instance</span><br><span class="line">          .imageCache.putIfAbsent(key, () =&gt; load(key), onError: handleError);</span><br><span class="line">      <span class="keyword">if</span> (completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stream.setCompleter(completer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catchError(handleError);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImageConfiguration 包含图片和设备的相关信息，如图片的大小、所在的AssetBundle(只有打到安装包的图片存在)以及当前的设备平台、devicePixelRatio（设备像素比等）。Flutter SDK提供了一个便捷函数createLocalImageConfiguration来创建ImageConfiguration 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageConfiguration createLocalImageConfiguration(BuildContext context, &#123; Size size &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> ImageConfiguration(</span><br><span class="line">    bundle: DefaultAssetBundle.of(context),</span><br><span class="line">    devicePixelRatio: MediaQuery.of(context, nullOk: <span class="keyword">true</span>)?.devicePixelRatio ?? <span class="number">1.0</span>,</span><br><span class="line">    locale: Localizations.localeOf(context, nullOk: <span class="keyword">true</span>),</span><br><span class="line">    textDirection: Directionality.of(context),</span><br><span class="line">    size: size,</span><br><span class="line">    platform: defaultTargetPlatform,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现这些信息基本都是通过Context来获取。</p>
<p>上面代码A处就是处理缓存的主要代码，这里的<strong>PaintingBinding.instance.imageCache 是 ImageCache的一个实例，它是PaintingBinding的一个属性，而Flutter框架中的PaintingBinding.instance是一个单例，imageCache事实上也是一个单例，也就是说图片缓存是全局的，统一由PaintingBinding.instance.imageCache 来管理</strong>。</p>
<p>下面我们看看ImageCache类定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> _kDefaultSize = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> _kDefaultSizeBytes = <span class="number">100</span> &lt;&lt; <span class="number">20</span>; <span class="comment">// 100 MiB</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 正在加载中的图片队列</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, _PendingImage&gt; _pendingImages = &lt;<span class="built_in">Object</span>, _PendingImage&gt;&#123;&#125;;</span><br><span class="line">  <span class="comment">// 缓存队列</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, _CachedImage&gt; _cache = &lt;<span class="built_in">Object</span>, _CachedImage&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存数量上限(1000)</span></span><br><span class="line">  <span class="built_in">int</span> _maximumSize = _kDefaultSize;</span><br><span class="line">  <span class="comment">// 缓存容量上限 (100 MB)</span></span><br><span class="line">  <span class="built_in">int</span> _maximumSizeBytes = _kDefaultSizeBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存上限设置的setter</span></span><br><span class="line">  <span class="keyword">set</span> maximumSize(<span class="built_in">int</span> value) &#123;...&#125;</span><br><span class="line">  <span class="keyword">set</span> maximumSizeBytes(<span class="built_in">int</span> value) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  ... <span class="comment">// 省略部分定义</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除所有缓存</span></span><br><span class="line">  <span class="keyword">void</span> clear() &#123;</span><br><span class="line">    <span class="comment">// ...省略具体实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除指定key对应的图片缓存</span></span><br><span class="line">  <span class="built_in">bool</span> evict(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">   <span class="comment">// ...省略具体实现代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ImageStreamCompleter putIfAbsent(<span class="built_in">Object</span> key, ImageStreamCompleter loader(), &#123; ImageErrorListener onError &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(key != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(loader != <span class="keyword">null</span>);</span><br><span class="line">    ImageStreamCompleter result = _pendingImages[key]?.completer;</span><br><span class="line">    <span class="comment">// 图片还未加载成功，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓存，继续往下走</span></span><br><span class="line">    <span class="comment">// 先移除缓存，后再添加，可以让最新使用过的缓存在_map中的位置更近一些，清理时会LRU来清除</span></span><br><span class="line">    <span class="keyword">final</span> _CachedImage image = _cache.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _cache[key] = image;</span><br><span class="line">      <span class="keyword">return</span> image.completer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = loader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onError(error, stackTrace);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">rethrow</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> listener(ImageInfo info, <span class="built_in">bool</span> syncCall) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">int</span> imageSize = info?.image == <span class="keyword">null</span> ? <span class="number">0</span> : info.image.height * info.image.width * <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">final</span> _CachedImage image = _CachedImage(result, imageSize);</span><br><span class="line">      <span class="comment">// 下面是缓存处理的逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (maximumSizeBytes &gt; <span class="number">0</span> &amp;&amp; imageSize &gt; maximumSizeBytes) &#123;</span><br><span class="line">        _maximumSizeBytes = imageSize + <span class="number">1000</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _currentSizeBytes += imageSize;</span><br><span class="line">      <span class="keyword">final</span> _PendingImage pendingImage = _pendingImages.remove(key);</span><br><span class="line">      <span class="keyword">if</span> (pendingImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pendingImage.removeListener();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _cache[key] = image;</span><br><span class="line">      _checkCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maximumSize &gt; <span class="number">0</span> &amp;&amp; maximumSizeBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ImageStreamListener streamListener = ImageStreamListener(listener);</span><br><span class="line">      _pendingImages[key] = _PendingImage(result, streamListener);</span><br><span class="line">      <span class="comment">// Listener is removed in [_PendingImage.removeListener].</span></span><br><span class="line">      result.addListener(streamListener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当缓存数量超过最大值或缓存的大小超过最大缓存容量，会调用此方法清理到缓存上限以内</span></span><br><span class="line">  <span class="keyword">void</span> _checkCacheSize() &#123;</span><br><span class="line">   <span class="keyword">while</span> (_currentSizeBytes &gt; _maximumSizeBytes || _cache.length &gt; _maximumSize) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Object</span> key = _cache.keys.first;</span><br><span class="line">      <span class="keyword">final</span> _CachedImage image = _cache[key];</span><br><span class="line">      _currentSizeBytes -= image.sizeBytes;</span><br><span class="line">      _cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//省略无关代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有缓存则使用缓存，没有缓存则调用load方法加载图片，加载成功后:</p>
<ol>
<li>先判断图片数据有没有缓存，如果有，则直接返回ImageStream。</li>
<li>如果没有缓存，则调用load(T key)方法从数据源加载图片数据，加载成功后先缓存，然后返回ImageStream。</li>
</ol>
<p>另外，我们可以看到ImageCache类中有设置缓存上限的setter，所以，<font color="#dd0000"><strong>如果我们可以自定义缓存上限</strong></font>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PaintingBinding.instance.imageCache.maximumSize=<span class="number">2000</span>; <span class="comment">//最多2000张</span></span><br><span class="line">PaintingBinding.instance.imageCache.maximumSizeBytes = <span class="number">200</span> &lt;&lt; <span class="number">20</span>; <span class="comment">//最大200M</span></span><br></pre></td></tr></table></figure>

<p>现在我们看一下缓存的key，因为Map中相同key的值会被覆盖，也就是说key是图片缓存的一个唯一标识，只要是不同key，那么图片数据就会分别缓存（即使事实上是同一张图片）。那么图片的唯一标识是什么呢？跟踪源码，很容易发现key正是ImageProvider.obtainKey()方法的返回值，而此方法需要ImageProvider子类去重写，这也就意味着不同的ImageProvider对key的定义逻辑会不同。其实也很好理解，比如对于NetworkImage，将图片的url作为key会很合适，而对于AssetImage，则应该将“包名+路径”作为唯一的key。下面我们以NetworkImage为例，看一下它的obtainKey()实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Future&lt;NetworkImage&gt; obtainKey(image_provider.ImageConfiguration configuration) &#123;</span><br><span class="line">  <span class="keyword">return</span> SynchronousFuture&lt;NetworkImage&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，创建了一个同步的future，然后直接将自身做为key返回。因为Map中在判断key（此时是NetworkImage对象）是否相等时会使用“==”运算符，那么定义key的逻辑就是NetworkImage的“==”运算符：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">dynamic</span> other) &#123;</span><br><span class="line">  ... <span class="comment">//省略无关代码</span></span><br><span class="line">  <span class="keyword">final</span> NetworkImage typedOther = other;</span><br><span class="line">  <span class="keyword">return</span> url == typedOther.url</span><br><span class="line">      &amp;&amp; scale == typedOther.scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很清晰，<font color="#dd0000"><strong>对于网络图片来说，会将其“url+缩放比例”作为缓存的key。也就是说</strong>如果两张图片的url或scale只要有一个不同，便会重新下载并分别缓存<strong>。</strong></font></p>
<p>另外，我们需要注意的是，图片缓存是在内存中，并没有进行本地文件持久化存储，这也是为什么网络图片在应用重启后需要重新联网下载的原因。</p>
<p>同时也意味着在应用生命周期内，如果缓存没有超过上限，相同的图片只会被下载一次。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ckacju81r005yf2264bemgs8v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Flutter从0到1构建大前端应用』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/" class="article-date">
  <time datetime="2020-05-06T04:29:29.217Z" itemprop="datePublished">2020-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/">读书笔记『Flutter从0到1构建大前端应用』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-Flutter简介"><a href="#第一章-Flutter简介" class="headerlink" title="第一章 Flutter简介"></a>第一章 Flutter简介</h3><p><strong>P4</strong>：Flutter Engine</p>
<ul>
<li>Skia：2D渲染引擎(Android系统自带，<strong>iOS系统不自带，因此iOS包所占用的存储空间更大</strong>)</li>
<li>Dart：Dart运行时</li>
<li>Text：文本排版引擎</li>
</ul>
<h3 id="第二章-Dart-语言入门"><a href="#第二章-Dart-语言入门" class="headerlink" title="第二章 Dart 语言入门"></a>第二章 Dart 语言入门</h3><p><strong>P18</strong>：Dart是一门强类型语言，在第一次赋值时，<strong>如果已经确定了是字符串类型，则不能更改为别的类型</strong>。如果真的想要改变，可以使用<strong>dynamic</strong>关键字。</p>
<p><strong>P19</strong>：num声明的变量可以加入的是int型，还可以被改成double型，但是反过来int声明的变量不能再赋值为double。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">num</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">30.2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>P23</strong>：使用bool表示布尔值，布尔值只有true和false；可以在debug模式下通过assert断言判断布尔值</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(a.isEmpty);</span><br></pre></td></tr></table></figure>

<p>创建一个不可变数组，使用const[…]</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><strong>P25</strong>：<font color="#dd0000"><strong>使用dynamic时会告诉编译器，我们不用做类型检测，并且知道自己在做什么。</strong></font></p>
<p><strong>P26</strong>：可以使用as，is关键字对类型进行检测</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> obj = &lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">int</span>&gt;) &#123;</span><br><span class="line">  obj[<span class="string">'age'</span>] = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="#dd0000"><strong>~/ 除法，返回一个整数结果</strong></font></p>
        
          <p class="article-more-link">
            <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/" data-id="ckacju811004kf22653tg8kqb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『深入理解Java虚拟机』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/" class="article-date">
  <time datetime="2020-04-19T14:29:40.479Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/">读书笔记『深入理解Java虚拟机』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##第一部分 走进Java</p>
<h3 id="第1章-走进Java"><a href="#第1章-走进Java" class="headerlink" title="第1章 走进Java"></a>第1章 走进Java</h3><p><strong>P11</strong>：HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以<code>方法</code>为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别处罚标准编译和OSR(栈上替换)编译动作。(这点在第11章关于热点代码的描述中有再次提到)</p>
<p><strong>P15</strong>：Dalvik VM并不是一个Java虚拟机，<strong>它没有遵循Java虚拟机规范，不能直接执行Java的Class文件</strong>，使用的是<code>寄存器架构</code>而不是JVM中常见的<code>栈架构</code>。但它执行的dex文件可以通过Class文件转化而来。在Android2.2上已提供即时编译器实现(JIT)，在执行性能上有了很大的提高。</p>
<h2 id="第二部分-自动内存管理机制"><a href="#第二部分-自动内存管理机制" class="headerlink" title="第二部分 自动内存管理机制"></a>第二部分 自动内存管理机制</h2><h3 id="第2章-Java内存区域与内存溢出异常"><a href="#第2章-Java内存区域与内存溢出异常" class="headerlink" title="第2章 Java内存区域与内存溢出异常"></a>第2章 Java内存区域与内存溢出异常</h3><p>运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、方法区(非堆)、堆。其中前三个为线程私有的。</p>
<p><strong>P39</strong>：程序计数器</p>
<p>程序计数器是一块较小的内存空间，可以看作是<code>当前线程</code>所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变之歌计数器的值来选取下一条需要执行的字节码指令的。<strong>程序计数器是线程私有的</strong>，这很容易理解。如果正在执行的是Native方法，这个计数器值则为空。<code>程序计数器是内存区域中唯一Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</code>(可能是因为它本身占据的内存很小吧)</p>
        
          <p class="article-more-link">
            <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/" data-id="ckacju816004yf226048f2hbj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android基础『V1V2V3签名』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" class="article-date">
  <time datetime="2020-04-10T07:24:34.404Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>基础概念</p>
<p>签名：在 APK 中写入一个「指纹」。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。</p>
<p>摘要算法：<font color="#dd0000"><strong>使用一段简单的看上去随机的不可逆向的固定长度的字符串来表示一个文件的唯一性。</strong></font>常见的摘要算法如MD5(128个比特位)、SHA-1算法(160/192/256个比特位)。</p>
<p>公钥密码体制：也称非对称算法，特点是<strong>公钥是公开的</strong>，私钥是保密的。常见的如：RSA。</p>
<p>展开讨论一下RSA：</p>
<ol>
<li>加密：公钥加密，私钥解密的过程，称为「加密」。</li>
<li><strong>签名：私钥加密，公钥解密的过程，称为「签名」。</strong>加签用来证明这段密文是有公钥对应的私钥拥有者发出的。</li>
</ol>
<p>网络传输一般不会对整个文件进行签名，因为非对称加密效率比较低。所以一般使用<font color="#dd0000"><strong>摘要算法+RSA算法</strong></font>实现，传输使用RSA的私钥对文件的摘要信息进行加密作为摘要；接受者接收到文件后，对文件使用相同的摘要算法对文件求摘要值，然后再使用公钥解密加密过得摘要，比较两个摘要值判断文件是否合法。</p>
<p>数字证书：尽管使用RSA +摘要算法可以实现文件的可靠性检测。但是仍然存在问题，<font color="#dd0000"><strong>问题在于公钥是公开的，</strong></font>比如某些钓鱼网站，直接下发一个他自己的公钥，那么用户就算验证了文件的合法性。依然会进圈套，因为用户不知道和他交互的是否是正确的对象。</p>
<p>所以需要一个权威的CA机构，用来<font color="#dd0000"><strong>颁发数字证书，用以认证用户手上公开的公钥</strong></font>，这些权威的CA机构将他们的证书先预置在机器里，然后使用他们的私钥对申请数字证书的公钥以及其他信息(有效期、签名算法、数字签名blalala)进行加密，从而得到一个数字证书。用来验证自己所访问的对象是否是正确的。</p>
<hr>
<p>Android中的签名方案</p>
<p><font color="#dd0000"><strong>V1</strong></font>：基于jarsigner(JDK自带工具，使用keystore文件进行签名) 或 apksigner(Android专门提供的，使用pk8、x509.pem进行签名)。keystore和pk8/x509.pem可以相互转换。</p>
<p>签名原理：首先keystore文件包含一个MD5和一个SHA1摘要。<strong>这也是很多开放平台需要我们上传的摘要数据</strong>。</p>
<p>签名APK后会在META-INF文件夹下生产CERT.RSA、CERT.SF、MANIFEST.MF三个文件。</p>
<p>在apk中，/META-INF文件夹中保存着apk的签名信息，一般至少包含三个文件，[CERT].RSA，[CERT].SF和MANIFEIST.MF文件。这三个文件就是对apk的签名信息。</p>
        
          <p class="article-more-link">
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" data-id="ckacju80d0033f22635cx6j43" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Java并发编程实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.097Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h3><p><strong>P1</strong>：在不同的<strong>进程</strong>之间可以通过一些<strong>粗粒度</strong>的通讯机制来完成交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。</p>
<p><strong>P7</strong>：安全性的含义是”永远不发生糟糕的事情”，而<strong>活跃性</strong>则关注于另一个目标，即<strong>某件正确的事情最终会发生</strong>。当某个操作无法继续执行下去时，就会发生活跃性问题。</p>
<p><strong>P8</strong>：在Servlet规范中，Servlet同样需要满足被多个线程同事调用，换句话说，<strong>Servlet需要是线程安全的。</strong></p>
<h3 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h3><p><strong>P11</strong>：要编写线程安全的代码，其核心在于<strong>要对状态访问操作进行管理</strong>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p>
<p><strong>P13</strong>：在线程安全性的定义中，最核心的概念就是<strong>正确性</strong>。正确性的含义是，<font color="#dd0000"><strong>某个类的行为与其规范完全一致</strong></font>。</p>
<p><strong>P15</strong>：当某个计算的正确性取决于多个线程<strong>交替执行时序</strong>时，那么久就会发生<font color="#dd0000"><strong>竞态条件</strong></font>。</p>
<p><strong>P16</strong>：竞态条件的本质——<strong>基于</strong>一种可能<font color="#dd0000"><strong>失效的观察结果</strong></font>来做出判断或者执行某个计算。</p>
<p><strong>P18</strong>：在java.util.concurrent.atomic包中包含了一些<strong>原子变量类</strong>，用于实现在<strong>数值</strong>和<font color="#dd0000"><strong>对象引用</strong></font>上的原子状态转换。如：<strong>AtomicLong</strong>，<strong>AtomicReference</strong>。</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ckacju815004uf2262e3o94ld" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目『腾讯MMKV存储框架』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.095Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MMKV的介绍"><a href="#MMKV的介绍" class="headerlink" title="MMKV的介绍"></a>MMKV的介绍</h2><p>MMKV 是基于 <font color="#dd0000"><strong>mmap 内存映射</strong></font>的 key-value 组件，<strong>底层序列化/反序列化使用 protobuf 实现</strong>，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>高性能 实时写入</strong></li>
<li><strong>稳定 防crash</strong></li>
<li><strong>多进程访问</strong><br> 通过与 Android 开发同学的沟通，了解到系统自带的 SharedPreferences 对多进程的支持不好。<br> 现有基于 ContentProvider 封装的实现，虽然多进程是支持了，但是性能低下，经常导致 ANR。<br> 考虑到 mmap 共享内存本质上的多进程共享的，我们在这个基础上，深入挖掘了 Android 系统的能力，提供了可能是业界最高效的多进程数据共享组件。</li>
<li><strong>匿名内存</strong><br> 在多进程共享的基础上，考虑到某些敏感数据(例如密码)需要进程间共享，但是不方便落地存储到文件上，直接用 mmap 不合适。<br> 我们了解到 Android 系统提供了 Ashmem 匿名共享内存的能力，发现它在进程退出后就会消失，不会落地到文件上，非常适合这个场景。<br> 我们很愉快地提供了 Ashmem MMKV 的功能。</li>
<li><strong>数据加密</strong><br> 不像 iOS 提供了硬件层级的加密机制，在 Android 环境里，数据加密是非常必须的。<br> MMKV 使用了 AES CFB-128 算法来加密/解密。我们选择 CFB 而不是常见的 CBC 算法，<br> 主要是因为 MMKV 使用 append-only 实现插入/更新操作，流式加密算法更加合适。</li>
<li><strong>数据有效性</strong></li>
</ul>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" data-id="ckacju80z004bf226h5rc26m8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目——OkHttp『源码学习』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.091Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OKHttp是个优秀的开源项目，值得学习。但是代码量比EventBus、Retrofit之类的大多了。想要一下子没有遗漏的都搞清楚不是一件容易的事情。这篇博客，是我在学习过程中的一些问题，有些自觉找到了答案，有些还不知道如何回答，留待以后补充吧。</p>
<h2 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h2><ol>
<li><p>异步，同步队列共用线程池吗？共用请求数量限制(maxRequests和maxRequestsPerHost)吗？</p>
<p>答：<code>请求数量限制只对异步队列有效</code>，对于同步任务不做限制，只管添加执行就得了。</p>
</li>
<li><p>为什么不直接使用线程池，而是自己另外维护了工作队列？</p>
<p>答：首先这里使用了的线程池是基于同步队列的，而同步队列本身是不支持工作队列的，所以需要一个额外的工作队列来维护任务的提交工作。</p>
</li>
<li><p>为什么OkHttp的异步任务选择使用两个队列维护？而不是使用一个工作队列实现？</p>
<p>答：说下我自己的看法，首先为什么需要两个队列，因为在提交异步任务是需要统计当前的运行中的任务数量，使用一个队列的话，还需要遍历队列中的任务状态，而将等待运行和运行中分离开来可以避免这种困扰，减少问题发生的可能性。</p>
</li>
<li><p>等待队列中的任务何时触发运行？</p>
<p>答：不管是异步任务还是同步任务，任务的执行代码都包含在一个try…catch代码块中，该代码块的finally中执行dispatcher.finished(this)，在finished()方法中首先会从异步运行中队列中移除代表当前任务的Call对象，然后会去异步等待就绪队列中拿任务放到异步运行中队列中，并执行任务。看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.finished()</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//首先从运行队列中移除当前已完成的Call对象</span></span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      <span class="comment">//这个promoteCalls()方法中，会从异步就绪等待队列中拿取任务放到异步运行队列并执行</span></span><br><span class="line">      <span class="keyword">if</span> (promoteCalls) promoteCalls(); </span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有任务在运行时，触发回调，暂时不知道使用场景</span></span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下调度等待就绪任务的promoteCalls()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.promoteCalls()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//从当前等待就绪队列中移除当前Call对象</span></span><br><span class="line">        i.remove();</span><br><span class="line">        <span class="comment">//添加Call到运行队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果okhttpclient不作为单例使用，那么线程池是否就有多个了，Dispatcher呢？</p>
<p><strong>答</strong>：每个OkHttpClient对象实例对应一个Dispatcher，因此也就意味着多个OkHttpClient对应着多个线程池。</p>
</li>
<li><p>RetryAndFollowUpInterceptor中的重试指的是什么？是重试连接还是跳转？还是包含了这两个动作：重连次数和跳转数限制？</p>
<p><strong>答</strong>：</p>
</li>
<li><p>缓存需要手动指定才能生效吗？缓存机制是什么？</p>
</li>
<li><p>DiskLruCache算法的具体细节是什么？缓存清理线程的工作原理是什么？</p>
</li>
<li><p>为什么要把AsyncCall定义成RealCall的内部类？有什么好处吗？</p>
</li>
<li><p>为什么缓存管理需要另外一个日志文件？</p>
</li>
<li><p>为什么DiskLruCache的内部类Entry需要一个cleanFiles文件数组和一个dirtyFiles文件数组？</p>
</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" data-id="ckacju81q005xf226c5idgbgz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java进阶『Javassist学习笔记』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.088Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.javassist.org/" target="_blank" rel="noopener">http://www.javassist.org/</a></p>
<h3 id="文档翻译"><a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h3><ol>
<li><p>读取和写入字节码</p>
<p>Javassist是一个用于处理Java字节码的类库。Java字节码被存储在class文件中，每个class文件包含一个Java类或者接口。</p>
<p>Javassist.CtClass是一个class文件的抽象代表。一个CtClass对象可以(在编译期)用来处理一个class文件。以下面代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段代码首先获得一个ClassPool对象，ClassPool是CtClass所代表的class文件的容器。ClassPool会在构造CtClass对象时去读取class文件，并且持有构造好的CtClass对象以便之后使用。想要修改一个class，首先需要通过ClassPool获取到一个CtClass对象。ClassPool对象的get()方法可以用来实现这个目的。</p>
<p>从实现细节来说，ClassPool是一个以class的名字为key用来存储CtClass对象的哈希表，get()会从哈希表中根据传入的key查找CtClass对象。如果未能查找到缓存对象，get()方法会创建一个新的CtClass对象，并将这个新建的对象保存到哈希表中，然后返回给调用方。</p>
<p>从ClassPool中获取到的CtClass对象可以被修改，在上面的代码中，cc的superclass被修改成了test.Point。</p>
<p>writeFile()实现了从CtClass对象到class文件的转换，并将他写入到了本地磁盘。Javassist也提供了一种直接获取修改过的二进制代码的方法toBytecode()。除此之外，还可以直接载入CtClass：</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" data-id="ckacju80l003nf226ci0jaezw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『线程相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.087Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/">Java『线程相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Java『线程相关』### Java线程<br><strong>线程是进程中实施调度和分派的基本单位</strong>。一个进程可以包含多个线程，一个线程只能在一个进程的地址空间内活动。</p>
<h5 id="一、线程状态"><a href="#一、线程状态" class="headerlink" title="一、线程状态"></a>一、线程状态</h5><p>​    线程有6种状态，new，runnable，blocked，waiting(等待其他线程执行结束)，timed_waiting(等待其他线程结束，设定超时)，terminated(Thread类中一个State枚举了线程的所有状态）。</p>
<h5 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h5><ol>
<li>使用synchronized关键字修饰方法。由于java的<font color="#dd0000"><strong>每个对象都有一个内置锁</strong></font>，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。注： synchronized关键字也可以<font color="#dd0000"><strong>修饰静态方法</strong></font>，此时如果调用该静态方法，将会<font color="#dd0000"><strong>锁住整个类</strong></font>。</li>
<li>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ckacju80m003pf226a69a5e8k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/" rel="tag">Android，性能优化，电量优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JetPack/" rel="tag">JetPack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paging/" rel="tag">Paging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Room/" rel="tag">Room</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava2/" rel="tag">RxJava2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" rel="tag">开源项目学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Android%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/" style="font-size: 10px;">Android，性能优化，电量优化</a> <a href="/tags/Flutter/" style="font-size: 12.5px;">Flutter</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JetPack/" style="font-size: 12.5px;">JetPack</a> <a href="/tags/Kotlin/" style="font-size: 12.5px;">Kotlin</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Paging/" style="font-size: 10px;">Paging</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Room/" style="font-size: 10px;">Room</a> <a href="/tags/RxJava2/" style="font-size: 12.5px;">RxJava2</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">开源项目学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">源码学习</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 10px;">组件化</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/12/Android%E3%80%8E%E7%94%B5%E9%87%8F%E7%9B%91%E6%B5%8B%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8%E3%80%8F/">Android『电量检测及优化使用』</a>
          </li>
        
          <li>
            <a href="/2020/05/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Flutter实战』</a>
          </li>
        
          <li>
            <a href="/2020/05/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EFlutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E3%80%8F/">读书笔记『Flutter从0到1构建大前端应用』</a>
          </li>
        
          <li>
            <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/">读书笔记『深入理解Java虚拟机』</a>
          </li>
        
          <li>
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ > </script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>