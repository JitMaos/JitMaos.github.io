<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-读书笔记『深入理解Java虚拟机』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/" class="article-date">
  <time datetime="2020-04-19T14:29:40.479Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/">读书笔记『深入理解Java虚拟机』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##第一部分 走进Java</p>
<h3 id="第1章-走进Java"><a href="#第1章-走进Java" class="headerlink" title="第1章 走进Java"></a>第1章 走进Java</h3><p><strong>P11</strong>：HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以<code>方法</code>为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别处罚标准编译和OSR(栈上替换)编译动作。(这点在第11章关于热点代码的描述中有再次提到)</p>
<p><strong>P15</strong>：Dalvik VM并不是一个Java虚拟机，<strong>它没有遵循Java虚拟机规范，不能直接执行Java的Class文件</strong>，使用的是<code>寄存器架构</code>而不是JVM中常见的<code>栈架构</code>。但它执行的dex文件可以通过Class文件转化而来。在Android2.2上已提供即时编译器实现(JIT)，在执行性能上有了很大的提高。</p>
<h2 id="第二部分-自动内存管理机制"><a href="#第二部分-自动内存管理机制" class="headerlink" title="第二部分 自动内存管理机制"></a>第二部分 自动内存管理机制</h2><h3 id="第2章-Java内存区域与内存溢出异常"><a href="#第2章-Java内存区域与内存溢出异常" class="headerlink" title="第2章 Java内存区域与内存溢出异常"></a>第2章 Java内存区域与内存溢出异常</h3><p>运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、方法区(非堆)、堆。其中前三个为线程私有的。</p>
<p><strong>P39</strong>：程序计数器</p>
<p>程序计数器是一块较小的内存空间，可以看作是<code>当前线程</code>所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变之歌计数器的值来选取下一条需要执行的字节码指令的。<strong>程序计数器是线程私有的</strong>，这很容易理解。如果正在执行的是Native方法，这个计数器值则为空。<code>程序计数器是内存区域中唯一Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</code>(可能是因为它本身占据的内存很小吧)</p>
        
          <p class="article-more-link">
            <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/" data-id="ck9kkco9z004u8526ekpa5o39" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android基础『V1V2V3签名』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" class="article-date">
  <time datetime="2020-04-10T07:24:34.404Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>基础概念</p>
<p>签名：在 APK 中写入一个「指纹」。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。</p>
<p>摘要算法：<font color="#dd0000"><strong>使用一段简单的看上去随机的不可逆向的固定长度的字符串来表示一个文件的唯一性。</strong></font>常见的摘要算法如MD5(128个比特位)、SHA-1算法(160/192/256个比特位)。</p>
<p>公钥密码体制：也称非对称算法，特点是<strong>公钥是公开的</strong>，私钥是保密的。常见的如：RSA。</p>
<p>展开讨论一下RSA：</p>
<ol>
<li>加密：公钥加密，私钥解密的过程，称为「加密」。</li>
<li><strong>签名：私钥加密，公钥解密的过程，称为「签名」。</strong>加签用来证明这段密文是有公钥对应的私钥拥有者发出的。</li>
</ol>
<p>网络传输一般不会对整个文件进行签名，因为非对称加密效率比较低。所以一般使用<font color="#dd0000"><strong>摘要算法+RSA算法</strong></font>实现，传输使用RSA的私钥对文件的摘要信息进行加密作为摘要；接受者接收到文件后，对文件使用相同的摘要算法对文件求摘要值，然后再使用公钥解密加密过得摘要，比较两个摘要值判断文件是否合法。</p>
<p>数字证书：尽管使用RSA +摘要算法可以实现文件的可靠性检测。但是仍然存在问题，<font color="#dd0000"><strong>问题在于公钥是公开的，</strong></font>比如某些钓鱼网站，直接下发一个他自己的公钥，那么用户就算验证了文件的合法性。依然会进圈套，因为用户不知道和他交互的是否是正确的对象。</p>
<p>所以需要一个权威的CA机构，用来<font color="#dd0000"><strong>颁发数字证书，用以认证用户手上公开的公钥</strong></font>，这些权威的CA机构将他们的证书先预置在机器里，然后使用他们的私钥对申请数字证书的公钥以及其他信息(有效期、签名算法、数字签名blalala)进行加密，从而得到一个数字证书。用来验证自己所访问的对象是否是正确的。</p>
<hr>
<p>Android中的签名方案</p>
<p><font color="#dd0000"><strong>V1</strong></font>：基于jarsigner(JDK自带工具，使用keystore文件进行签名) 或 apksigner(Android专门提供的，使用pk8、x509.pem进行签名)。keystore和pk8/x509.pem可以相互转换。</p>
<p>签名原理：首先keystore文件包含一个MD5和一个SHA1摘要。<strong>这也是很多开放平台需要我们上传的摘要数据</strong>。</p>
<p>签名APK后会在META-INF文件夹下生产CERT.RSA、CERT.SF、MANIFEST.MF三个文件。</p>
<p>在apk中，/META-INF文件夹中保存着apk的签名信息，一般至少包含三个文件，[CERT].RSA，[CERT].SF和MANIFEIST.MF文件。这三个文件就是对apk的签名信息。</p>
        
          <p class="article-more-link">
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" data-id="ck9kkco8c003085262mdq4j03" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Java并发编程实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.097Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h3><p><strong>P1</strong>：在不同的<strong>进程</strong>之间可以通过一些<strong>粗粒度</strong>的通讯机制来完成交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。</p>
<p><strong>P7</strong>：安全性的含义是”永远不发生糟糕的事情”，而<strong>活跃性</strong>则关注于另一个目标，即<strong>某件正确的事情最终会发生</strong>。当某个操作无法继续执行下去时，就会发生活跃性问题。</p>
<p><strong>P8</strong>：在Servlet规范中，Servlet同样需要满足被多个线程同事调用，换句话说，<strong>Servlet需要是线程安全的。</strong></p>
<h3 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h3><p><strong>P11</strong>：要编写线程安全的代码，其核心在于<strong>要对状态访问操作进行管理</strong>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p>
<p><strong>P13</strong>：在线程安全性的定义中，最核心的概念就是<strong>正确性</strong>。正确性的含义是，<font color="#dd0000"><strong>某个类的行为与其规范完全一致</strong></font>。</p>
<p><strong>P15</strong>：当某个计算的正确性取决于多个线程<strong>交替执行时序</strong>时，那么久就会发生<font color="#dd0000"><strong>竞态条件</strong></font>。</p>
<p><strong>P16</strong>：竞态条件的本质——<strong>基于</strong>一种可能<font color="#dd0000"><strong>失效的观察结果</strong></font>来做出判断或者执行某个计算。</p>
<p><strong>P18</strong>：在java.util.concurrent.atomic包中包含了一些<strong>原子变量类</strong>，用于实现在<strong>数值</strong>和<font color="#dd0000"><strong>对象引用</strong></font>上的原子状态转换。如：<strong>AtomicLong</strong>，<strong>AtomicReference</strong>。</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ck9kkco9m004o852657diflhx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目『腾讯MMKV存储框架』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.095Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MMKV的介绍"><a href="#MMKV的介绍" class="headerlink" title="MMKV的介绍"></a>MMKV的介绍</h2><p>MMKV 是基于 <font color="#dd0000"><strong>mmap 内存映射</strong></font>的 key-value 组件，<strong>底层序列化/反序列化使用 protobuf 实现</strong>，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>高性能 实时写入</strong></li>
<li><strong>稳定 防crash</strong></li>
<li><strong>多进程访问</strong><br> 通过与 Android 开发同学的沟通，了解到系统自带的 SharedPreferences 对多进程的支持不好。<br> 现有基于 ContentProvider 封装的实现，虽然多进程是支持了，但是性能低下，经常导致 ANR。<br> 考虑到 mmap 共享内存本质上的多进程共享的，我们在这个基础上，深入挖掘了 Android 系统的能力，提供了可能是业界最高效的多进程数据共享组件。</li>
<li><strong>匿名内存</strong><br> 在多进程共享的基础上，考虑到某些敏感数据(例如密码)需要进程间共享，但是不方便落地存储到文件上，直接用 mmap 不合适。<br> 我们了解到 Android 系统提供了 Ashmem 匿名共享内存的能力，发现它在进程退出后就会消失，不会落地到文件上，非常适合这个场景。<br> 我们很愉快地提供了 Ashmem MMKV 的功能。</li>
<li><strong>数据加密</strong><br> 不像 iOS 提供了硬件层级的加密机制，在 Android 环境里，数据加密是非常必须的。<br> MMKV 使用了 AES CFB-128 算法来加密/解密。我们选择 CFB 而不是常见的 CBC 算法，<br> 主要是因为 MMKV 使用 append-only 实现插入/更新操作，流式加密算法更加合适。</li>
<li><strong>数据有效性</strong></li>
</ul>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" data-id="ck9kkco8y00448526cj0oav7a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目——OkHttp『源码学习』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.091Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OKHttp是个优秀的开源项目，值得学习。但是代码量比EventBus、Retrofit之类的大多了。想要一下子没有遗漏的都搞清楚不是一件容易的事情。这篇博客，是我在学习过程中的一些问题，有些自觉找到了答案，有些还不知道如何回答，留待以后补充吧。</p>
<h2 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h2><ol>
<li><p>异步，同步队列共用线程池吗？共用请求数量限制(maxRequests和maxRequestsPerHost)吗？</p>
<p>答：<code>请求数量限制只对异步队列有效</code>，对于同步任务不做限制，只管添加执行就得了。</p>
</li>
<li><p>为什么不直接使用线程池，而是自己另外维护了工作队列？</p>
<p>答：首先这里使用了的线程池是基于同步队列的，而同步队列本身是不支持工作队列的，所以需要一个额外的工作队列来维护任务的提交工作。</p>
</li>
<li><p>为什么OkHttp的异步任务选择使用两个队列维护？而不是使用一个工作队列实现？</p>
<p>答：说下我自己的看法，首先为什么需要两个队列，因为在提交异步任务是需要统计当前的运行中的任务数量，使用一个队列的话，还需要遍历队列中的任务状态，而将等待运行和运行中分离开来可以避免这种困扰，减少问题发生的可能性。</p>
</li>
<li><p>等待队列中的任务何时触发运行？</p>
<p>答：不管是异步任务还是同步任务，任务的执行代码都包含在一个try…catch代码块中，该代码块的finally中执行dispatcher.finished(this)，在finished()方法中首先会从异步运行中队列中移除代表当前任务的Call对象，然后会去异步等待就绪队列中拿任务放到异步运行中队列中，并执行任务。看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.finished()</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//首先从运行队列中移除当前已完成的Call对象</span></span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      <span class="comment">//这个promoteCalls()方法中，会从异步就绪等待队列中拿取任务放到异步运行队列并执行</span></span><br><span class="line">      <span class="keyword">if</span> (promoteCalls) promoteCalls(); </span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有任务在运行时，触发回调，暂时不知道使用场景</span></span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下调度等待就绪任务的promoteCalls()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.promoteCalls()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//从当前等待就绪队列中移除当前Call对象</span></span><br><span class="line">        i.remove();</span><br><span class="line">        <span class="comment">//添加Call到运行队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果okhttpclient不作为单例使用，那么线程池是否就有多个了，Dispatcher呢？</p>
<p><strong>答</strong>：每个OkHttpClient对象实例对应一个Dispatcher，因此也就意味着多个OkHttpClient对应着多个线程池。</p>
</li>
<li><p>RetryAndFollowUpInterceptor中的重试指的是什么？是重试连接还是跳转？还是包含了这两个动作：重连次数和跳转数限制？</p>
<p><strong>答</strong>：</p>
</li>
<li><p>缓存需要手动指定才能生效吗？缓存机制是什么？</p>
</li>
<li><p>DiskLruCache算法的具体细节是什么？缓存清理线程的工作原理是什么？</p>
</li>
<li><p>为什么要把AsyncCall定义成RealCall的内部类？有什么好处吗？</p>
</li>
<li><p>为什么缓存管理需要另外一个日志文件？</p>
</li>
<li><p>为什么DiskLruCache的内部类Entry需要一个cleanFiles文件数组和一个dirtyFiles文件数组？</p>
</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" data-id="ck9kkcoag005q85264mty4bcy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java进阶『Javassist学习笔记』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.088Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.javassist.org/" target="_blank" rel="noopener">http://www.javassist.org/</a></p>
<h3 id="文档翻译"><a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h3><ol>
<li><p>读取和写入字节码</p>
<p>Javassist是一个用于处理Java字节码的类库。Java字节码被存储在class文件中，每个class文件包含一个Java类或者接口。</p>
<p>Javassist.CtClass是一个class文件的抽象代表。一个CtClass对象可以(在编译期)用来处理一个class文件。以下面代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段代码首先获得一个ClassPool对象，ClassPool是CtClass所代表的class文件的容器。ClassPool会在构造CtClass对象时去读取class文件，并且持有构造好的CtClass对象以便之后使用。想要修改一个class，首先需要通过ClassPool获取到一个CtClass对象。ClassPool对象的get()方法可以用来实现这个目的。</p>
<p>从实现细节来说，ClassPool是一个以class的名字为key用来存储CtClass对象的哈希表，get()会从哈希表中根据传入的key查找CtClass对象。如果未能查找到缓存对象，get()方法会创建一个新的CtClass对象，并将这个新建的对象保存到哈希表中，然后返回给调用方。</p>
<p>从ClassPool中获取到的CtClass对象可以被修改，在上面的代码中，cc的superclass被修改成了test.Point。</p>
<p>writeFile()实现了从CtClass对象到class文件的转换，并将他写入到了本地磁盘。Javassist也提供了一种直接获取修改过的二进制代码的方法toBytecode()。除此之外，还可以直接载入CtClass：</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" data-id="ck9kkco8n003k8526eeg01fen" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『线程相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.087Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/">Java『线程相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Java『线程相关』### Java线程<br><strong>线程是进程中实施调度和分派的基本单位</strong>。一个进程可以包含多个线程，一个线程只能在一个进程的地址空间内活动。</p>
<h5 id="一、线程状态"><a href="#一、线程状态" class="headerlink" title="一、线程状态"></a>一、线程状态</h5><p>​    线程有6种状态，new，runnable，blocked，waiting(等待其他线程执行结束)，timed_waiting(等待其他线程结束，设定超时)，terminated(Thread类中一个State枚举了线程的所有状态）。</p>
<h5 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h5><ol>
<li>使用synchronized关键字修饰方法。由于java的<font color="#dd0000"><strong>每个对象都有一个内置锁</strong></font>，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。注： synchronized关键字也可以<font color="#dd0000"><strong>修饰静态方法</strong></font>，此时如果调用该静态方法，将会<font color="#dd0000"><strong>锁住整个类</strong></font>。</li>
<li>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ck9kkco8r003q8526cl76agtd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『Javap命令』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.086Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/">Java『Javap命令』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看JVM的运行时数据区，包括：虚拟机栈、程序计数器、本地方法栈、方法区和堆；其中虚拟机栈中存储的是栈帧，而栈帧是由<font color="#dd0000"><strong>局部变量表、操作数栈</strong></font>、动态链接、方法出口等组成。今天学习一下Javap命令，通过对字节码进行反编译来查看局部变量表的细节。</p>
<p>javap -v cclassName，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。<br>javap -l className，会输出行号和本地变量表信息。<br>javap -c className，会对当前class字节码进行反编译生成汇编代码。</p>
<ol>
<li>新建TreeNode.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用javac编译生成class文件</li>
<li>输入命令：javap -v TreeNode.class</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Classfile TreeNode<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-2-3</span>; size <span class="number">370</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">6</span>db15fb197ff5952f8b106978416b74a</span><br><span class="line">  Compiled from <span class="string">"TreeNode.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">leon</span>.<span class="title">LeetCode</span>.<span class="title">TreeNode</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#19         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#20         // com/leon/LeetCode/TreeNode.val:I</span><br><span class="line">   #3 = Class              #21            // com/leon/LeetCode/TreeNode</span><br><span class="line">   #4 = Class              #22            // java/lang/Object</span><br><span class="line">   #5 = Utf8               val</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               left</span><br><span class="line">   #8 = Utf8               Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">   #9 = Utf8               right</span><br><span class="line">  #10 = Utf8               &lt;init&gt;</span><br><span class="line">  #11 = Utf8               (I)V</span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line">  #13 = Utf8               LineNumberTable</span><br><span class="line">  #14 = Utf8               LocalVariableTable</span><br><span class="line">  #15 = Utf8               this</span><br><span class="line">  #16 = Utf8               x</span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line">  #18 = Utf8               TreeNode.java</span><br><span class="line">  #19 = NameAndType        #10:#23        // "&lt;init&gt;":()V</span><br><span class="line">  #20 = NameAndType        #5:#6          // val:I</span><br><span class="line">  #21 = Utf8               com/leon/LeetCode/TreeNode</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               ()V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode left;</span><br><span class="line">    descriptor: Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode right;</span><br><span class="line">    descriptor: Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode(<span class="keyword">int</span>);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         6: putfield      #2                  // Field val:I</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">1</span>     x   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>常见的字节码命令</p>
<table>
<thead>
<tr>
<th>Bytecode</th>
<th>Stackbefore-&gt;after</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>iconst_0</td>
<td>-&gt;0</td>
<td>Loads the int value 0 onto the stack //从栈中读取变量</td>
</tr>
<tr>
<td>istore_1</td>
<td>value-&gt;</td>
<td>Store int value into variable 1 //将变量压入栈</td>
</tr>
<tr>
<td>istore_2</td>
<td>value-&gt;</td>
<td>Store int value into variable 2 //将变量压入栈</td>
</tr>
<tr>
<td>iinc</td>
<td>No change</td>
<td>Increment local variable #index by signed byte const</td>
</tr>
<tr>
<td>iload_1</td>
<td>-&gt;value</td>
<td>Loads an int value from variable 1 //加载变量的值</td>
</tr>
<tr>
<td>iadd</td>
<td>value 1,value 2-&gt;result</td>
<td>Adds 2 ints together //将两个变量相加</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/" data-id="ck9kkco8i003b852681m2apyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android『保活相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E3%80%8E%E4%BF%9D%E6%B4%BB%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.075Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E3%80%8E%E4%BF%9D%E6%B4%BB%E7%9B%B8%E5%85%B3%E3%80%8F/">Android『保活相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="Service的兼容"><a href="#Service的兼容" class="headerlink" title="Service的兼容"></a>Service的兼容</h4><ol>
<li>5.0以后不再支持隐式Intent方式启动外部Service。</li>
<li>8.0以后对后台服务有了更多的限制，对服务做了前台服务、后台服务的区分。<strong>应用进入后台时，有一个短暂的时间窗口，可以在该时间窗口内创建和使用服务，在时间窗口结束后，应用将被视为空闲状态，此时，系统将停止应用的</strong><font color="#dd0000"><strong>后台服务</strong></font>，就像应用已经调用服务的<strong>Service.stopSelf()</strong>一样。</li>
<li>基于<strong>2</strong>，Android 8.0引入了一个新方法<strong>Context.startForegroundService()</strong>，在系统创建服务后，应用有五秒的时间调用startForeground()，来显示新服务的可见通知(Notification)。<strong>如果应用在此期间限制内未调用startForeground()，则系统将停止并声明此应用为ANR</strong>。</li>
<li>Android在8.0限制了后台服务这些，启动后台服务需要设置通知栏，使服务变成前台服务。但是在<font color="#dd0000"><strong>9.0</strong></font>上，就会出现<code>Permission Denial: startForeground requires android.permission.FOREGROUND_SERVICE</code>。</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2020/03/19/Android%E3%80%8E%E4%BF%9D%E6%B4%BB%E7%9B%B8%E5%85%B3%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E3%80%8E%E4%BF%9D%E6%B4%BB%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ck9kkco8a002v852626mbanva" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-项目架构——JetPack『Paging使用』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94JetPack%E3%80%8EPaging%E4%BD%BF%E7%94%A8%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.068Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94JetPack%E3%80%8EPaging%E4%BD%BF%E7%94%A8%E3%80%8F/">项目架构——JetPack『Paging使用』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文结合Paging和Room实现一个简单的Demo，演示这两个库的用法。</p>
<h3 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h3><p>Paging是Google推出的的JetPack框架中的一员，用于处理列表的分页加载。</p>
<p>Paging主要包含三部分，分别是DataSource、PageList、PageListAdapter。</p>
<h4 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h4><p>表示数据源，通常是这样的DataSource&lt;Key,Value&gt;，其中Key表示<strong>加载数据的条件信息</strong>，Value表示<strong>加载的数据实体</strong>。<font color="#dd0000"><strong>DataSource是一个抽象类</strong></font>，可以使用它的子类：</p>
<ul>
<li><code>PageKeyedDataSource&lt;Key, Value&gt;</code> ：适用于目标数据根据<strong>页信息</strong>请求数据的场景，即<code>Key</code> 字段是<strong>页相关的信息</strong>。比如请求的数据的参数中包含类似<code>next/previous</code>页数的信息。</li>
<li><code>ItemKeyedDataSource&lt;Key, Value&gt;</code> ：适用于目标数据的<strong>加载依赖特定item</strong>的信息， 即Key字段包含的是Item中的信息，<strong>比如需要根据第N项的信息加载第N+1项的数据，传参中需要传入第N项的ID时，该场景多出现于论坛类应用评论信息的请求</strong>。</li>
<li><code>PositionalDataSource&lt;T&gt;</code>：适用于目标数据总数固定，通过特定的位置加载数据，这里Key是Integer类型的位置信息，T即Value。 比如从数据库中的1200条开始加在20条数据。</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94JetPack%E3%80%8EPaging%E4%BD%BF%E7%94%A8%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94JetPack%E3%80%8EPaging%E4%BD%BF%E7%94%A8%E3%80%8F/" data-id="ck9kkco9v004s85269x4tedbv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JetPack/" rel="tag">JetPack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paging/" rel="tag">Paging</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JetPack/" rel="tag">JetPack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paging/" rel="tag">Paging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Room/" rel="tag">Room</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava2/" rel="tag">RxJava2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" rel="tag">开源项目学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JetPack/" style="font-size: 12.5px;">JetPack</a> <a href="/tags/Kotlin/" style="font-size: 12.5px;">Kotlin</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Paging/" style="font-size: 10px;">Paging</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Room/" style="font-size: 10px;">Room</a> <a href="/tags/RxJava2/" style="font-size: 12.5px;">RxJava2</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">开源项目学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">源码学习</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 10px;">组件化</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8E%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8F/">读书笔记『深入理解Java虚拟机』</a>
          </li>
        
          <li>
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ > </script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>