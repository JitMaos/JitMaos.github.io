<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android基础『V1V2V3签名』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" class="article-date">
  <time datetime="2020-04-10T07:24:34.404Z" itemprop="datePublished">2020-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>基础概念</p>
<p>签名：在 APK 中写入一个「指纹」。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。</p>
<p>摘要算法：<font color="#dd0000"><strong>使用一段简单的看上去随机的不可逆向的固定长度的字符串来表示一个文件的唯一性。</strong></font>常见的摘要算法如MD5(128个比特位)、SHA-1算法(160/192/256个比特位)。</p>
<p>公钥密码体制：也称非对称算法，特点是<strong>公钥是公开的</strong>，私钥是保密的。常见的如：RSA。</p>
<p>展开讨论一下RSA：</p>
<ol>
<li>加密：公钥加密，私钥解密的过程，称为「加密」。</li>
<li><strong>签名：私钥加密，公钥解密的过程，称为「签名」。</strong>加签用来证明这段密文是有公钥对应的私钥拥有者发出的。</li>
</ol>
<p>网络传输一般不会对整个文件进行签名，因为非对称加密效率比较低。所以一般使用<font color="#dd0000"><strong>摘要算法+RSA算法</strong></font>实现，传输使用RSA的私钥对文件的摘要信息进行加密作为摘要；接受者接收到文件后，对文件使用相同的摘要算法对文件求摘要值，然后再使用公钥解密加密过得摘要，比较两个摘要值判断文件是否合法。</p>
<p>数字证书：尽管使用RSA +摘要算法可以实现文件的可靠性检测。但是仍然存在问题，<font color="#dd0000"><strong>问题在于公钥是公开的，</strong></font>比如某些钓鱼网站，直接下发一个他自己的公钥，那么用户就算验证了文件的合法性。依然会进圈套，因为用户不知道和他交互的是否是正确的对象。</p>
<p>所以需要一个权威的CA机构，用来<font color="#dd0000"><strong>颁发数字证书，用以认证用户手上公开的公钥</strong></font>，这些权威的CA机构将他们的证书先预置在机器里，然后使用他们的私钥对申请数字证书的公钥以及其他信息(有效期、签名算法、数字签名blalala)进行加密，从而得到一个数字证书。用来验证自己所访问的对象是否是正确的。</p>
<hr>
<p>Android中的签名方案</p>
<p><font color="#dd0000"><strong>V1</strong></font>：基于jarsigner(JDK自带工具，使用keystore文件进行签名) 或 apksigner(Android专门提供的，使用pk8、x509.pem进行签名)。keystore和pk8/x509.pem可以相互转换。</p>
<p>签名原理：首先keystore文件包含一个MD5和一个SHA1摘要。<strong>这也是很多开放平台需要我们上传的摘要数据</strong>。</p>
<p>签名APK后会在META-INF文件夹下生产CERT.RSA、CERT.SF、MANIFEST.MF三个文件。</p>
<p>在apk中，/META-INF文件夹中保存着apk的签名信息，一般至少包含三个文件，[CERT].RSA，[CERT].SF和MANIFEIST.MF文件。这三个文件就是对apk的签名信息。</p>
        
          <p class="article-more-link">
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/" data-id="ck91fgnl4003exa267nrv84e4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记『Java并发编程实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.097Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h3><p><strong>P1</strong>：在不同的<strong>进程</strong>之间可以通过一些<strong>粗粒度</strong>的通讯机制来完成交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。</p>
<p><strong>P7</strong>：安全性的含义是”永远不发生糟糕的事情”，而<strong>活跃性</strong>则关注于另一个目标，即<strong>某件正确的事情最终会发生</strong>。当某个操作无法继续执行下去时，就会发生活跃性问题。</p>
<p><strong>P8</strong>：在Servlet规范中，Servlet同样需要满足被多个线程同事调用，换句话说，<strong>Servlet需要是线程安全的。</strong></p>
<h3 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h3><p><strong>P11</strong>：要编写线程安全的代码，其核心在于<strong>要对状态访问操作进行管理</strong>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p>
<p><strong>P13</strong>：在线程安全性的定义中，最核心的概念就是<strong>正确性</strong>。正确性的含义是，<font color="#dd0000"><strong>某个类的行为与其规范完全一致</strong></font>。</p>
<p><strong>P15</strong>：当某个计算的正确性取决于多个线程<strong>交替执行时序</strong>时，那么久就会发生<font color="#dd0000"><strong>竞态条件</strong></font>。</p>
<p><strong>P16</strong>：竞态条件的本质——<strong>基于</strong>一种可能<font color="#dd0000"><strong>失效的观察结果</strong></font>来做出判断或者执行某个计算。</p>
<p><strong>P18</strong>：在java.util.concurrent.atomic包中包含了一些<strong>原子变量类</strong>，用于实现在<strong>数值</strong>和<font color="#dd0000"><strong>对象引用</strong></font>上的原子状态转换。如：<strong>AtomicLong</strong>，<strong>AtomicReference</strong>。</p>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ck91fgnm5004vxa26fug16vfy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目『腾讯MMKV存储框架』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.095Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MMKV的介绍"><a href="#MMKV的介绍" class="headerlink" title="MMKV的介绍"></a>MMKV的介绍</h2><p>MMKV 是基于 <font color="#dd0000"><strong>mmap 内存映射</strong></font>的 key-value 组件，<strong>底层序列化/反序列化使用 protobuf 实现</strong>，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>高性能 实时写入</strong></li>
<li><strong>稳定 防crash</strong></li>
<li><strong>多进程访问</strong><br> 通过与 Android 开发同学的沟通，了解到系统自带的 SharedPreferences 对多进程的支持不好。<br> 现有基于 ContentProvider 封装的实现，虽然多进程是支持了，但是性能低下，经常导致 ANR。<br> 考虑到 mmap 共享内存本质上的多进程共享的，我们在这个基础上，深入挖掘了 Android 系统的能力，提供了可能是业界最高效的多进程数据共享组件。</li>
<li><strong>匿名内存</strong><br> 在多进程共享的基础上，考虑到某些敏感数据(例如密码)需要进程间共享，但是不方便落地存储到文件上，直接用 mmap 不合适。<br> 我们了解到 Android 系统提供了 Ashmem 匿名共享内存的能力，发现它在进程退出后就会消失，不会落地到文件上，非常适合这个场景。<br> 我们很愉快地提供了 Ashmem MMKV 的功能。</li>
<li><strong>数据加密</strong><br> 不像 iOS 提供了硬件层级的加密机制，在 Android 环境里，数据加密是非常必须的。<br> MMKV 使用了 AES CFB-128 算法来加密/解密。我们选择 CFB 而不是常见的 CBC 算法，<br> 主要是因为 MMKV 使用 append-only 实现插入/更新操作，流式加密算法更加合适。</li>
<li><strong>数据有效性</strong></li>
</ul>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" data-id="ck91fgnlw004ixa268zfa3aw7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目——OkHttp『源码学习』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.091Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OKHttp是个优秀的开源项目，值得学习。但是代码量比EventBus、Retrofit之类的大多了。想要一下子没有遗漏的都搞清楚不是一件容易的事情。这篇博客，是我在学习过程中的一些问题，有些自觉找到了答案，有些还不知道如何回答，留待以后补充吧。</p>
<h2 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h2><ol>
<li><p>异步，同步队列共用线程池吗？共用请求数量限制(maxRequests和maxRequestsPerHost)吗？</p>
<p>答：<code>请求数量限制只对异步队列有效</code>，对于同步任务不做限制，只管添加执行就得了。</p>
</li>
<li><p>为什么不直接使用线程池，而是自己另外维护了工作队列？</p>
<p>答：首先这里使用了的线程池是基于同步队列的，而同步队列本身是不支持工作队列的，所以需要一个额外的工作队列来维护任务的提交工作。</p>
</li>
<li><p>为什么OkHttp的异步任务选择使用两个队列维护？而不是使用一个工作队列实现？</p>
<p>答：说下我自己的看法，首先为什么需要两个队列，因为在提交异步任务是需要统计当前的运行中的任务数量，使用一个队列的话，还需要遍历队列中的任务状态，而将等待运行和运行中分离开来可以避免这种困扰，减少问题发生的可能性。</p>
</li>
<li><p>等待队列中的任务何时触发运行？</p>
<p>答：不管是异步任务还是同步任务，任务的执行代码都包含在一个try…catch代码块中，该代码块的finally中执行dispatcher.finished(this)，在finished()方法中首先会从异步运行中队列中移除代表当前任务的Call对象，然后会去异步等待就绪队列中拿任务放到异步运行中队列中，并执行任务。看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.finished()</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//首先从运行队列中移除当前已完成的Call对象</span></span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      <span class="comment">//这个promoteCalls()方法中，会从异步就绪等待队列中拿取任务放到异步运行队列并执行</span></span><br><span class="line">      <span class="keyword">if</span> (promoteCalls) promoteCalls(); </span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有任务在运行时，触发回调，暂时不知道使用场景</span></span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下调度等待就绪任务的promoteCalls()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.promoteCalls()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//从当前等待就绪队列中移除当前Call对象</span></span><br><span class="line">        i.remove();</span><br><span class="line">        <span class="comment">//添加Call到运行队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果okhttpclient不作为单例使用，那么线程池是否就有多个了，Dispatcher呢？</p>
<p><strong>答</strong>：每个OkHttpClient对象实例对应一个Dispatcher，因此也就意味着多个OkHttpClient对应着多个线程池。</p>
</li>
<li><p>RetryAndFollowUpInterceptor中的重试指的是什么？是重试连接还是跳转？还是包含了这两个动作：重连次数和跳转数限制？</p>
<p><strong>答</strong>：</p>
</li>
<li><p>缓存需要手动指定才能生效吗？缓存机制是什么？</p>
</li>
<li><p>DiskLruCache算法的具体细节是什么？缓存清理线程的工作原理是什么？</p>
</li>
<li><p>为什么要把AsyncCall定义成RealCall的内部类？有什么好处吗？</p>
</li>
<li><p>为什么缓存管理需要另外一个日志文件？</p>
</li>
<li><p>为什么DiskLruCache的内部类Entry需要一个cleanFiles文件数组和一个dirtyFiles文件数组？</p>
</li>
</ol>
        
          <p class="article-more-link">
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" data-id="ck91fgnn4005txa26f3m93t0j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java进阶『Javassist学习笔记』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.088Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.javassist.org/" target="_blank" rel="noopener">http://www.javassist.org/</a></p>
<h3 id="文档翻译"><a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h3><ol>
<li><p>读取和写入字节码</p>
<p>Javassist是一个用于处理Java字节码的类库。Java字节码被存储在class文件中，每个class文件包含一个Java类或者接口。</p>
<p>Javassist.CtClass是一个class文件的抽象代表。一个CtClass对象可以(在编译期)用来处理一个class文件。以下面代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段代码首先获得一个ClassPool对象，ClassPool是CtClass所代表的class文件的容器。ClassPool会在构造CtClass对象时去读取class文件，并且持有构造好的CtClass对象以便之后使用。想要修改一个class，首先需要通过ClassPool获取到一个CtClass对象。ClassPool对象的get()方法可以用来实现这个目的。</p>
<p>从实现细节来说，ClassPool是一个以class的名字为key用来存储CtClass对象的哈希表，get()会从哈希表中根据传入的key查找CtClass对象。如果未能查找到缓存对象，get()方法会创建一个新的CtClass对象，并将这个新建的对象保存到哈希表中，然后返回给调用方。</p>
<p>从ClassPool中获取到的CtClass对象可以被修改，在上面的代码中，cc的superclass被修改成了test.Point。</p>
<p>writeFile()实现了从CtClass对象到class文件的转换，并将他写入到了本地磁盘。Javassist也提供了一种直接获取修改过的二进制代码的方法toBytecode()。除此之外，还可以直接载入CtClass：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clzzz = cc.toClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个新的class</p>
<p>可以使用makeClass创建一个新的class，之后可以使用CtNewMethod类中的方法创建方法，然后通过addMethod添加到创建的class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Point"</span>);</span><br></pre></td></tr></table></figure>

<p>要创建接口，需要使用makeInterface()</p>
</li>
<li><p>冻结的class</p>
<p>如果一个CtClass对象已经通过writeFile()，toClass()，或toBytecode()转换成一个class文件，那么Javassist会冻结Ctclass对象，不允许对Ctclass对象进行修改。这是为了提示开发者在JVM已经加载class文件后不能修改class文件。<strong>一个冰冻了的Ctclass可以通过defrost()方法解冻的方式来使能编辑。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;</span><br><span class="line">    :</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.defrost();</span><br><span class="line">cc.setSuperclass(...);    <span class="comment">// OK since the class is not frozen.</span></span><br></pre></td></tr></table></figure>

<p>如果ClassPool.doPruning被设置为true，那么Javassist会在冻结对象是进行CtClass对象的剪裁，以减少内存开销。想要禁用剪裁，需要调用stopPruning()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;</span><br><span class="line">cc.stopPruning(<span class="keyword">true</span>);</span><br><span class="line">    :</span><br><span class="line">cc.writeFile();                             <span class="comment">// convert to a class file.</span></span><br><span class="line"><span class="comment">// cc is not pruned.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类搜索路径</p>
<p>默认ClassPool.getDefault()从JVM的相同环境变量搜索类。但是如果程序运行在服务端，那么ClassPool对象就无法在用户的类搜索路径上找到目标类，此时可以通过insertClassPatch来增加类搜索路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>搜索路径不仅可以是本地路径，还可以是线上的路径</strong>，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure>

<p>除此之外，还可以直接传入byte数据来构造CtClass对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] b = a <span class="keyword">byte</span> array;</span><br><span class="line">String name = <span class="class"><span class="keyword">class</span> <span class="title">name</span></span>;</span><br><span class="line">cp.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, b));</span><br><span class="line">CtClass cc = cp.get(name);</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ol>
<li>如果想在运行期编辑类，给类添加方法，只能新增一个新的类。<strong>因为一个ClassLoader不能加载同一个类两次</strong>。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" data-id="ck91fgnl7003jxa260wjwe6fs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『线程相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.087Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/">Java『线程相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Java『线程相关』### Java线程<br><strong>线程是进程中实施调度和分派的基本单位</strong>。一个进程可以包含多个线程，一个线程只能在一个进程的地址空间内活动。</p>
<h5 id="一、线程状态"><a href="#一、线程状态" class="headerlink" title="一、线程状态"></a>一、线程状态</h5><p>​    线程有6种状态，new，runnable，blocked，waiting(等待其他线程执行结束)，timed_waiting(等待其他线程结束，设定超时)，terminated(Thread类中一个State枚举了线程的所有状态）。</p>
<h5 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h5><ol>
<li>使用synchronized关键字修饰方法。由于java的<font color="#dd0000"><strong>每个对象都有一个内置锁</strong></font>，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。注： synchronized关键字也可以<font color="#dd0000"><strong>修饰静态方法</strong></font>，此时如果调用该静态方法，将会<font color="#dd0000"><strong>锁住整个类</strong></font>。</li>
<li>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ck91fgnl8003lxa26h4xgapct" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『Javap命令』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.086Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/">Java『Javap命令』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看JVM的运行时数据区，包括：虚拟机栈、程序计数器、本地方法栈、方法区和堆；其中虚拟机栈中存储的是栈帧，而栈帧是由<font color="#dd0000"><strong>局部变量表、操作数栈</strong></font>、动态链接、方法出口等组成。今天学习一下Javap命令，通过对字节码进行反编译来查看局部变量表的细节。</p>
<p>javap -v cclassName，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。<br>javap -l className，会输出行号和本地变量表信息。<br>javap -c className，会对当前class字节码进行反编译生成汇编代码。</p>
<ol>
<li>新建TreeNode.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用javac编译生成class文件</li>
<li>输入命令：javap -v TreeNode.class</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Classfile TreeNode<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-2-3</span>; size <span class="number">370</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">6</span>db15fb197ff5952f8b106978416b74a</span><br><span class="line">  Compiled from <span class="string">"TreeNode.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">leon</span>.<span class="title">LeetCode</span>.<span class="title">TreeNode</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#19         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#20         // com/leon/LeetCode/TreeNode.val:I</span><br><span class="line">   #3 = Class              #21            // com/leon/LeetCode/TreeNode</span><br><span class="line">   #4 = Class              #22            // java/lang/Object</span><br><span class="line">   #5 = Utf8               val</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               left</span><br><span class="line">   #8 = Utf8               Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">   #9 = Utf8               right</span><br><span class="line">  #10 = Utf8               &lt;init&gt;</span><br><span class="line">  #11 = Utf8               (I)V</span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line">  #13 = Utf8               LineNumberTable</span><br><span class="line">  #14 = Utf8               LocalVariableTable</span><br><span class="line">  #15 = Utf8               this</span><br><span class="line">  #16 = Utf8               x</span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line">  #18 = Utf8               TreeNode.java</span><br><span class="line">  #19 = NameAndType        #10:#23        // "&lt;init&gt;":()V</span><br><span class="line">  #20 = NameAndType        #5:#6          // val:I</span><br><span class="line">  #21 = Utf8               com/leon/LeetCode/TreeNode</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               ()V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode left;</span><br><span class="line">    descriptor: Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode right;</span><br><span class="line">    descriptor: Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode(<span class="keyword">int</span>);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         6: putfield      #2                  // Field val:I</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">1</span>     x   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>常见的字节码命令</p>
<table>
<thead>
<tr>
<th>Bytecode</th>
<th>Stackbefore-&gt;after</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>iconst_0</td>
<td>-&gt;0</td>
<td>Loads the int value 0 onto the stack //从栈中读取变量</td>
</tr>
<tr>
<td>istore_1</td>
<td>value-&gt;</td>
<td>Store int value into variable 1 //将变量压入栈</td>
</tr>
<tr>
<td>istore_2</td>
<td>value-&gt;</td>
<td>Store int value into variable 2 //将变量压入栈</td>
</tr>
<tr>
<td>iinc</td>
<td>No change</td>
<td>Increment local variable #index by signed byte const</td>
</tr>
<tr>
<td>iload_1</td>
<td>-&gt;value</td>
<td>Loads an int value from variable 1 //加载变量的值</td>
</tr>
<tr>
<td>iadd</td>
<td>value 1,value 2-&gt;result</td>
<td>Adds 2 ints together //将两个变量相加</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/" data-id="ck91fgnl1003bxa26bvs679zx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android项目『APPFrame』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E9%A1%B9%E7%9B%AE%E3%80%8EAPPFrame%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.081Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E9%A1%B9%E7%9B%AE%E3%80%8EAPPFrame%E3%80%8F/">Android项目『APPFrame』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GreenDao使用记录"><a href="#GreenDao使用记录" class="headerlink" title="GreenDao使用记录"></a>GreenDao使用记录</h3><p>一、3.2.2上目前只支持使用java类生成dao，不支持kotlin</p>
<p>二、报错：Caused by: org.greenrobot.greendao.DaoException: Could not init DAOConfig</p>
<p>解决：添加混淆规则：</p>
<p>-keep class org.greenrobot.greendao.<em>*{</em>;}<br>-keepclassmembers class * extends org.greenrobot.greendao.AbstractDao {<br>public static java.lang.String TABLENAME;<br>}<br>-keep class **$Properties<br>三、</p>
<h3 id="使用TitleBar"><a href="#使用TitleBar" class="headerlink" title="使用TitleBar"></a>使用TitleBar</h3><p>一、修改Activity的theme为NoActionBar</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"NoActionBar"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>二、添加menu.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar_viewmode"</span></span><br><span class="line">        android:title=<span class="string">"练习"</span></span><br><span class="line">        app:showAsAction=<span class="string">"always"</span>/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar_quickclassify"</span></span><br><span class="line">        android:title=<span class="string">"分类"</span></span><br><span class="line">        app:showAsAction=<span class="string">"always"</span>/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar_sort"</span></span><br><span class="line">        android:title=<span class="string">"排序"</span></span><br><span class="line">        app:showAsAction=<span class="string">"always"</span>/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>



<p>三、添加布局元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"?attr/actionBarSize"</span></span><br><span class="line">        android:background=<span class="string">"?attr/colorPrimary"</span></span><br><span class="line">        android:theme=<span class="string">"@style/ThemeOverlay.AppCompat.ActionBar"</span></span><br><span class="line">        app:popupTheme=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span></span><br><span class="line">        android:elevation=<span class="string">"4dp"</span></span><br><span class="line">        android:layout_marginTop=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_marginStart=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_marginEnd=<span class="string">"0dp"</span></span><br><span class="line">        app:menu=<span class="string">"@menu/base_main_activity_actions"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure>

<p>四、设置supportActionBar和listener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setSupportActionBar(toolbar)</span><br><span class="line">toolbar.setNavigationOnClickListener(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>五、重写onOptionsItemSelected和onCreateOptionsMenu</p>
<h3 id="命令行查看数据库"><a href="#命令行查看数据库" class="headerlink" title="命令行查看数据库"></a>命令行查看数据库</h3><ol>
<li>选择一个root过的手机，或者新建一个root过得模拟器，具体可以看命令行操作用户结尾的是#(已root)，还是$(未root)，或者提示pemisssion denied。</li>
<li>cd到databases文件目录。</li>
<li>使用adb shell命令，进入shell模式。</li>
<li>使用sqlite3命令选择数据库文件，如sqlite3 DBNAME.db。</li>
<li>使用.table查看当前选中数据库包含的数据表。</li>
<li>查看具体数据表的结构：.schema tableName</li>
<li>退出shell，.exit。</li>
</ol>
<h2 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h2><h3 id="体验优化"><a href="#体验优化" class="headerlink" title="体验优化"></a>体验优化</h3><ul>
<li><p>初始化数据库时，显示加载百分比进度条，暂定计算方式有两种</p>
<ul>
<li>当前处理行数 / 总行数</li>
<li>下载文件时，已经知道了要处理的单词数量。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E9%A1%B9%E7%9B%AE%E3%80%8EAPPFrame%E3%80%8F/" data-id="ck91fgnkv0035xa26e1cedny2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android知识点『适配相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.080Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E3%80%8F/">Android『适配相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Android-ID"><a href="#Android-ID" class="headerlink" title="Android ID"></a>Android ID</h5><p>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String id = Settings.Secure.getString(mContext.getContentResolver(),</span><br><span class="line">                 Settings.Secure.ANDROID_ID);</span><br></pre></td></tr></table></figure>

<p>兼容问题：</p>
<p>In O, Android ID (Settings.Secure.ANDROID_ID or SSAID) has a different value for each app and each user on the device. Developers requiring a device-scoped identifier, should instead use a resettable identifier, such as Advertising ID, giving users more control. Advertising ID also provides a user-facing setting to limit ad tracking</p>
<p>Additionally in Android O:</p>
<ul>
<li>The ANDROID_ID value won’t change on package uninstall/reinstall, as long as the package name and signing key are the same. Apps can rely on this value to maintain state across reinstalls.</li>
<li>If an app was installed on a device running an earlier version of Android, the Android ID remains the same when the device is updated to Android O,<font color="#dd0000"><strong>unless the app is uninstalled and reinstalled.</strong></font> </li>
<li>The Android ID value only changes if the device is factory reset or if the signing key rotates between uninstall and reinstall events.</li>
<li>This change is only required for device manufacturers shipping with Google Play services and Advertising ID. <font color="#dd0000"><strong>Other device manufacturers may provide an alternative resettable ID or continue to provide ANDROID ID.</strong></font></li>
</ul>
<h5 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h5><h5 id="动态权限"><a href="#动态权限" class="headerlink" title="动态权限"></a>动态权限</h5><h5 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h5><h5 id="定位权限"><a href="#定位权限" class="headerlink" title="定位权限"></a>定位权限</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ck91fgnl00038xa263x3y9n3o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android学习『跨进程通信』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E5%AD%A6%E4%B9%A0%E3%80%8E%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.079Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E5%AD%A6%E4%B9%A0%E3%80%8E%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%8F/">Android学习『跨进程通信』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、内核态和用户态"><a href="#一、内核态和用户态" class="headerlink" title="一、内核态和用户态"></a>一、内核态和用户态</h3><h4 id="1、内核态和用户态的简介"><a href="#1、内核态和用户态的简介" class="headerlink" title="1、内核态和用户态的简介"></a>1、内核态和用户态的简介</h4><blockquote>
<ul>
<li><strong>内核态</strong>：CPU可以访问内存所有数据，包括外围设备，例如硬盘、网卡，CPU可以将自己从一个程序切换到另外一个程序。</li>
<li><strong>用户态</strong>:   <font color="#dd0000"><strong>只能受限的访问内存，且不允许访问外围设备，占用CPU的能力被剥削，CPU资源可以被其他程序获取</strong></font>。</li>
</ul>
</blockquote>
<h4 id="2、为什么要有用户态和内核态"><a href="#2、为什么要有用户态和内核态" class="headerlink" title="2、为什么要有用户态和内核态"></a>2、为什么要有用户态和内核态</h4><blockquote>
<p>由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送网络，CPU划分出两个权限等级  —-用户态  和  内核态。</p>
</blockquote>
<h4 id="3、用户态与内核态的切换"><a href="#3、用户态与内核态的切换" class="headerlink" title="3、用户态与内核态的切换"></a>3、用户态与内核态的切换</h4><h5 id="3-1-切换简介"><a href="#3-1-切换简介" class="headerlink" title="3.1 切换简介"></a>3.1 切换简介</h5><p>所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情，例如从硬盘读取数据，或者从键盘获取输入等。而唯一可以这这些事情的就是 <strong>操作系统</strong> ，所以这时候 <strong>程序</strong> 就需要先向 <strong>操作系统</strong> 请求，以 <strong>程序</strong> 的名字来执行这些操作。这时候就需要一个这样的机制：用户态 切换到 内核态，但是不能控制内核态中执行的执行这种机制叫做** 系统调用 **，在CPU中的实现称之为 “陷阱指令(Trap Instruction)”</p>
<h5 id="3-2-系统调用机制流程："><a href="#3-2-系统调用机制流程：" class="headerlink" title="3.2 系统调用机制流程："></a>3.2 系统调用机制流程：</h5><blockquote>
<ul>
<li>1、用户态程序将一些数据值放在寄存器中，或者使用参数创建一个堆栈(stack frame)，以表明需要操作系统提供的服务。</li>
<li>2、用户态程序执行陷阱指令</li>
<li>3、CUP切换到内核态，并跳到内存指定位置的指令，这些指令是操作系统的一部分，他们具有内存保护，不可被用户态程序访问</li>
<li>4、这些指令称之为 陷阱 (trap) 或者新系统调用处理器 ( system call hanlder )。他们会读取程序放入内存的数据参数，并执行程序请求的服务。</li>
<li>5、系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。</li>
</ul>
</blockquote>
<h3 id="二、红黑树"><a href="#二、红黑树" class="headerlink" title="二、红黑树"></a>二、红黑树</h3><p>红黑树，顾名思义，红黑树的节点是有颜色概念的，即非红即黑，通过颜色的语速，红黑树为支持着二叉搜索树的平衡性。一个红黑树必须有下面5个特征</p>
<blockquote>
<ul>
<li>1、节点是红色或黑色</li>
<li>2、根是黑色</li>
<li>3、所有叶子是黑色(叶子是NIL节点)</li>
<li>4、每个红色节点的两个子节点都是黑色的(从每个叶子到跟的所有路径不能有两个连续的红色节点)</li>
<li>5、从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
</blockquote>
<p>这些特征强制约束了红黑树的关键性质：从跟到叶子的最长可能路径不多于最短可能路径的两倍长(特征4保证了路径最长的情况为1红1黑，最短的情况为全黑，再结合特征5，可以推导出)。<strong>结果是这个树大致上是平衡的</strong>。因为比如插入、删除和查找操作中，操作某个值的最坏情况的时间都要求与树的高度成比例，<font color="#dd0000"><strong>这个高度上的理论上限允许红黑树在最坏的情况都是高效的，而不同于普通的(二叉搜索树)</strong></font></p>
<h3 id="三、Linux的跨进程通信-IPC-概述"><a href="#三、Linux的跨进程通信-IPC-概述" class="headerlink" title="三、Linux的跨进程通信(IPC)概述"></a>三、Linux的跨进程通信(IPC)概述</h3><h4 id="1-跨进程通信-IPC-的目的"><a href="#1-跨进程通信-IPC-的目的" class="headerlink" title="1.跨进程通信(IPC)的目的"></a>1.跨进程通信(IPC)的目的</h4><p>跨进程通信(IPC)的目的主要如下：</p>
<blockquote>
<ul>
<li>数据传递<br> 一个进程需要将它的数据发送给另外一个进程，发送的数据量在一个字节到几M字节之间</li>
<li>共享数据<br> 多个进程想要操作共享数据。</li>
<li>通知事件<br> 一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)</li>
<li>资源共享<br> 多个进程之间共享资源。为了做到这一点，需要内核提供锁和同步机制</li>
<li>进程控制<br> 有些进程希望完全控制另一个进程的执行(如debug进程)，此时控制进程希望能够拦截另一个进程的所有步骤和异常，并能够及时知道它的状态改变。</li>
</ul>
</blockquote>
<h4 id="2-Linux-进程间通信-IPC-的发展"><a href="#2-Linux-进程间通信-IPC-的发展" class="headerlink" title="2.Linux 进程间通信(IPC)的发展"></a>2.Linux 进程间通信(IPC)的发展</h4><p>Linux中的进程间通信大体分为4类</p>
<blockquote>
<ul>
<li>基于早期Unix的进程间通信：管道和信号</li>
<li>基于System V的进程间通信：System V消息队列、System V 信号灯、System V 共享内存</li>
<li>基于Socket 的进程间通信：socket</li>
<li>POSIX进程间通信：posix 消息队列、posix信号灯、posix共享内存</li>
</ul>
</blockquote>
<h3 id="三、Android中进程通信的限制"><a href="#三、Android中进程通信的限制" class="headerlink" title="三、Android中进程通信的限制"></a>三、Android中进程通信的限制</h3><h4 id="1-静态成员和单利模式完全失效"><a href="#1-静态成员和单利模式完全失效" class="headerlink" title="1. 静态成员和单利模式完全失效"></a>1. 静态成员和单利模式完全失效</h4><p>Android系统为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配了一个独立的虚拟机，不同的虚拟机在内存上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类对象会产生多分副本</p>
<h4 id="2-线程同步机制完全失效"><a href="#2-线程同步机制完全失效" class="headerlink" title="2. 线程同步机制完全失效"></a>2. 线程同步机制完全失效</h4><h4 id="3-SharedPreferences的可靠性下降"><a href="#3-SharedPreferences的可靠性下降" class="headerlink" title="3. SharedPreferences的可靠性下降"></a>3. SharedPreferences的可靠性下降</h4><p>因为SharePreference不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，这是因为SharedPreferences底层是通过读/写XML文件来实现的，并发写显然会出问题的，甚至并发读/写都有可能出问题。</p>
<h4 id="4-Application会多次创建"><a href="#4-Application会多次创建" class="headerlink" title="4. Application会多次创建"></a>4. Application会多次创建</h4><p>当一个组件跑在一个新的进程中，由于系统要再创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程。因此，相当于系统又把这个应用重新启动了一遍，既然重新启动了，那么自认会创建新的Applicatiaon。</p>
<h3 id="四、Serializable和Parcelable接口"><a href="#四、Serializable和Parcelable接口" class="headerlink" title="四、Serializable和Parcelable接口"></a>四、Serializable和Parcelable接口</h3><h4 id="1-Serializable接口"><a href="#1-Serializable接口" class="headerlink" title="1. Serializable接口"></a>1. Serializable接口</h4><h5 id="1-1-Serializable简介"><a href="#1-1-Serializable简介" class="headerlink" title="1.1 Serializable简介"></a>1.1 Serializable简介</h5><p>Serializable 是<font color="#dd0000"><strong>Java</strong></font>所提供的一个序列化接口，它是一个<font color="#dd0000"><strong>空接口</strong></font>，为对象提供标准的序列化和反序列化操作。</p>
<h5 id="1-2-SerialVersionUID的作用"><a href="#1-2-SerialVersionUID的作用" class="headerlink" title="1.2 SerialVersionUID的作用"></a>1.2 SerialVersionUID的作用</h5><blockquote>
<ul>
<li>这个serialVersionUID是用来辅助序列化和反序列化的过程。原则上序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID一致才能成功的反序列化。</li>
<li>serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中(也可能是其他中介)，当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能会发生变化，这时候就无法正常的反序列化。会报如下错误:</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.io</span><span class="selector-class">.InvalidClassException</span></span><br></pre></td></tr></table></figure>

<h6 id="所以当我们手动制订了它之后，就可以很大程度上避免了泛学历化过程的失败。"><a href="#所以当我们手动制订了它之后，就可以很大程度上避免了泛学历化过程的失败。" class="headerlink" title="所以当我们手动制订了它之后，就可以很大程度上避免了泛学历化过程的失败。"></a>所以当我们手动制订了它之后，就可以很大程度上避免了泛学历化过程的失败。</h6><p>1、静态成员变量属于类，不属于对象，所以不会参与序列化的过程</p>
<p>2、用transient关键字编辑的成员变量不参与序列化的过程。</p>
<p>3、可以通过重写writeObject()和readObject()两个方法来重写系统默认的序列化和反序列化的过程。不过本人并不推荐</p>
<h4 id="2-Parcelable接口"><a href="#2-Parcelable接口" class="headerlink" title="2. Parcelable接口"></a>2. Parcelable接口</h4><p>Parcelable也是一个接口，只要实现了这个接口，一个类的对象就可以实现序列化和并且通过Intent和Binder传递。</p>
<p>参考：<a href="https://www.jianshu.com/p/36b488863bc0" target="_blank" rel="noopener">隔壁老李头的跨进程通信IPC系列</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E5%AD%A6%E4%B9%A0%E3%80%8E%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E3%80%8F/" data-id="ck91fgnkt0032xa26ca83evez" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AnnotationProcessor/" rel="tag">AnnotationProcessor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JetPack/" rel="tag">JetPack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/" rel="tag">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paging/" rel="tag">Paging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Room/" rel="tag">Room</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava2/" rel="tag">RxJava2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" rel="tag">开源项目学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/AnnotationProcessor/" style="font-size: 10px;">AnnotationProcessor</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/JetPack/" style="font-size: 15px;">JetPack</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Paging/" style="font-size: 10px;">Paging</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Room/" style="font-size: 10px;">Room</a> <a href="/tags/RxJava2/" style="font-size: 15px;">RxJava2</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">开源项目学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">源码学习</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 10px;">组件化</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/10/Android%E5%9F%BA%E7%A1%80%E3%80%8EV1V2V3%E7%AD%BE%E5%90%8D%E3%80%8F/">Android基础『V1V2V3签名』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ > </script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>