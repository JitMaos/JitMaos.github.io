<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-读书笔记『Java并发编程实战』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.097Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h3><p><strong>P1</strong>：在不同的<strong>进程</strong>之间可以通过一些<strong>粗粒度</strong>的通讯机制来完成交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。</p>
<p><strong>P7</strong>：安全性的含义是”永远不发生糟糕的事情”，而<strong>活跃性</strong>则关注于另一个目标，即<strong>某件正确的事情最终会发生</strong>。当某个操作无法继续执行下去时，就会发生活跃性问题。</p>
<p><strong>P8</strong>：在Servlet规范中，Servlet同样需要满足被多个线程同事调用，换句话说，<strong>Servlet需要是线程安全的。</strong></p>
<h3 id="第二章-线程安全性"><a href="#第二章-线程安全性" class="headerlink" title="第二章 线程安全性"></a>第二章 线程安全性</h3><p><strong>P11</strong>：要编写线程安全的代码，其核心在于<strong>要对状态访问操作进行管理</strong>，特别是对<strong>共享的</strong>和<strong>可变的</strong>状态的访问。</p>
<p><strong>P13</strong>：在线程安全性的定义中，最核心的概念就是<strong>正确性</strong>。正确性的含义是，<font color="#dd0000"><strong>某个类的行为与其规范完全一致</strong></font>。</p>
<p><strong>P15</strong>：当某个计算的正确性取决于多个线程<strong>交替执行时序</strong>时，那么久就会发生<font color="#dd0000"><strong>竞态条件</strong></font>。</p>
<p><strong>P16</strong>：竞态条件的本质——<strong>基于</strong>一种可能<font color="#dd0000"><strong>失效的观察结果</strong></font>来做出判断或者执行某个计算。</p>
<p><strong>P18</strong>：在java.util.concurrent.atomic包中包含了一些<strong>原子变量类</strong>，用于实现在<strong>数值</strong>和<font color="#dd0000"><strong>对象引用</strong></font>上的原子状态转换。如：<strong>AtomicLong</strong>，<strong>AtomicReference</strong>。</p>
<p><strong>P19</strong>：AtomicLong是一种替代long类型整形的线程安全类，类似地，AtomicReference是一种替代<strong>对象引用</strong>的线程安全类。<font color="#00dd6d">测试代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAtomicClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger safeNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableMinus()).start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnalbeAdd()).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnalbeAdd</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"n+:"</span> + num++);</span><br><span class="line"><span class="comment">//                System.out.println("n+:" + safeNum.incrementAndGet()); //线程安全操作</span></span><br><span class="line">                times -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableMinus</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"n-:"</span> + num--);</span><br><span class="line"><span class="comment">//                System.out.println("n-:" + safeNum.decrementAndGet()); //线程安全操作</span></span><br><span class="line">                times --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P20</strong>：Java 提供了一种<strong>内置</strong>的锁机制来支持原子性：<font color="#dd0000"><strong>同步代码块</strong></font>。同步代码块包括两部分：一个作为锁的<strong>对象引用</strong>，一个作为由这个锁保护的<strong>代码块</strong>。每个Java对象都可以用做一个实现同步的锁，这些锁被称为<font color="#dd0000"><strong>内置锁</strong></font>或<font color="#dd0000"><strong>监视器锁</strong></font>。<strong>线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。</strong></p>
<p><strong>P21</strong>：<strong>重入</strong>意味着获取锁的操作的粒度是<strong>线程</strong>，而不是<strong>调用</strong>。当线程请求一个未被持有的锁是，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器将会响应的递减。当计数器为0时，这个锁将被释放。<font color="#dd0000"><strong>注意：这里的重入指的是一个同步代码块中可以调用另一个同步代码块。而不是反复进入一个方法。</strong></font><font color="#00dd6d">测试代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试重入机制，如果无法重入，那么同一个锁下不同的同步代码之间的相互调用将发生死锁</span></span><br><span class="line"><span class="comment"> * Created by wanly on 2019-08-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestReEnter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TestReEnter testReEnter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testReEnter = <span class="keyword">new</span> TestReEnter();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                testReEnter.doSomething1(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">(<span class="keyword">long</span> sleepTime)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"|"</span> + <span class="string">"doSomething1.start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        doSomething2();</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"|"</span> + <span class="string">"doSomething1.start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"|"</span> + <span class="string">"doSomething2.start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"|"</span> + <span class="string">"doSomething2.end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>：Java中每一个对象都可以作为锁，Synchronized主要有三种使用方法：</p>
<ul>
<li>普通同步方法（实例方法），锁是<strong>当前实例对象</strong> ，进入同步代码前要获得当前实例的锁</li>
<li>静态同步方法，锁是当前<strong>类的class对象</strong> ，进入同步代码前要获得当前类对象的锁</li>
<li>同步方法块，锁是<strong>括号里面的对象</strong>，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<h3 id="第三章-对象的共享"><a href="#第三章-对象的共享" class="headerlink" title="第三章 对象的共享"></a>第三章 对象的共享</h3><p><strong>P27</strong>：<font color="#dd0000"><strong>内存可见性</strong></font>：我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，<strong>而且希望确保当前一个线程修改对象状态后，其他线程能够看到发生的状态变化。</strong></p>
<p><strong>扩展</strong>：我们知道一般计算机CPU有会有几级缓存，而主存的存储空间往往是有限的，所以线程在工作时，会将他需要用到的数据对象放到自己的工作内存中进行读写。这样多线程情况下，每个线程都有自己的工作内存，从而导致<strong>可见性问题</strong>，即线程A在他的工作内存在修改了变量m的值，线程B在他的工作内存中无法<strong>及时</strong>知道m的改变。</p>
<p><strong>P28</strong>：<font color="#dd0000"><strong>重排序</strong></font>：在没有同步的情况下，编译器、处理器以及运行时等都有可能对操作的执行顺序进行一些意想不到的调整。</p>
<p><strong>P29</strong>：Java内存模型要求，变量的读取操作和写入操作都必须是原子操作。但对于<strong>非volatile类型的long和double</strong>变量，JVM允许将64位的读操作和写操作分解为2个32位的操作。</p>
<p><strong>P31</strong>：当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此<font color="#dd0000"><strong>不会将该变量上的操作与其他内存操作一起重排序</strong></font>。volatile变量<font color="#dd0000"><strong>不会被缓存在寄存器或者对其他处理器不可见的地方</strong></font>，因此读取volatile类型的变量时总会返回最新写入的值。</p>
<p><strong>扩展</strong>：通常我们写单例模式时，有多种方式，比如：懒汉模式、饿汉模式、委托(静态私有内部类)、双重检测锁等。一般我们使用的最多的是双重检测锁来实现(<strong>虽然这本书说JDK 1.6以后双重检测并不是一种好方法</strong>)，anyway。这里讲一下双重检测和volatile的关系。<font color="#dd0000"><strong>那就是如果忘了使用volatile修饰单例对象，由于存在指令重排序的可能，仍然有可能造成错误。</strong></font></p>
<p><strong>P34</strong>：当对象在其构造函数中创建一个线程时，无论是显式创建(通过将它传给构造函数)还是隐身创建(由于Thread或Runnable是该对象的一个内部类)，<font color="#dd0000"><strong>this引用都会被新创建的线程共享</strong></font>。</p>
<p><strong>P35</strong>：一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据， 就不需要同步。这种技术被称为<strong>线程封闭(Thread Confinement)</strong>，它是实现线程安全性的最简单方式之一。<strong>栈封闭</strong>是一种特殊的线程封闭。</p>
<p><strong>P37</strong>：维持线程封闭性的一种更规范的方法是使用ThreadLocal，这个类<strong>能够使线程中的某个值于保存值的对象关联起来。</strong><font color="#dd0000"><strong>get总是返回由当前执行线程在调用set时设置的最新值</strong></font>。</p>
<p><strong>扩展</strong>：我们通常直接打交道的API是ThreadLocal，但实际上每个线程用于真正存储共享变量”副本”的是ThreadLocalMap，它是一个数组，其中的元素是Entry&lt;ThreadLocal，Value&gt;。</p>
<p><strong>P43</strong>：要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确的构造的对象可以通过以下方式来安全发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象的引用保存到volatile类型的域对象AtomicReference对象中。</li>
<li>将对象的引用保存到某个正确构造函数的final类型域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
<h3 id="第四章-对象的组合"><a href="#第四章-对象的组合" class="headerlink" title="第四章 对象的组合"></a>第四章 对象的组合</h3><p><strong>P49</strong>：实例封闭：如果某个对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用，你可以确保该对象只能有单个线程方案(线程封闭)，或者通过一个锁来保护该对象的所有访问。</p>
<p><strong>P59</strong>：在Java中有很多线程封闭的类库，其中有些类的唯一用途就是将非线程安全的类转换成线程安全的类，如：</p>
<p>Collections.synchronizedList(List<E> list)、Collections.synchronizedSet(Set<E> s)等。</p>
<p><strong>P61</strong>：非线程安全的<strong>putIfAbsent</strong>方法，<font color="#00dd6d">代码演示：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = !list.contains(x);</span><br><span class="line">        <span class="keyword">if</span>(absent) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然容器list是线程安全的，putIfAbsent也是同步的，但是<strong>putIfAbsent和list上的锁对象不是同一个锁对象</strong>。这意味着<font color="#dd0000"><strong>putIfAbsent相对于List的其他操作来说并不是原子的，因此就无法确保党putIfAbsent运行时另一个线程不会修改链表</strong></font>。</p>
<h3 id="第五章-基础构建模块"><a href="#第五章-基础构建模块" class="headerlink" title="第五章 基础构建模块"></a>第五章 基础构建模块</h3><p><strong>P68</strong>：设计同步容器类的<strong>迭代器</strong>时并没有考虑到<strong>并发修改</strong>的问题，<strong>并且他们表现出的行为是’及时失败(fail-fast)’的。</strong>这意味着，当他们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException异常。这是一种类似”善意地”捕获并发异常。<font color="#00dd6d">示例代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForConcurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="string">"AA"</span>);</span><br><span class="line">        <span class="comment">//尽管遍历的是线程安全类Vector，但仍然不能保证在迭代size()时是安全的(可能抛出数组边界越界异常)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vector.size();i++) &#123;</span><br><span class="line">            System.out.println(vector.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>P69</strong>：有些情况下，迭代器会隐藏起来。编译器将字符串的连接操作转换为调用StringBuilder.append(Object)，而这个方法<font color="#dd0000"><strong>又会调用容器的toString方法，标准容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示</strong></font>，<font color="#00dd6d">示例代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HideenIterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123;set.add(i);&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123;set.remove(i);&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">                add(r.nextInt());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里会迭代遍历set中的每一个元素，用来生成格式化内容</span></span><br><span class="line">            System.out.println(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>P70</strong>：<font color="#dd0000"><strong>容器</strong></font>的<strong>hashCode</strong>和<strong>equals</strong>等方法也会间接的执行迭代操作，<strong>当容器作为另一个容器的元素或健值时，就会出现这种情况</strong>。 同样，contiainsAll、removeAll和retainAll等方法，以及把同步容器作为参数的构造函数，都会对容器进行迭代。在Java 5.0中新增了ConcurrentHashMap用以替代同步且基于散列的Map，以及CopyOnWriteArrayList，用于在遍历操作为主要操作的情况下替代同步的List。</p>
<p><strong>P71</strong>：Java 5.0新增了Queue和BlockingQueue。Queue用来<strong>临时</strong>保存一组<strong>等待处理</strong>的元素。Queue上的操作不会阻塞，如果列表为空，那么获取元素的 操作将返回空值。<font color="#dd0000"><strong>事实上，Queue是通过LinkedList实现的，之所以还需要一个Queue，是因为它能去除List的随机访问需求从而实现更高效的并发。</strong></font>BlockingQueue扩展了Queue，增加了<font color="#dd0000"><strong>可阻塞</strong></font>的插入和获取等操作。</p>
<p><strong>P71</strong>：<strong>ConcurrentHashMap</strong>并不是将每个方法都在同一个锁上同步并使得每次只有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁(Lock Striping)。ConcurrentHashMap与其他并发容器提供的迭代器不会抛出ConcurentModificationException，因此不需要再迭代过程中对容器加锁。尽管有这些改进，但仍然有一些需要权衡的因素。<font color="#dd0000"><strong>对于一些需要在整个Map上进行的计算的方法，例如size和isEmpty，这些方法的语义被忽略减弱了以反映容器的并发特性。</strong></font>实际上它们只是一个<font color="#dd0000"><strong>估计值</strong></font>。</p>
<p><strong>CopyOnWriteArrayList</strong>：用于替代同步List，子某些情况下它提供更好的并发性能，并且在<strong>迭代期间</strong>不需要对容器进行加锁或复制。</p>
<p><strong>P73</strong>：<font color="#dd0000"><strong>写入时复制容器的线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再进一步的同步，在每次修改时，都会创建并更新发布一个新的容器副本，从而实现可变性。</strong></font>仅当<strong>迭代</strong>操作远远多于<strong>修改</strong>操作时，才应该使用<strong>写入时复制</strong>容器。这个准则很好地描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每一个监听器，在大多数情况下，注册和注销事件监听器的操作远小于接受事件通知的操作。</p>
<p>阻塞队列提供了<font color="#dd0000"><strong>可阻塞</strong></font>的put和take方法，以及支持<font color="#dd0000"><strong>定时</strong></font>的offer和poll方法。</p>
<p><strong>P74</strong>：在类库中包含了BlockingQueue的多种实现，其中LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，二者分别与LinkedList和ArrayList相似，但比同步List拥有更好的并发性能。</p>
<p>PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列将非常有用。</p>
<p>最后一个BlockingQueue实现是SynchronousQueue，<font color="#dd0000"><strong>实际上它并不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移除队列。</strong></font>这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。直接交付方式还会将更多关于任务状态的信息反馈给生产者(任务交付成功，或失败)。<strong>因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另外一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列</strong></p>
<p><strong>P77</strong>：Java6新增了两种容器类型，Deque(发音为”deck”)和BlockingDeque，他们分别对Queue和BlockingQueue进行了扩展。Deque是一个<font color="#dd0000"><strong>双端</strong></font>队列，<strong>实现了在队列头和队列尾的高效插入和移除。具体实现包括ArrayDeque和LinkedBlockingDeque。</strong>双端队列适用于<font color="#dd0000"><strong>工作密取(Work Stealing)</strong></font>，工作密取非常适用于<strong>既是生产者又是消费者问题——当执行某个工作时可能导致更多的工作。</strong><font color="#dd0000"><strong>例如：在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。</strong></font><br><strong>扩展</strong>：工作窃取(work-stealing)算法是<font color="#dd0000"><strong>指某个线程从其他队列里窃取任务来执行</strong></font>。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并未每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如线程1负责处理1队列里的任务，2线程负责2队列的。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们可能会访问同一个队列，所以为了<strong>减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务线程永远从双端队列的尾部拿任务执行。</strong></p>
<p>本节转自：[工作窃取算法 work-stealing](<a href="https://blog.csdn.net/pange1991/article/details/80944797" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/80944797</a>）</p>
<p><strong>P78</strong>：当某方法抛出InterruptedException时，表示该方法是一个<strong>阻塞方法</strong>，如果这个方法被中断，那么它将<font color="#dd0000"><strong>努力提前结束阻塞状态</strong></font>。Thread提供了interrupt方法，用于<strong>中断线程</strong>或者<strong>查询</strong>线程是否已经被中断。每个线程都有一个<strong>布尔类型的属性</strong>，表示线程的<strong>中断状态</strong>，当中断线程时将设置这个状态。</p>
<p>中断是一种<font color="#dd0000"><strong>协作机制</strong></font>。一个线程<strong>不能强制</strong>其他线程停止正在执行的操作而去执行其他操作。 当线程A中断B时，A<font color="#dd0000"><strong>仅仅是要求</strong></font>B在执行到某个可以暂停的地方停止正在执行的操作——前提是如果线程B愿意停下来。虽然在API或者语言规范中并没有为中断定义任何特定应用级别的语义，<strong>但最常使用中断的情况就是取消某个操作</strong>。<font color="#00dd6d">示例代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程1开始休眠---"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程1中断状态检测1:"</span> +</span><br><span class="line">                            Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程1休眠被中断---"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程1中断状态检测2:"</span> +</span><br><span class="line">                            Thread.currentThread().isInterrupted());</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    System.out.println(<span class="string">"线程1中断状态检测3:"</span> +</span><br><span class="line">                            Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程1休眠结束---"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程2开始执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t1.interrupt();</span><br><span class="line">                System.out.println(<span class="string">"线程2执行结束"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">线程<span class="number">1</span>开始休眠---</span><br><span class="line">线程<span class="number">2</span>开始执行</span><br><span class="line">线程<span class="number">2</span>执行结束</span><br><span class="line">线程<span class="number">1</span>休眠被中断---</span><br><span class="line">线程<span class="number">1</span>中断状态检测<span class="number">2</span>:<span class="keyword">false</span></span><br><span class="line">线程<span class="number">1</span>中断状态检测<span class="number">3</span>:<span class="keyword">true</span></span><br><span class="line">线程<span class="number">1</span>休眠结束---</span><br></pre></td></tr></table></figure>

<p><strong>P79</strong>：所有的同步工具类都包含一些特定的结构化属性：它们<strong>封装</strong>了一些状态，这些状态将决定执行同步工具类的线程时<strong>继续执行</strong>还是<strong>等待</strong>，此外还提供了一些<strong>方法</strong>对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。同步工具类有堵塞队列(BlockingQueue)、信号量(Semaphore)、栅栏(Barrier)、闭锁(Latch)等。</p>
<p><font color="#dd0000"><strong>闭锁(Latch)</strong></font>是一种同步工具类，可以<strong>延迟线程的进度</strong>直到到达终止状态。闭锁相当于一扇门：在闭锁到达<strong>结束状态</strong>之前，这扇门一直是<font color="#dd0000"><strong>关闭</strong></font>的，并且没有任何线程能通过，当到达<strong>结束</strong>状态时，这扇门会<strong>打开并允许所有的线程通过</strong>。<font color="#dd0000"><strong>当闭锁达到结束状态后，将不会再改变状态</strong></font>，因此这扇门将<strong>永远保持打开</strong>状态。<font color="#dd0000"><strong>闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。</strong></font>例如：</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行。</li>
<li>确保某个服务在其依赖的所有其它服务都已经启动之后才启动。</li>
<li><strong>等待直到某个操作的所有参与者(例如，在多玩家游戏中所有的玩家)都就绪在继续执行。这种情况下，当所有玩家都准备就绪时，闭锁就达到结束状态。</strong></li>
</ul>
<p><font color="#dd0000"><strong>CountDownLatch</strong></font>是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使<strong>一个或多个线程等待一组时间发生。</strong>闭锁状态包括一个计数器，该计数器被<strong>初始化为一个正数，表示需要等待的事件数量</strong>。countDown方法递减计数器，表示一个事件已经发生了，<strong>而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生</strong>。如果计数器的值非零，那么await会一直阻塞知道计数器为零，或者等待中的线程中断，或者<font color="#dd0000"><strong>等待超时</strong></font>。<font color="#00dd6d">示例代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads,<span class="keyword">final</span> Runnable task)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nThreads;i++) &#123;</span><br><span class="line">           Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">super</span>.run();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//在线程启动后，阻塞在这里，等待闭锁开关打开</span></span><br><span class="line">                       startGate.await();</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">//这里直接调用Runnalbe.run方法，没有新起线程</span></span><br><span class="line">                           task.run();</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          endGate.countDown();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           t.start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">       <span class="comment">//打开闭锁开关，使等待在上面的线程能够继续执行</span></span><br><span class="line">       startGate.countDown();</span><br><span class="line">       endGate.await();</span><br><span class="line">       <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">       <span class="keyword">return</span> end - start;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>P80</strong>：FutureTask也可以用做闭锁。(FutureTask实现了Future语义，表示一种<strong>抽象</strong>的<font color="#dd0000"><strong>可生成结果</strong></font>的计算)。FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable。Future.get的行为取决于任务的状态，<strong>如果任务已经完成，那么get会立即返回结果，否则get将阻塞知道任务进入完成状态，然后返回结果或者抛出异常</strong>。</p>
<p><strong>扩展</strong>：FutureTask继承RunnableFuture接口，而RunnableFuture接口又继承Runnable和Future接口。Future接口中包含get()、cancel()、isCancelled()、isDonw()等方法。<strong>使用FutureTask可以在线程A中计算结果，在线程B中获取计算值。</strong></p>
<p><strong>P82</strong>：计数信号量(Counting Semapore)用来<font color="#dd0000"><strong>控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量</strong></font>。计数信号量还可以用来实现某种资源池，或者对容器施加边界。Semaphore中管理着一组<strong>虚拟的许可</strong>，许可的初始数量可通过构造函数来指定。在执行操作时可以<strong>首先获得许可(只要还有剩余的许可)</strong>，并在使用以后<strong>释放</strong>许可。<font color="#dd0000"><strong>如果没有许可，那么acquire将阻塞直到有许可(或者直到被中断或者操作超时）</strong></font>，release方法将返回一个许可给信号量。计算信号量的一种<strong>简化形式</strong>是二值信号量，即初始值为1的Semaphore。二值信号量可以用作互斥体(mutex)，并具备<font color="#dd0000"><strong>不可重入</strong></font>的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。<font color="#00dd6d">示例代码：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用信号量为容器设置边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBoundedHashSetWithSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BoundedHashSet&lt;String&gt; boundedHashSet = <span class="keyword">new</span> BoundedHashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        boundedHashSet.add(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"1.Set.size="</span> + boundedHashSet.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                boundedHashSet.add(<span class="string">"B"</span>);</span><br><span class="line">                System.out.println(<span class="string">"2.Set.size="</span> + boundedHashSet.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> set.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sem.acquire(); <span class="comment">//请求许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            System.out.println(<span class="string">"插入元素："</span> + o.toString());</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!wasAdded) &#123;</span><br><span class="line">                sem.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">        System.out.println(<span class="string">"移除元素："</span> + o.toString());</span><br><span class="line">        <span class="keyword">if</span>(wasRemoved) &#123;</span><br><span class="line">            sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P83</strong>：<font color="#dd0000"><strong>栅栏（zha lan)</strong></font>类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的<strong>关键区别</strong>在于，<font color="#dd0000"><strong>所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程</strong></font>。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合：“所有人6:00在麦当劳碰头，到了以后要等其他人，之后再讨论下一步要做的事情。”</p>
<p>CyclicBarrier可以使一定数量的参与方<strong>反复</strong>地在栅栏位置汇集，它在<strong>并行迭代算法</strong>中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被<font color="#dd0000"><strong>重置</strong></font>以便下次使用。如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是<font color="#dd0000"><strong>打破</strong></font>了，所有阻塞的await调用都将终止并抛出<strong>BrokenBarrierException</strong>。如果成功通过栅栏，那么await将为每个线程返回一个<strong>唯一</strong>的<strong>到达索引号</strong>，我们可以利用这些索引来<strong>选举</strong>产生一个<strong>领导线程</strong>，并在下次迭代中由该领导线程执行一些<strong>特殊</strong>的工作。CyclicBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏时会(在一个子任务线程中)执行它，但在阻塞现场被释放之前是不能执行的。</p>
<p>在模拟程序中通常需要使用栅栏，例如某个步骤中的计算可以并行执行，但必须等到该步骤中的所有计算都执行完毕才能进入下一个步骤。</p>
<p><strong>P86-P90</strong>：构建高效且可伸缩的结果缓存</p>
<p>V1：使用HashMap&lt;A,V&gt;，然后对其上的读写操作方法使用synchronized加锁，<strong>缺点是每次只有一个线程能够执行读写操作</strong>。</p>
<p>V2：使用ConcurrentHashMap&lt;A,V&gt;替换HashMap&lt;A,V&gt;，优点是这样不需要对读写方法再进行一次同步，ConcurrentHashMap本身处理了同步问题，但是这里还是有一个不足的地方：<strong>就是可能导致重复的计算，如果某个线程启动了一个开销很大的计算，而其他线程并不知道这个计算正在进行，那么很可能会重复这个计算。</strong></p>
<p>V3：使用ConcurrentHashMap&lt;A,Future<V>&gt;替换ConcurrentHashMap&lt;A,V&gt;，<strong>当前版本首先检查某个相应的计算是否已经启动，而V2中是首先判断某个计算是否已经完成。V3可以避免重复计算，配合putIfAbsent原子方法实现。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapCache</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt; cache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMapCache</span><span class="params">(Computable&lt;A,V&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            <span class="keyword">if</span>(f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(eval);</span><br><span class="line">                <span class="comment">//使用ConcurrentHashMap中的原子操作putIfAbsent</span></span><br><span class="line">                f = cache.putIfAbsent(arg,ft);</span><br><span class="line">                <span class="keyword">if</span>(f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"|缓存为空，开始计算"</span>);</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"|缓存不为空，阻塞等待"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    cache.remove(arg,f);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConcurrentMapCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computable&lt;String,String&gt; c = <span class="keyword">new</span> Computable&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">compute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s + <span class="string">"++++++++"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConcurrentHashMapCache&lt;String,String&gt; concurrentHashMapCache = <span class="keyword">new</span> ConcurrentHashMapCache&lt;String,String&gt;(c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.run();</span><br><span class="line">                    System.out.println(concurrentHashMapCache.compute(<span class="string">"AA"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六章-任务执行"><a href="#第六章-任务执行" class="headerlink" title="第六章 任务执行"></a>第六章 任务执行</h3><p><strong>P94</strong>：在某些情况中，串行处理方式能带来简单性或安全性。<strong>大多数GUI框架都是通过单一的线程来串行地处理任务</strong>。</p>
<p><strong>P95</strong>：如果可运行的线程数量多于可用处理器的数量，那么有线程将闲置。大量闲置的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。</p>
<p><strong>P96</strong>：虽然Executor是个简单的接口，但它却为灵活且强大的异步任务执行框架提供了基础，该框架支持多种不同类型的任务执行策略。<strong>它提供了一种标准的方法将任务的提交过程和执行过程解耦开来，并用Runnable来表示任务</strong>。<font color="#dd0000"><strong>Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制</strong></font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>P99</strong>：可以通过调用<strong>Executors中的静态工厂方法之</strong>一来创建一个线程池：</p>
<p><strong>newFixedThreadPool</strong>。newFixedThreadPool将创建一个<strong>固定长度</strong>的线程池，每当提交一个任务时就创建一个县城，直至达到线程池的最大数量，这时线程池的规模不在变化(<font color="#dd0000"><strong>如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程</strong></font>)</p>
<p><strong>newCachedThreadPool</strong>。newCachedThreadPool将创建一个可缓存的线程池，如果线程池的当前规模超过处理需要时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，<font color="#dd0000"><strong>线程池的规模不存在任何限制。</strong></font></p>
<p><strong>newSingleThreadPool</strong>。是一个<strong>单线程</strong>的Executor，它创建单个工作线程来执行任务，<font color="#dd0000"><strong>如果这个线程异常结束，会创建另一个线程来替代</strong></font>。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行(例如FIFO、LIFO、优先级)。</p>
<p>备注：单线程的Executor还提供了了大量的内部同步机制，从而确保了任务执行的任何内存写入操作对于后续任务来说都是可见的。<strong>这意味着，及时这个线程会不时地被另一个线程替代，但对象总是可以安全地封闭在”任务线程”中。</strong></p>
<p><strong>newScheduledThreadPool</strong>。newScheduledThreadPool将创建一个<font color="#dd0000"><strong>固定长度</strong></font>的线程池，而且以<font color="#dd0000"><strong>延迟或定时</strong></font>的方式来执行任务，类似于Timer。</p>
<p><strong>P100</strong>：<font color="#dd0000"><strong>为了解决执行服务的生命周期问题</strong></font>，Executor扩展了ExecutorService接口，<strong>添加了一些用于生命周期管理的方法</strong>(同时还有一些用于任务提交的便利方法)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">boolwan <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">boolwan <span class="title">awaitTimination</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="comment">// ...... 其他用于任务提交的便利方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExecutorService的生命周期有3中状态：运行、关闭和已终止。ExecutorService在初始创建时处于<strong>运行状态</strong>。shutdown方法将执行<strong>平缓</strong>的关闭过程：<strong>不再接收新的任务，同时等待已经提交的任务执行完成</strong>——<font color="#dd0000"><strong>包括哪些还未开始执行的任务</strong></font>。shutdownNow方法将执行<strong>粗暴</strong>的关闭过程：它将<font color="#dd0000"><strong>尝试（备注：并非一定成功）</strong></font><strong>取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</strong></p>
<p>在ExecutorService关闭后提交的任务将由<strong>拒绝执行处理器(Rejected Execution Handler)</strong>来处理，它将抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。等所有任务都完成后，ExecutorService将转入终止状态。<strong>可以调用awaitTermination来等待ExecutorService达到终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果。</strong></p>
<p><strong>P101</strong>：Timer存在一些缺陷，<font color="#dd0000"><strong>因此应该考虑使用SheduledThreadPool来替代它</strong></font>，Timer在执行所有定时任务时<font color="#dd0000"><strong>只会创建一个线程</strong></font>。<strong>如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性</strong>。例如某个周期TimerTask需要每10ms执行一次，而另一个TimerTask需要执行40ms，<strong>那么这个周期任务或者在40ms任务执行完成后快速连续调用4次，或者彻底丢失4次调用(取决于它是基于固定速率来调度还是基于固定延时来调度）</strong>。</p>
<p>Timer的另一个问题是，如果TimerTask抛出一个未检查的异常。那么Timer将表现出糟糕的行为：Timer线程并不捕获异常，因此当TimerTask抛出未检查的异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。这被称为<strong>线程泄漏</strong>。</p>
<p>备注：Timer支持基于<strong>绝对时间</strong>而不是<strong>相对时间</strong>的调度机制，因此任务的执行对系统时钟变化很敏感，而ScheduledThreadPoolExecutor值支持基于相对时间的调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(),<span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(),<span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P103</strong>：Runable是一种由很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。<strong>Callable是一种更好的抽象：它认为主入口点(即call)将返回一个值，并且可能抛出一个异常</strong>。在Executor中包含了一些辅助方法能够将其他类型的任务封装为一个Callable，例如Runnable和java.security.PrivilegedAction。</p>
<p>在Executor框架中，已提交单尚未开始的任务可以取消，<strong>但对于那些已经开始执行的任务，只有当他们能够响应中断时，才能取消。</strong></p>
<p>Future表示一个任务的<font color="#dd0000"><strong>生命周期</strong></font>，并提供相应的方法来<strong>判断</strong>是否已经完成或取消，以及<strong>获取</strong>任务的结果和取消任务等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Callable与Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Excepiton</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExcutionException,CancellationException</span>;</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unti)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,ExcutionException</span></span><br><span class="line"><span class="function">    ,CancellationException,TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法的行为取决于任务的状态(尚未开始、正在运行、已完成)。如果任务已经完成，那么get会立即返回或者抛出一个Exception，<strong>如果任务没有完成，那么get将阻塞并直到任务完成</strong>。如果任务抛出了异常，那么get将该异常封装为ExecutionException并<strong>重新抛出</strong>，如果任务被取消，那么get将抛出CancellationException。如果get抛出了ExecutionException，那么可以通过getCause()来获得被封装的初始异常。</p>
<p><strong>P104</strong>：可以通过许多种方法创建一个Future来标书任务。ExecutorService中所有submit方法都将返回一个Future，从而将衣蛾Runnable或Callable提交给Executor，并得到一个Futrue用来获得任务的执行结果或者取消任务。还可以显示地为某个指定的Runnable或Callable实例化一个FutureTask。(由于FutureTask实现Runnable,因此可以将它提交给Executor来执行，或者直接调用它的run方法。)</p>
<p><strong>P106</strong>：<font color="#dd0000"><strong>CompletionService将Executor和BlockingQueue的功能融合在一起</strong></font>。你可以将Callable任务提交给它来执行，人后使用类似于<strong>队列操作额take和poll</strong>等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。ExecutorCompletionService实现了CompletionService，并将计算结果委托给了一个Executor。</p>
<p>ExecutorCompletionService的实现非常简单。在构造函数中创建一个BlockingQueue来保存计算完成的结果。当计算完成时，<strong>调用Future-Task的down方法</strong>。当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask的一个子类，然后在改写该子类的done方法，并将结果放入BlockingQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueingFuture</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueingFuture</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.done();</span><br><span class="line">        completionQueue.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    Renderer(ExecutorService executor) &#123;<span class="keyword">this</span>.executor = executor;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImagaeInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService =</span><br><span class="line">                <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">final</span> ImageInfo imageInfo:info) &#123;</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>,n=info.size;t&lt;n;t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                ImageData imageData = f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P108</strong>:为任务设置超时——在使用限时任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间，并且在超时后中止执行或取消任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTimeOut</span> </span>&#123;</span><br><span class="line">    <span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> endNanos = System.nanoTime() + <span class="number">10000</span>;</span><br><span class="line">        Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">        <span class="comment">//在等待广告的同时显示页面</span></span><br><span class="line">        Page page = renderPageBody();</span><br><span class="line">        Ad ad;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只等待指定的时间长度</span></span><br><span class="line">            <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">            ad = f.get(timeLeft,NANOSECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ExecutionException e) &#123;</span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(TimeoutException e)&#123;</span><br><span class="line">            ad = DEFAULT_AD;</span><br><span class="line">            f.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        page.setAd(ad);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>P109</strong>：创建n个任务，将其提交到一个线程池，保留n个Future，并使用限时的get方法通过Future串行地获取每一个结果，这一些都很简单，但还有一个更简单的方法——invokeAll。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInvokeAll</span> </span>&#123;</span><br><span class="line">    ExecutorService exec;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> company.solicitQuote(travelInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span><span class="params">(TravelInfo travelInfo</span></span></span><br><span class="line"><span class="function"><span class="params">        ,Set&lt;TravelCompany&gt; companies,Comparator&lt;TravelQuote&gt; ranking</span></span></span><br><span class="line"><span class="function"><span class="params">            , <span class="keyword">long</span> time,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(TravelCompany company:companies) &#123;</span><br><span class="line">            tasks.add(<span class="keyword">new</span> QuoteTask(company,travelInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Future&lt;TravelQuote&gt;&gt; futures =</span><br><span class="line">                exec.invokeAll(tasks,time,unit);</span><br><span class="line">        List&lt;TravelQuote&gt; quotes =</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;TravelQuote&gt;(tasks.size());</span><br><span class="line">        Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;TravelQuote&gt; f:futures) &#123;</span><br><span class="line">            QuoteTask task = taskIter.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                quotes.add(f.get());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                quotes.add(task.getFailureQuote(e.getCause()));</span><br><span class="line">            &#125; <span class="keyword">catch</span>(CancellationException e) &#123;</span><br><span class="line">                quotes.add(task.getTimeoutQuote(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(quotes,ranking);</span><br><span class="line">        <span class="keyword">return</span> quotes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第七章-取消与关闭"><a href="#第七章-取消与关闭" class="headerlink" title="第七章 取消与关闭"></a>第七章 取消与关闭</h3><p><strong>P111</strong>：钥匙任务和线程能安全、快速、可靠地停下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。<strong>但它提供了中断(Interruption)，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</strong></p>
<p><strong>P112-P113</strong>：可以使用volatile修饰的标志位来取消线程的执行；但是当在BlockingQueue中使用这种volatile标志位的方式可能会因为阻塞队列的操作方法被阻塞住而永远无法得到检查机会。</p>
<p><strong>P114</strong>：阻塞库方法，例如：Thread.sleep和Object.wait等，都会检查线程何时中断，并且在发现中断时提前返回。他们在响应中断时执行的操作包括：清除中断状态，抛出InterruptedException表示阻塞操作由于中断而提前结束。</p>
<p><strong>P115</strong>：对中断操作正确的理解是：它不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在<strong>下一个合适的时机</strong><font color="#dd0000"><strong>中断自己</strong></font>。在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理——<strong>可以抛出InterruptedException，或者通过再次调用interrupt来恢复中断状态</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/" data-id="ck82f1b6c0027lu2676p5abw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目『腾讯MMKV存储框架』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.095Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MMKV的介绍"><a href="#MMKV的介绍" class="headerlink" title="MMKV的介绍"></a>MMKV的介绍</h2><p>MMKV 是基于 <font color="#dd0000"><strong>mmap 内存映射</strong></font>的 key-value 组件，<strong>底层序列化/反序列化使用 protobuf 实现</strong>，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>高性能 实时写入</strong></li>
<li><strong>稳定 防crash</strong></li>
<li><strong>多进程访问</strong><br> 通过与 Android 开发同学的沟通，了解到系统自带的 SharedPreferences 对多进程的支持不好。<br> 现有基于 ContentProvider 封装的实现，虽然多进程是支持了，但是性能低下，经常导致 ANR。<br> 考虑到 mmap 共享内存本质上的多进程共享的，我们在这个基础上，深入挖掘了 Android 系统的能力，提供了可能是业界最高效的多进程数据共享组件。</li>
<li><strong>匿名内存</strong><br> 在多进程共享的基础上，考虑到某些敏感数据(例如密码)需要进程间共享，但是不方便落地存储到文件上，直接用 mmap 不合适。<br> 我们了解到 Android 系统提供了 Ashmem 匿名共享内存的能力，发现它在进程退出后就会消失，不会落地到文件上，非常适合这个场景。<br> 我们很愉快地提供了 Ashmem MMKV 的功能。</li>
<li><strong>数据加密</strong><br> 不像 iOS 提供了硬件层级的加密机制，在 Android 环境里，数据加密是非常必须的。<br> MMKV 使用了 AES CFB-128 算法来加密/解密。我们选择 CFB 而不是常见的 CBC 算法，<br> 主要是因为 MMKV 使用 append-only 实现插入/更新操作，流式加密算法更加合适。</li>
<li><strong>数据有效性</strong></li>
</ul>
<h3 id="关于mmap内存映射"><a href="#关于mmap内存映射" class="headerlink" title="关于mmap内存映射"></a>关于mmap内存映射</h3><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，<strong>实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系</strong>。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而<font color="#dd0000"><strong>系统会自动回写脏页面到对应的文件磁盘上</strong></font>，即完成了对文件的操作而不必再调用read,write等系统调用函数。<font color="#dd0000"><strong>相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享</strong></font>。</p>
<p>####mmap内存映射原理</p>
<p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p>
<p><strong>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p>
<p>1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p>
<p>3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</p>
<p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p>
<p><strong>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p>
<p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p>
<p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p>
<p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p>
<p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p>
<p><strong>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</strong></p>
<p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p>
<p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p>
<p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p>
<p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p>
<p>12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>
<p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p>
<h4 id="mmap和常规文件操作的区别"><a href="#mmap和常规文件操作的区别" class="headerlink" title="mmap和常规文件操作的区别"></a>mmap和常规文件操作的区别</h4><p>对linux文件系统不了解的朋友，请参阅我之前写的博文《<a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html" target="_blank" rel="noopener">从内核文件系统看文件读写过程</a>》，我们首先简单的回顾一下常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p>
<p>1、进程发起读文件请求。</p>
<p>2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</p>
<p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p>
<p>4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p>
<p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
<p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p>
<p><strong>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong>说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p>
<h4 id="mmap优点总结"><a href="#mmap优点总结" class="headerlink" title="mmap优点总结"></a>mmap优点总结</h4><p>由上文讨论可知，mmap优点共有一下几点：</p>
<p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p>
<p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p>
<p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p>
<p>​     同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p>
<p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p>
<h4 id="mmap使用细节"><a href="#mmap使用细节" class="headerlink" title="mmap使用细节"></a>mmap使用细节</h4><p>1、使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p>
<p>2、内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。具体情形参见“情形三”。</p>
<p>3、映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p>
<p>在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：</p>
<p><strong>情形一：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。</strong></p>
<p>分析：因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。映射后的对应关系如下图所示：</p>
<p>​               <img src="https://images0.cnblogs.com/blog2015/571793/201507/200521495513717.png" alt="img"></p>
<p>此时：</p>
<p>（1）读/写前5000个字节（0~4999），会返回操作文件内容。</p>
<p>（2）读字节5000<del>8191时，结果全为0。写5000</del>8191时，进程不会报错，但是所写的内容不会写入原文件中 。</p>
<p>（3）读/写8192以外的磁盘部分，会返回一个SIGSECV错误。</p>
<p><strong>情形二：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。</strong></p>
<p>分析：由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常。如下图所示：</p>
<p>​                 <img src="https://images0.cnblogs.com/blog2015/571793/201507/200522381763096.png" alt="img"></p>
<p>此时：</p>
<p>（1）进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中。</p>
<p>（2）对于5000~8191字节，进程可以进行读写过程，不会报错。但是内容在写入前均为0，另外，写入后不会反映在文件中。</p>
<p>（3）对于8192~14999字节，进程不能对其进行读写，会报SIGBUS错误。</p>
<p>（4）对于15000以外的字节，进程不能对其读写，会引发SIGSEGV错误。</p>
<p><strong>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。</strong></p>
<p>分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。</p>
<p>但是如果，每次操作ptr读写前，先增加文件的大小，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr ~ [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。</p>
<p>这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费</p>
<h4 id="mmap性能总结"><a href="#mmap性能总结" class="headerlink" title="mmap性能总结"></a>mmap性能总结</h4><ul>
<li>大家关于“<strong>mmap</strong>()”更快的认识来自于 <strong>read</strong>() 是需要内存拷贝的；</li>
<li>当今硬件技术的发展，使得内存拷贝消耗的时间已经极大降低了；</li>
<li>但“<strong>mmap</strong>()”的开销在于一次  pagefault，这个开销相比而言已经更高了，而且 pagefault 的处理任务现在比以前还更多了；</li>
<li>而且，<strong>mmap</strong>之后，再有读操作不会经过系统调用，在 LRU 比较最近使用的页的时候不占优势；</li>
<li>于是，普通读情况下（排除反复读之类的文艺与2B读操作），<strong>read</strong>() 通常会比 <strong>mmap</strong>() 来得更快。</li>
</ul>
<h2 id="MMKV的Android集成使用"><a href="#MMKV的Android集成使用" class="headerlink" title="MMKV的Android集成使用"></a>MMKV的Android集成使用</h2><h3 id="安装引入"><a href="#安装引入" class="headerlink" title="安装引入"></a>安装引入</h3><p>推荐使用 Maven：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;com.tencent:mmkv-static:1.0.24&#39;</span><br><span class="line">    &#x2F;&#x2F; replace &quot;1.0.24&quot; with any available version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>MMKV 的使用非常简单，所有变更立马生效，无需调用 <code>sync</code>、<code>apply</code>。 在 App 启动时初始化 MMKV，设定 MMKV 的根目录（files/mmkv/），例如在 MainActivity 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    String rootDir &#x3D; MMKV.initialize(this);</span><br><span class="line">    System.out.println(&quot;mmkv root: &quot; + rootDir);</span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MMKV 提供一个全局的实例，可以直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tencent.mmkv.MMKV;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"></span><br><span class="line">MMKV kv = MMKV.defaultMMKV();</span><br><span class="line"></span><br><span class="line">kv.encode(<span class="string">"bool"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">boolean</span> bValue = kv.decodeBool(<span class="string">"bool"</span>);</span><br><span class="line"></span><br><span class="line">kv.encode(<span class="string">"int"</span>, Integer.MIN_VALUE);</span><br><span class="line"><span class="keyword">int</span> iValue = kv.decodeInt(<span class="string">"int"</span>);</span><br><span class="line"></span><br><span class="line">kv.encode(<span class="string">"string"</span>, <span class="string">"Hello from mmkv"</span>);</span><br><span class="line">String str = kv.decodeString(<span class="string">"string"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="MMKV-实现原理"><a href="#MMKV-实现原理" class="headerlink" title="MMKV 实现原理"></a>MMKV 实现原理</h2><ul>
<li><p><strong>内存准备</strong><br>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</p>
</li>
<li><p><strong>数据组织</strong><br>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</p>
</li>
<li><p><strong>写入优化</strong><br>考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。</p>
</li>
<li><p><strong>空间增长</strong><br>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。</p>
</li>
</ul>
<h2 id="MMKV中需要考虑的问题"><a href="#MMKV中需要考虑的问题" class="headerlink" title="MMKV中需要考虑的问题"></a>MMKV中需要考虑的问题</h2><h3 id="Android-多进程设计与实现"><a href="#Android-多进程设计与实现" class="headerlink" title="Android 多进程设计与实现"></a>Android 多进程设计与实现</h3><h4 id="CS-架构-vs-去中心化架构"><a href="#CS-架构-vs-去中心化架构" class="headerlink" title="CS 架构 vs 去中心化架构"></a>CS 架构 vs 去中心化架构</h4><p>Android 平台第一个想到的就是 ContentProvider：一个单独进程管理数据，数据同步不易出错，简单好用易上手。然而它的问题也很明显，就是一个字<strong>慢</strong>：启动慢，访问也慢。这个可以说是 Android 下基于 Binder 的 CS 架构组件的通用痛点。至于其他的 CS 架构，例如经典的 socket、PIPE、message queue，因为要至少 2 次的内存拷贝，就更加慢了。</p>
<p>MMKV 追求的是极致的访问速度，我们要尽可能地避免进程间通信，CS 架构是不可取的。再考虑到 MMKV 底层使用 mmap 实现，采用去中心化的架构是很自然的选择。我们只需要将文件 mmap 到每个访问进程的内存空间，加上合适的进程锁，再处理好数据的同步，就能够实现多进程并发访问。</p>
<h4 id="挑选进程锁"><a href="#挑选进程锁" class="headerlink" title="挑选进程锁"></a>挑选进程锁</h4><p>然而去中心化的架构实现起来并不简单，Android 是个阉割版的 Linux，IPC 组件的支持比较残缺。例如，说到进程锁第一个想到的就是 pthread 库的 pthread_mutex，创建于共享内存的 pthread_mutex 是可以用作进程锁的，然而 Android 版的 pthread_mutex 并不保证<strong>robust</strong>，亦即对 pthread_mutex 加了锁的进程被 kill，系统不会进行清理工作，这个锁会一直存在下去，那么其他等锁的进程就会永远饿死。其他的 IPC 组件，例如信号量、条件变量，也有同样问题，Android 为了能够尽快关闭进程，真是无所不用其极。</p>
<p>找了一圈，能够保证 robust 的，只有已打开的<strong>文件描述符</strong>，以及基于文件描述符的<strong>文件锁</strong>和 Binder 组件的死亡通知（是的，Binder 也是依赖这个<a href="http://gityuan.com/2016/10/03/binder_linktodeath/#%E5%9B%9B-%E8%A7%A6%E5%8F%91%E6%AD%BB%E4%BA%A1%E9%80%9A%E7%9F%A5" target="_blank" rel="noopener">清理机制运作</a>，打开的文件是 /dev/binder）。</p>
<p>我们有两个选择：</p>
<ul>
<li><strong>文件锁</strong>，优点是天然 robust，缺点是不支持递归加锁，也不支持读写锁升级/降级，需要自行实现。</li>
<li><strong>pthread_mutex</strong>，优点是 pthread 库支持递归加锁，也支持读写锁升级/降级，缺点是不 robust，需要自行清理。</li>
</ul>
<p>关于 mutex 清理，有个可能的方案是基于 Binder 死亡通知进行清理：A、B进程相互注册对方的死亡通知，在对方死亡的时候进行清理。但有个比较棘手的场景：只有 A 进程存在，那么他的死亡通知就没人处理，留下一个永远加锁的 mutex。Binder 规定死亡通知不能本进程自行处理，必须由其他进程处理，所以这个问题不好解决。</p>
<p>综合各种考虑，我们先将文件锁作为一个简单的互斥锁，进行 MMKV 的多进程开发，稍后再回头解决递归锁和读写锁升级/降级的问题。</p>
<h3 id="多进程实现细节"><a href="#多进程实现细节" class="headerlink" title="多进程实现细节"></a>多进程实现细节</h3><p>首先我们简单回顾一下 MMKV 原来的逻辑。MMKV 本质上是将文件 mmap 到内存块中，将新增的 key-value 统统 append 到内存中；到达边界后，进行重整回写以腾出空间，空间还是不够的话，就 double 内存空间；对于内存文件中可能存在的重复键值，MMKV 只选用最后写入的作为有效键值。那么其他进程为了保持数据一致，就需要处理这三种情况：<strong>写指针增长、内存重整、内存增长</strong>。但首先还得解决一个问题：怎么让其他进程感知这三种情况？</p>
<h4 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h4><ul>
<li>写指针的同步<br>我们可以在每个进程内部缓存自己的写指针，然后在写入键值的同时，还要把最新的写指针位置也写到 mmap 内存中；这样每个进程只需要对比一下缓存的指针与 mmap 内存的写指针，如果不一样，就说明其他进程进行了写操作。事实上 MMKV 原本就在文件头部保存了<strong>有效内存的大小</strong>，这个数值刚好就是写指针的内存偏移量，我们可以重用这个数值来校对写指针。</li>
<li>内存重整的感知<br>考虑使用一个<strong>单调递增的序列号</strong>，每次发生内存重整，就将序列号递增。将这个序列号也放到 mmap 内存中，每个进程内部也缓存一份，只需要对比序列号是否一致，就能够知道其他进程是否触发了内存重整。</li>
<li>内存增长的感知<br>事实上 MMKV 在内存增长之前，会先尝试通过内存重整来腾出空间，重整后还不够空间才申请新的内存。所以内存增长可以跟内存重整一样处理。至于新的内存大小，可以通过查询<strong>文件大小</strong>来获得，无需在 mmap 内存另外存放。</li>
</ul>
<p>状态同步逻辑用伪码表达大概是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void checkLoadData() &#123;</span><br><span class="line">    if (m_sequence !&#x3D; mmapSequence()) &#123;</span><br><span class="line">        m_sequence &#x3D; mmapSequence();</span><br><span class="line">        if (m_size !&#x3D; fileSize()) &#123;</span><br><span class="line">            m_size &#x3D; fileSize();</span><br><span class="line">            &#x2F;&#x2F; 处理内存增长</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理内存重整</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (m_actualSize !&#x3D; mmapActualSize()) &#123;</span><br><span class="line">        auto lastPosition &#x3D; m_actualSize;</span><br><span class="line">        m_actualSize &#x3D; mmapActualSize();</span><br><span class="line">        &#x2F;&#x2F; 处理写指针增长</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 什么也没发生</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写指针增长"><a href="#写指针增长" class="headerlink" title="写指针增长"></a>写指针增长</h4><p>当一个进程发现 mmap 写指针增长，就意味着其他进程写入了新键值。这些新的键值都 append 在原有写指针后面，可能跟前面的 key 重复，也可能是全新的 key，而原写指针前面的键值都是有效的。那么我们就要把这些新键值都读出来，插入或替换原有键值，并将写指针同步到最新位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto lastPosition &#x3D; m_actualSize;</span><br><span class="line">m_actualSize &#x3D; mmapActualSize();</span><br><span class="line">&#x2F;&#x2F; 处理写指针增长</span><br><span class="line">auto bufferSize &#x3D; m_actualSize - lastPosition;</span><br><span class="line">auto buffer &#x3D; Buffer(lastPosition, bufferSize);</span><br><span class="line">map&lt;string, Buffer&gt; dictionary &#x3D; decodeMap(buffer);</span><br><span class="line">for (auto&amp; itr : dictionary) &#123;</span><br><span class="line">    &#x2F;&#x2F; m_cache 还是有效的</span><br><span class="line">    m_cache[itr.first] &#x3D; itr.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存重整"><a href="#内存重整" class="headerlink" title="内存重整"></a>内存重整</h4><p>当一个进程发现内存被重整了，就意味着原写指针前面的键值全部失效，那么最简单的做法是全部抛弃掉，从头开始重新加载一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 处理内存重整</span><br><span class="line">m_actualSize &#x3D; mmapActualSize();</span><br><span class="line">auto buffer &#x3D; Buffer(0, m_actualSize);</span><br><span class="line">m_cache &#x3D; decodeMap(buffer);</span><br></pre></td></tr></table></figure>

<h4 id="内存增长"><a href="#内存增长" class="headerlink" title="内存增长"></a>内存增长</h4><p>正如前文所述，发生内存增长的时候，必然已经先发生了内存重整，那么原写指针前面的键值也是统统失效，处理逻辑跟内存重整一样。</p>
<h4 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h4><p>到这里我们已经完成了数据的多进程同步工作，是时候回头处理锁事了，亦即前面提到的递归锁和锁升级/降级。</p>
<ul>
<li><strong>递归锁</strong><br>意思是如果一个进程/线程已经拥有了锁，那么后续的加锁操作不会导致卡死，并且解锁也不会导致外层的锁被解掉。对于文件锁来说，前者是满足的，后者则不然。因为<strong>文件锁是状态锁</strong>，没有计数器，无论加了多少次锁，一个解锁操作就全解掉。只要用到子函数，就非常需要递归锁。</li>
<li><strong>锁升级/降级</strong><br>锁升级是指将已经持有的共享锁，升级为互斥锁，亦即将读锁升级为写锁；锁降级则是反过来。文件锁支持锁升级，但是容易死锁：假如 A、B 进程都持有了读锁，现在都想升级到写锁，就会陷入相互等待的困境，<strong>发生死锁</strong>。另外，由于文件锁不支持递归锁，也导致了锁降级无法进行，一降就降到没有锁。</li>
</ul>
<p>为了解决这两个难题，需要对文件锁进行封装，增加读锁、写锁计数器。处理逻辑如下表：</p>
<table>
<thead>
<tr>
<th>读锁计数器</th>
<th>写锁计数器</th>
<th>加读锁</th>
<th>加写锁</th>
<th>解读锁</th>
<th>解写锁</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>加读锁</td>
<td>加写锁</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>+1</td>
<td>+1</td>
<td>-</td>
<td>解写锁</td>
</tr>
<tr>
<td>0</td>
<td>N</td>
<td>+1</td>
<td>+1</td>
<td>-</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>+1</td>
<td>解读锁再加写锁</td>
<td>解读锁</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>+1</td>
<td>+1</td>
<td>-1</td>
<td>加读锁</td>
</tr>
<tr>
<td>1</td>
<td>N</td>
<td>+1</td>
<td>+1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>N</td>
<td>0</td>
<td>+1</td>
<td>解读锁再加写锁</td>
<td>-1</td>
<td>-</td>
</tr>
<tr>
<td>N</td>
<td>1</td>
<td>+1</td>
<td>+1</td>
<td>-1</td>
<td>加读锁</td>
</tr>
<tr>
<td>N</td>
<td>N</td>
<td>+1</td>
<td>+1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<p>需要注意的地方有两点：</p>
<ul>
<li>加写锁时，如果当前已经持有读锁，那么先尝试加写锁，try_lock 失败说明其他进程持有了读锁，我们需要先将自己的读锁释放掉，再进行加写锁操作，以避免死锁的发生。</li>
<li>解写锁时，假如之前曾经持有读锁，那么我们不能直接释放掉写锁，这样会导致读锁也解了。我们应该加一个读锁，将锁降级。</li>
</ul>
<h3 id="补充适用建议"><a href="#补充适用建议" class="headerlink" title="补充适用建议"></a>补充适用建议</h3><p>如果使用请务必做code19版本的适配，这个在github官网有说明</p>
<p>依赖下面这个库，然后对19区分处理<br> implementation ‘com.getkeepsafe.relinker:relinker:1.3.1’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT == <span class="number">19</span>) &#123;</span><br><span class="line">    MMKV.initialize(relativePath, <span class="keyword">new</span> MMKV.LibLoader() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">            ReLinker.loadLibrary(context, libName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MMKV.initialize(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：<br><a href="https://github.com/Tencent/MMKV/blob/master/readme_cn.md" target="_blank" rel="noopener">https://github.com/Tencent/MMKV/blob/master/readme_cn.md</a><br><a href="https://blog.csdn.net/qq_33611327/article/details/81738195" target="_blank" rel="noopener">深度分析mmap：是什么 为什么 怎么用 性能总结</a><br><a href="https://github.com/Tencent/MMKV/wiki/android_ipc" target="_blank" rel="noopener">MMKV for Android 多进程设计与实现</a></p>
<p><a href="https://www.jianshu.com/p/65334d245bc4" target="_blank" rel="noopener">微信MMKV使用和原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/" data-id="ck82f1b680020lu2690vq6whn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开源项目——OkHttp『源码学习』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.091Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OKHttp是个优秀的开源项目，值得学习。但是代码量比EventBus、Retrofit之类的大多了。想要一下子没有遗漏的都搞清楚不是一件容易的事情。这篇博客，是我在学习过程中的一些问题，有些自觉找到了答案，有些还不知道如何回答，留待以后补充吧。</p>
<h2 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h2><ol>
<li><p>异步，同步队列共用线程池吗？共用请求数量限制(maxRequests和maxRequestsPerHost)吗？</p>
<p>答：<code>请求数量限制只对异步队列有效</code>，对于同步任务不做限制，只管添加执行就得了。</p>
</li>
<li><p>为什么不直接使用线程池，而是自己另外维护了工作队列？</p>
<p>答：首先这里使用了的线程池是基于同步队列的，而同步队列本身是不支持工作队列的，所以需要一个额外的工作队列来维护任务的提交工作。</p>
</li>
<li><p>为什么OkHttp的异步任务选择使用两个队列维护？而不是使用一个工作队列实现？</p>
<p>答：说下我自己的看法，首先为什么需要两个队列，因为在提交异步任务是需要统计当前的运行中的任务数量，使用一个队列的话，还需要遍历队列中的任务状态，而将等待运行和运行中分离开来可以避免这种困扰，减少问题发生的可能性。</p>
</li>
<li><p>等待队列中的任务何时触发运行？</p>
<p>答：不管是异步任务还是同步任务，任务的执行代码都包含在一个try…catch代码块中，该代码块的finally中执行dispatcher.finished(this)，在finished()方法中首先会从异步运行中队列中移除代表当前任务的Call对象，然后会去异步等待就绪队列中拿任务放到异步运行中队列中，并执行任务。看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.finished()</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//首先从运行队列中移除当前已完成的Call对象</span></span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      <span class="comment">//这个promoteCalls()方法中，会从异步就绪等待队列中拿取任务放到异步运行队列并执行</span></span><br><span class="line">      <span class="keyword">if</span> (promoteCalls) promoteCalls(); </span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有任务在运行时，触发回调，暂时不知道使用场景</span></span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下调度等待就绪任务的promoteCalls()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.promoteCalls()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">//从当前等待就绪队列中移除当前Call对象</span></span><br><span class="line">        i.remove();</span><br><span class="line">        <span class="comment">//添加Call到运行队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果okhttpclient不作为单例使用，那么线程池是否就有多个了，Dispatcher呢？</p>
<p><strong>答</strong>：每个OkHttpClient对象实例对应一个Dispatcher，因此也就意味着多个OkHttpClient对应着多个线程池。</p>
</li>
<li><p>RetryAndFollowUpInterceptor中的重试指的是什么？是重试连接还是跳转？还是包含了这两个动作：重连次数和跳转数限制？</p>
<p><strong>答</strong>：</p>
</li>
<li><p>缓存需要手动指定才能生效吗？缓存机制是什么？</p>
</li>
<li><p>DiskLruCache算法的具体细节是什么？缓存清理线程的工作原理是什么？</p>
</li>
<li><p>为什么要把AsyncCall定义成RealCall的内部类？有什么好处吗？</p>
</li>
<li><p>为什么缓存管理需要另外一个日志文件？</p>
</li>
<li><p>为什么DiskLruCache的内部类Entry需要一个cleanFiles文件数组和一个dirtyFiles文件数组？</p>
</li>
</ol>
<h2 id="我们发送一个简单请求的过程："><a href="#我们发送一个简单请求的过程：" class="headerlink" title="我们发送一个简单请求的过程："></a>我们发送一个简单请求的过程：</h2><ol>
<li>构造一个OkHttpClient对象，注意每个OkHttpClient都会有一个线程池和连接池，所以想要做到线程池和连接池的复用，最好使用一个全局的OkHttpClient单例对象。</li>
<li>构造一个Request，这里使用了Builder设计模式。</li>
<li>使用OkHttpClient的newCall方法构造一个Call接口对象，这个Call接口对象的具体实现在RealCall类中。</li>
<li>调用Call接口的enqueue(Callback)或execute()执行异步或同步请求。</li>
</ol>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>总得来说，一个请求的发送响应流程分为几个主要步骤：</p>
<ul>
<li>任务调度</li>
<li>拦截器处理(责任链机制)</li>
<li>缓存机制</li>
<li>连接复用。</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ol>
<li><p>在构造OkHttpClient对象的Builder时，会在Builder的构造方法中创建一个Dispatcher()，Dispatcher在OkHttp中扮演了一个管理调度器的角色。</p>
</li>
<li><p><strong>Dispatcher中包含三个任务队列，分别是：readyAsyncCalls(异步就绪等待队列)、runningAsyncCalls(运行中的异步任务队列)和runningSyncCalls(运行中的同步任务队列)。</strong>同时，Dispatcher中还包含了一个线程池，<font color="#dd0000"><strong>这是一个基于同步队列(SynchronousQueue)的线程池</strong></font>，Dispatcher在提交任务到线程池时会对当前线程执行情况做校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，maxRequests和maxRequestPerHost只对异步任务做限制。</strong></p>
</li>
<li><p><font color="#dd0000"><strong>不管是同步任务还是异步任务，最后都会执行execute()</strong></font>，这段代码被包含在一个catch块中，该catch块后面的finally中都执行了Dispatcher.finished(Call)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在finished方法中会根据isPromoteCall来决定是否会触发promoteCalls方法(Dispatcher有多个重载的finished()方法，<strong>同步任务不触发promoteCalls，异步方法触发promoteCalls方法</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">  <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    AsyncCall call = i.next();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      i.remove();</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出promoteCalls方法是用于<strong>从就绪等待队列中拿去任务到异步运行队列的</strong>。</p>
</li>
</ol>
<h3 id="Okhttp3中的拦截器责任链"><a href="#Okhttp3中的拦截器责任链" class="headerlink" title="Okhttp3中的拦截器责任链"></a>Okhttp3中的拦截器责任链</h3><p><strong>责任链模式</strong>可以查看『补充』中的查看，在OkHttp3中实现了对请求和响应的层层拦截处理，每个拦截器按照自己的职责添加处理方法。</p>
<p>Okhttp中有这几个内置的拦截器，看一张别人的流程图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5713484-35a9989e893171f1.png" alt="avatar"></p>
<h4 id="Interceptor接口"><a href="#Interceptor接口" class="headerlink" title="Interceptor接口"></a>Interceptor接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observes, modifies, and potentially short-circuits requests going out and the corresponding</span></span><br><span class="line"><span class="comment"> * responses coming back in. Typically interceptors add, remove, or transform headers on the request</span></span><br><span class="line"><span class="comment"> * or response.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于当前Request执行的Connection对象。这个方法只在网络层拦截器中有用到，对于应用程序的拦截器，总是返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Call <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p><font color="#dd0000"><strong>这个拦截器用于实现失败重试以及追踪重定向</strong></font>(默认最多20次重定向)。如果Call被取消可能会抛出IOException。</p>
<p>整个Call相关的StreamAllocation在RetryAndFollowUpInterceptor的intercept方法中创建。先看一下intercept方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(), createAddress(request.url()),</span><br><span class="line">        call, eventListener, callStackTrace);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// 路由异常后的重试，要求request还未发送出去</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 连接到服务器的异常重试，要求request还未发送出去。</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">        <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(<span class="keyword">null</span>)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Request followUp = followUpRequest(response);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">            createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">            + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下其中的followUpRequest(Response)方法，可以看到这里主要是根据Http请求响应的状态码来决定是否有重定向，如果有就使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据响应的状态码，判断是否需要进行重定向跟踪还是处理超时。如果不需要或不能重定向，则返回Null.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Request <span class="title">followUpRequest</span><span class="params">(Response userResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    Connection connection = streamAllocation.connection();</span><br><span class="line">    Route route = connection != <span class="keyword">null</span></span><br><span class="line">        ? connection.route()</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String method = userResponse.request().method();</span><br><span class="line">    <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">      <span class="keyword">case</span> HTTP_PROXY_AUTH:</span><br><span class="line">        Proxy selectedProxy = route != <span class="keyword">null</span></span><br><span class="line">            ? route.proxy()</span><br><span class="line">            : client.proxy();</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> HTTP_UNAUTHORIZED:</span><br><span class="line">        <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> HTTP_PERM_REDIRECT:</span><br><span class="line">      <span class="keyword">case</span> HTTP_TEMP_REDIRECT:</span><br><span class="line">        <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">        <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">        <span class="keyword">if</span> (!method.equals(<span class="string">"GET"</span>) &amp;&amp; !method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fall-through</span></span><br><span class="line">      <span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line">      <span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line">      <span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line">      <span class="keyword">case</span> HTTP_SEE_OTHER:</span><br><span class="line">        <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">        <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String location = userResponse.header(<span class="string">"Location"</span>);</span><br><span class="line">        <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">        <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">        <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Most redirects don't include a request body.</span></span><br><span class="line">        Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">          <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">            requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">            requestBuilder.method(method, requestBody);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">        <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">        <span class="comment">// way to retain them.</span></span><br><span class="line">        <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">          requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</span><br><span class="line">        <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">        <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">        <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">          <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userResponse.request();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>关于失败重试部分，需要注意的是<strong>OKHttp里默认的重试机制可只捕获RouteException和IOException，并且重试还有更多的限制要求，比如不能重复发送未buffered的request、带body的request需要在发送之前才能重试等</strong>。具体看recover方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 试着从一个失败中恢复与服务器的通信。如果Exception是可恢复的那么返回true，否则返回false。带有请求体body的request只有在body被缓存(buffered)或者失败发生于request被发送出去之前才能尝试恢复。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">    streamAllocation.streamFailed(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了不需要重试，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果网络请求已经开始，并且body内容只可以发送一次</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; userRequest.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会重试的类型：协议异常、Socketet异常并且网络情况还没开始，ssl认证异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有更多的路由可供尝试</span></span><br><span class="line">    <span class="keyword">if</span> (!streamAllocation.hasMoreRoutes()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于失败重试，使用在一个新的connection上使用同一个路由选择器Route Selector.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下路由相关的几个类Route、RouteSelector和RouteDatabase</p>
<h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p>首先明白一点，IP和DNS之间并没有直接关系，IP是一个网络传输协议，DNS是域名解析服务。<strong>一个域名使用DNS可能会解析到多台服务器IP，如果服务器做了负载冗余，那么当其中一台服务器挂了以后，可以无痕切换到别的服务器。</strong><font color="#dd0000"><strong>一个域名对应多个IP是OKHttp重试及路由的基础</strong></font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由实体类用来和一个抽象的原始服务器建立连接。当创建一个连接时，客户端可能有多个选择：</span></span><br><span class="line"><span class="comment"> 	 HTTP Proxy：一个代理服务器可以多种形式：</span></span><br><span class="line"><span class="comment"> 	  HTTP代理：一个客户端可能指定了一个代理服务器。否则将使用ProxySelector，ProxySelector可能会返回多个需要重试的代理。</span></span><br><span class="line"><span class="comment"> 	  IP地址：不管是通过IP直连到一个代理服务器还是原始服务器，每打开一个Sokcet连接就需要一个IP地址。而DNS服务器可能会返回多个IP地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Address address;</span><br><span class="line">  <span class="keyword">final</span> Proxy proxy;</span><br><span class="line">  <span class="keyword">final</span> InetSocketAddress inetSocketAddress;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Route</span><span class="params">(Address address, Proxy proxy, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"address == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"proxy == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inetSocketAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"inetSocketAddress == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">    <span class="keyword">this</span>.inetSocketAddress = inetSocketAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Address <span class="title">address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回当前路由的代理。Returns the &#123;<span class="doctag">@link</span> Proxy&#125; of this route.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;strong&gt;Warning:&lt;/strong&gt; This may disagree with &#123;<span class="doctag">@link</span> Address#proxy&#125; when it is null. When</span></span><br><span class="line"><span class="comment">   * the address's proxy is null, the proxy selector is used.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Proxy <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">socketAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inetSocketAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns true if this route tunnels HTTPS through an HTTP proxy. See &lt;a</span></span><br><span class="line"><span class="comment">   * href="http://www.ietf.org/rfc/rfc2817.txt"&gt;RFC 2817, Section 5.2&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requiresTunnel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address.sslSocketFactory != <span class="keyword">null</span> &amp;&amp; proxy.type() == Proxy.Type.HTTP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(@Nullable Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> other <span class="keyword">instanceof</span> Route</span><br><span class="line">        &amp;&amp; ((Route) other).address.equals(address)</span><br><span class="line">        &amp;&amp; ((Route) other).proxy.equals(proxy)</span><br><span class="line">        &amp;&amp; ((Route) other).inetSocketAddress.equals(inetSocketAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + address.hashCode();</span><br><span class="line">    result = <span class="number">31</span> * result + proxy.hashCode();</span><br><span class="line">    result = <span class="number">31</span> * result + inetSocketAddress.hashCode();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Route&#123;"</span> + inetSocketAddress + <span class="string">"&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Route是描述网络数据包传输的路径，最主要还是描述直接与其建立TCP连接的目标端点。对于设置了HTTP代理，且安全的连接 (SSL) 需要请求代理服务器建立一个到目标HTTP服务器的隧道连接，客户端与HTTP代理建立TCP连接，以此请求HTTP代理服务在客户端与HTTP服务器之间进行数据的盲转发。</p>
<h4 id="RouteSelector"><a href="#RouteSelector" class="headerlink" title="RouteSelector"></a>RouteSelector</h4><p>HTTP请求处理过程中所需的TCP连接建立过程，主要是找到一个Route，然后依据代理协议规则与特定目标建立TCP连接。对于无代理的情况，是与HTTP服务器建立TCP连接，对于SOCKS代理和http代理，是与代理服务器建立tcp连接，虽然都是与代理服务器建立tcp连接，但是SOCKS代理协议和http代理协议又有一定的区别。<br> 而且借助于域名做负均衡已经是网络中非常常见的手法了，因而，常常会有域名对应不同IP地址的情况。同时相同系统也可以设置多个代理，这使Route的选择变得非常复杂。<br> 在OKHTTP中，对Route连接有一定的错误处理机制。OKHTTP会逐个尝试找到Route建立TCP连接，直到找到可用的哪一个。这样对Route信息有良好的管理。OKHTTP中借助RouteSelector类管理所有路由信息，并帮助选择路由。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Address address;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RouteDatabase routeDatabase;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The most recently attempted route. */</span></span><br><span class="line">  <span class="keyword">private</span> Proxy lastProxy;</span><br><span class="line">  <span class="keyword">private</span> InetSocketAddress lastInetSocketAddress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* State for negotiating the next proxy to use. */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Proxy&gt; proxies = Collections.emptyList();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nextProxyIndex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* State for negotiating the next socket address to use. */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;InetSocketAddress&gt; inetSocketAddresses = Collections.emptyList();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nextInetSocketAddressIndex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* State for negotiating failed routes */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Route&gt; postponedRoutes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RouteSelector</span><span class="params">(Address address, RouteDatabase routeDatabase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.routeDatabase = routeDatabase;</span><br><span class="line"></span><br><span class="line">    resetNextProxy(address.url(), address.proxy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Prepares the proxy servers to try. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextProxy</span><span class="params">(HttpUrl url, Proxy proxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//第一种方式</span></span><br><span class="line">      <span class="comment">// If the user specifies a proxy, try that and only that.</span></span><br><span class="line">      proxies = Collections.singletonList(proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//第二种方式</span></span><br><span class="line">      <span class="comment">// Try each of the ProxySelector choices until one connection succeeds.</span></span><br><span class="line">      List&lt;Proxy&gt; proxiesOrNull = address.proxySelector().select(url.uri());</span><br><span class="line">      proxies = proxiesOrNull != <span class="keyword">null</span> &amp;&amp; !proxiesOrNull.isEmpty()</span><br><span class="line">          ? Util.immutableList(proxiesOrNull)</span><br><span class="line">          : Util.immutableList(Proxy.NO_PROXY);</span><br><span class="line">    &#125;</span><br><span class="line">    nextProxyIndex = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RouteDatabase"><a href="#RouteDatabase" class="headerlink" title="RouteDatabase"></a>RouteDatabase</h4><p>当在创建与目标地址的链接时，为了避免重复出现路由故障而创建的黑名单，如果尝试链接特定的IP或者代理服务器最后失败了，将记住这些故障。<strong>之后进行IP重试时，会通过shouldPostpone()方法将RouteDatabase中的路由路径延迟执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Route&gt; failedRoutes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Records a failure connecting to &#123;<span class="doctag">@code</span> failedRoute&#125;. */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Route failedRoute)</span> </span>&#123;</span><br><span class="line">   failedRoutes.add(failedRoute);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Records success connecting to &#123;<span class="doctag">@code</span> failedRoute&#125;. */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Route route)</span> </span>&#123;</span><br><span class="line">   failedRoutes.remove(route);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Returns true if &#123;<span class="doctag">@code</span> route&#125; has failed recently and should be avoided. */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">shouldPostpone</span><span class="params">(Route route)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> failedRoutes.contains(route);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p>作为用户代码和网络请求的代码的桥梁。首先它会基于用户的request创建一个网络request。然后它会处理网络调用。最后它会将网络response构成用户需要的Reponse。简单来说，就是<font color="#dd0000"><strong>处理请求的编码、Cookie、GZip解压缩等问题</strong></font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作为用户代码和网络请求的代码的桥梁。首先它会基于用户的request创建一个网络request。然后它会处理网络调用。最后它会将网络response构成用户需要的Reponse。</span></span><br><span class="line"><span class="comment"> Bridges from application code to network code. First it builds a network request from a user request. Then it proceeds to call the network. Finally it builds a user response from the network response.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CookieJar cookieJar;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BridgeInterceptor</span><span class="params">(CookieJar cookieJar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cookieJar = cookieJar;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns a 'Cookie' HTTP request header with all cookies, like &#123;<span class="doctag">@code</span> a=b; c=d&#125;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">cookieHeader</span><span class="params">(List&lt;Cookie&gt; cookies)</span> </span>&#123;</span><br><span class="line">    StringBuilder cookieHeader = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = cookies.size(); i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cookieHeader.append(<span class="string">"; "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Cookie cookie = cookies.get(i);</span><br><span class="line">      cookieHeader.append(cookie.name()).append(<span class="string">'='</span>).append(cookie.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieHeader.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>原理和注意事项：</p>
<p>1、原理<br> (1)、okhttp的网络缓存是基于http协议，不清楚请仔细看上一篇文章<br> (2)、使用DiskLruCache的缓存策略，具体请看本片文章的第一章节<br> 2、注意事项：<br> 1、目前只支持GET，其他请求方式需要自己实现。<br> 2、需要服务器配合，通过head设置相关头来控制缓存<br> 3、创建OkHttpClient时候需要配置Cache</p>
<p>(二)流程：</p>
<p>1、如果配置了缓存，则从缓存中取出(可能为null)<br> 2、获取缓存的策略.<br> 3、监测缓存<br> 4、如果禁止使用网络(比如飞行模式),且缓存无效，直接返回<br> 5、如果缓存有效，使用网络，不使用网络<br> 6、如果缓存无效，执行下一个拦截器<br> 7、本地有缓存、根据条件判断是使用缓存还是使用网络的response<br> 8、把response缓存到本地</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConnecInterceptor"><a href="#ConnecInterceptor" class="headerlink" title="ConnecInterceptor"></a>ConnecInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Opens a connection to the target server and proceeds to the next interceptor. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过streamAllocation的newStream方法获取一个流(HttpCodec 是个接口，根据协议的不同，由具体的子类的去实现)，第二步就是获取对应的RealConnection。</p>
<p>StreamAllocation的newStream()内部其实是通过findHealthyConnection()方法获取一个RealConnection，而在findHealthyConnection()里面通过一个while(true)死循环不断去调用findConnection()方法去找RealConnection.而在findConnection()里面其实是真正的寻找RealConnection，而上面提到的findHealthyConnection()里面主要就是调用findConnection()然后去验证是否是”健康”的。</p>
<p>在findConnection()里面主要是通过3重判断：1如果有已知连接且可用，则直接返回，2如果在连接池有对应address的连接，则返回，3切换路由再在连接池里面找下，如果有则返回，如果上述三个条件都没有满足，则直接new一个RealConnection。</p>
<p>然后开始握手，握手结束后，把连接加入连接池，如果在连接池有重复连接，和合并连接。</p>
<h4 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h4><p>真正的操作网络请求的流对象的接口，具体实现由Http1Codec、Http2Codec。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request;</span><br><span class="line"><span class="keyword">import</span> okhttp3.Response;</span><br><span class="line"><span class="keyword">import</span> okhttp3.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> okio.Sink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 编码HTTP请求，解密HTTP响应 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 废弃一个输入流的耗时超时时间。因为本身是为了复用connection，所以这个超时时间应该小于建立一次连接的耗时才有意义。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> DISCARD_STREAM_TIMEOUT_MILLIS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 返回一个输出流Sink，用来存放request body */</span></span><br><span class="line">  <span class="function">Sink <span class="title">createRequestBody</span><span class="params">(Request request, <span class="keyword">long</span> contentLength)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** This should update the HTTP engine's sentRequestMillis field. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 将request刷入底层的socket. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">flushRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Flush the request to the underlying socket and signal no more bytes will be transmitted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finishRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Parses bytes of a response header from an HTTP transport.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expectContinue true to return null if this is an intermediate response with a "100"</span></span><br><span class="line"><span class="comment">   *     response code. Otherwise this method never returns null.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Response.<span class="function">Builder <span class="title">readResponseHeaders</span><span class="params">(<span class="keyword">boolean</span> expectContinue)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns a stream that reads the response body. */</span></span><br><span class="line">  <span class="function">ResponseBody <span class="title">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.</span></span><br><span class="line"><span class="comment">   * That may happen later by the connection pool thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p>在OkHttp里面读取数据主要是通过以下四个步骤来实现的</p>
<ul>
<li>1 写入请求头</li>
<li>2 写入请求体</li>
<li>3 读取响应头</li>
<li>4 读取响应体</li>
</ul>
<p>OkHttp的流程是完全独立的。同样读写数据月是交给相关的类来处理，就是<strong>HttpCodec</strong>(解码器)来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">   HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">   StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">   RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">   Request request = realChain.request();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">//写入请求头</span></span><br><span class="line">   httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">   Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">     <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return what</span></span><br><span class="line">     <span class="comment">// we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">       httpCodec.flushRequest();</span><br><span class="line">       responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//写入请求体</span></span><br><span class="line">     <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">       Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">       BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">       request.body().writeTo(bufferedRequestBody);</span><br><span class="line">       bufferedRequestBody.close();</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">       <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from</span></span><br><span class="line">       <span class="comment">// being reused. Otherwise we're still obligated to transmit the request body to leave the</span></span><br><span class="line">       <span class="comment">// connection in a consistent state.</span></span><br><span class="line">       streamAllocation.noNewStreams();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   httpCodec.finishRequest();</span><br><span class="line">   <span class="comment">//读取响应头</span></span><br><span class="line">   <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">     responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Response response = responseBuilder</span><br><span class="line">       .request(request)</span><br><span class="line">       .handshake(streamAllocation.connection().handshake())</span><br><span class="line">       .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">       .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">       .build();</span><br><span class="line">   <span class="comment">//读取响应体</span></span><br><span class="line">   <span class="keyword">int</span> code = response.code();</span><br><span class="line">   <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">     <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">     response = response.newBuilder()</span><br><span class="line">         .body(Util.EMPTY_RESPONSE)</span><br><span class="line">         .build();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     response = response.newBuilder()</span><br><span class="line">         .body(httpCodec.openResponseBody(response))</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">       || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">     streamAllocation.noNewStreams();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">         <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> response;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>缓存实际上是一个比较复杂的逻辑，单独的功能块，实际上不属于OKhttp上的功能，实际上是通过是http协议和DiskLruCache做了处理。</p>
<p>LinkedHashMap可以实现LRU算法，并且在这个case里，它被用作对DiskCache的内存索引<br> 告诉你们一个秘密，Universal-Imager-Loader里面的DiskLruCache的实现跟这里的一模一样，除了io使用inputstream/outputstream<br> 使用LinkedHashMap和journal文件同时记录做过的操作，其实也就是有索引了，这样就相当于有两个备份，可以互相恢复状态<br> 通过dirtyFiles和cleanFiles，可以实现更新和读取同时操作，在commit的时候将cleanFiles的内容进行更新就好了</p>
<p>还是先从缓存拦截器说起吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Serves requests from the cache and writes responses to the cache. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(InternalCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(<span class="number">504</span>)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Response <span class="title">stripBody</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response != <span class="keyword">null</span> &amp;&amp; response.body() != <span class="keyword">null</span></span><br><span class="line">        ? response.newBuilder().body(<span class="keyword">null</span>).build()</span><br><span class="line">        : response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a new source that writes bytes to &#123;<span class="doctag">@code</span> cacheRequest&#125; as they are read by the source</span></span><br><span class="line"><span class="comment">   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span></span><br><span class="line"><span class="comment">   * may never exhaust the source stream and therefore not complete the cached response.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Response <span class="title">cacheWritingResponse</span><span class="params">(<span class="keyword">final</span> CacheRequest cacheRequest, Response response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Some apps return a null body; for compatibility we treat that like a null cache request.</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="keyword">null</span>) <span class="keyword">return</span> response;</span><br><span class="line">    Sink cacheBodyUnbuffered = cacheRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (cacheBodyUnbuffered == <span class="keyword">null</span>) <span class="keyword">return</span> response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BufferedSource source = response.body().source();</span><br><span class="line">    <span class="keyword">final</span> BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);</span><br><span class="line"></span><br><span class="line">    Source cacheWritingSource = <span class="keyword">new</span> Source() &#123;</span><br><span class="line">      <span class="keyword">boolean</span> cacheRequestClosed;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> bytesRead;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          bytesRead = source.read(sink, byteCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">            cacheRequestClosed = <span class="keyword">true</span>;</span><br><span class="line">            cacheRequest.abort(); <span class="comment">// Failed to write a complete cache response.</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">            cacheRequestClosed = <span class="keyword">true</span>;</span><br><span class="line">            cacheBody.close(); <span class="comment">// The cache response is complete!</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);</span><br><span class="line">        cacheBody.emitCompleteSegments();</span><br><span class="line">        <span class="keyword">return</span> bytesRead;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source.timeout();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheRequestClosed</span><br><span class="line">            &amp;&amp; !discard(<span class="keyword">this</span>, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">          cacheRequestClosed = <span class="keyword">true</span>;</span><br><span class="line">          cacheRequest.abort();</span><br><span class="line">        &#125;</span><br><span class="line">        source.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    String contentType = response.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">    <span class="keyword">long</span> contentLength = response.body().contentLength();</span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(<span class="keyword">new</span> RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Headers <span class="title">combine</span><span class="params">(Headers cachedHeaders, Headers networkHeaders)</span> </span>&#123;</span><br><span class="line">    Headers.Builder result = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = cachedHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      String fieldName = cachedHeaders.name(i);</span><br><span class="line">      String value = cachedHeaders.value(i);</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"Warning"</span>.equalsIgnoreCase(fieldName) &amp;&amp; value.startsWith(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// Drop 100-level freshness warnings.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Internal.instance.addLenient(result, fieldName, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = networkHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      String fieldName = networkHeaders.name(i);</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"Content-Length"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// Ignore content-length headers of validating responses.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isEndToEnd(fieldName)) &#123;</span><br><span class="line">        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns true if &#123;<span class="doctag">@code</span> fieldName&#125; is an end-to-end HTTP header, as defined by RFC 2616,</span></span><br><span class="line"><span class="comment">   * 13.5.1.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEndToEnd</span><span class="params">(String fieldName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="string">"Connection"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"Keep-Alive"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"Proxy-Authenticate"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"Proxy-Authorization"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"TE"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"Trailers"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"Transfer-Encoding"</span>.equalsIgnoreCase(fieldName)</span><br><span class="line">        &amp;&amp; !<span class="string">"Upgrade"</span>.equalsIgnoreCase(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h4><h4 id="Okio"><a href="#Okio" class="headerlink" title="Okio"></a>Okio</h4><h4 id="清除线程"><a href="#清除线程" class="headerlink" title="清除线程"></a>清除线程</h4><h3 id="连接复用机制"><a href="#连接复用机制" class="headerlink" title="连接复用机制"></a>连接复用机制</h3><p>连接方式分为隧道连接和Socket连接，几个关键类：</p>
<ul>
<li>Call</li>
<li>StreamAllocation</li>
<li>RealConnection</li>
<li>ConnectionPool</li>
</ul>
<h5 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个Call代表一个请求已经准备好可以请求了。Call可以被取消。因为这个对象代表了一个请求/响应对，所以它不能被执行两次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 返回当前Call对应的最原始的请求对象 */</span></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 立刻触发请求，并且会阻塞知道返回响应或者发生错误。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 安排请求在未来的时间中执行。OkHttpClient#Dispatch会安排好任务在合适执行。这个方法会通过responseCallback回调响应结果给调用方。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 在可能的情况下取消请求，如果请求已经完成则不能被取消。 */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 不管Call被执行了execute还是enqueue都会返回true。执行一个Call两次是不对的。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 复制一个已经存在的Call，得到一个可以执行的Call。</span></span><br><span class="line"><span class="comment">   Create a new, identical call to this one which can be enqueued or executed even if this call has already been.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StreamAllocation"><a href="#StreamAllocation" class="headerlink" title="StreamAllocation"></a>StreamAllocation</h5><p>如何理解StreamAllocation这个OKHttp3中自定义的类？先看一段官方的翻译：</p>
<p>[<strong>翻译-Start</strong>：StreamAllocation协调Connections、Streams、Calls三者之间的关系：</p>
<p>Connections：<strong>物理的Socket连接</strong>。因为建立一个连接可能会很慢，所以需要有能力来取消一个已经建立连接的连接。</p>
<p>Streams：<strong>逻辑上的HTTP 请求/响应对</strong>，位于Connections层智商。每一个连接都有它自己的分配(allocation)限制，用于定义同一个连接上最多支持的流的数量。HTTP/1.x最多一个分配1个流。而HTTP/2可以分配多个，这也就是所谓的连接的多路复用。</p>
<p>Calls：<strong>逻辑上的流的序列</strong>，通常是一个初始请求已经之后触发的多个请求。我们提倡在一个连接上管理一个Call的所有Stream。</p>
<p>StreamAllocation的实例可以用来代表了Call，在一个或多个Connection上使用一个或多个Stream。这个类提供了API用来释放这些资源：</p>
<ul>
<li>noNewStreams()：防止一个连接被新创建的流使用。</li>
<li>streamFinished()：释放分配池(allocation)中的活跃的stream。注意每次只有一个stream处于活跃状态，如果想要新启一个stream，需要先调用streamFinished()来释放当前stream。</li>
<li>release()：移除Call持有的connection。注意当一个流还在使用，那么connection不会立即被释放。<strong>翻译-FIN</strong>]</li>
</ul>
<p>他封装了网络请求相关的信息：连接池，地址信息，网络请求，事件回调，负责网络连接的连接、关闭，释放等操作。好像还是不太懂，因为翻译的不好，或者不够简洁。<font color="#dd0000"><strong>简单的用白话表述就是StreamAllocation是Connections、Streams、Calls之间的桥梁。一个Call可能对应多个Stream，而一个Stream必须依赖于一个Connection。StreamAllocation就是负责为请求的Call寻找合适的Connection，并管理Stream</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAllocation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Address address;</span><br><span class="line">  <span class="keyword">private</span> RouteSelector.Selection routeSelection;</span><br><span class="line">  <span class="keyword">private</span> Route route;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConnectionPool connectionPool;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Call call;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object callStackTrace;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State guarded by connectionPool.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RouteSelector routeSelector;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> refusedStreamCount;</span><br><span class="line">  <span class="keyword">private</span> RealConnection connection;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> reportedAcquired;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> released;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line">  <span class="keyword">private</span> HttpCodec codec;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StreamAllocation</span><span class="params">(ConnectionPool connectionPool, Address address, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">      EventListener eventListener, Object callStackTrace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connectionPool = connectionPool;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    <span class="keyword">this</span>.call = call;</span><br><span class="line">    <span class="keyword">this</span>.eventListener = eventListener;</span><br><span class="line">    <span class="keyword">this</span>.routeSelector = <span class="keyword">new</span> RouteSelector(address, routeDatabase(), call, eventListener);</span><br><span class="line">    <span class="keyword">this</span>.callStackTrace = callStackTrace;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = chain.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        codec = resultCodec;</span><br><span class="line">        <span class="keyword">return</span> resultCodec;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 寻找一个健康的Connection，如果没找到，则会继续循环直到找到一个健康的Connection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> writeTimeout, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class="line">      <span class="comment">// isn't, take it out of the pool and start again.</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        noNewStreams();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回一个用于装载stream的connection。优先使用已经存在的connection，没有的话就从连接池中获取，再没有就重新构建一个。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    Connection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</span><br><span class="line">      <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class="line">      <span class="comment">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class="line">      releasedConnection = <span class="keyword">this</span>.connection;</span><br><span class="line">      toClose = releaseIfNoNewStreams();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We had an already-allocated connection and it's good.</span></span><br><span class="line">        result = <span class="keyword">this</span>.connection;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!reportedAcquired) &#123;</span><br><span class="line">        <span class="comment">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">        Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          selectedRoute = route;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">        <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">        <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">          Route route = routes.get(i);</span><br><span class="line">          Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, route);</span><br><span class="line">          <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">            result = connection;</span><br><span class="line">            <span class="keyword">this</span>.route = route;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        acquire(result, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">    result.connect(</span><br><span class="line">        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);</span><br><span class="line">    routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      reportedAcquired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Pool the connection.</span></span><br><span class="line">      Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class="line">      <span class="comment">// release this connection and acquire that one.</span></span><br><span class="line">      <span class="keyword">if</span> (result.isMultiplexed()) &#123;</span><br><span class="line">        socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</span><br><span class="line">        result = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Releases the currently held connection and returns a socket to close if the held connection</span></span><br><span class="line"><span class="comment">   * restricts new streams from being created. With HTTP/2 multiple requests share the same</span></span><br><span class="line"><span class="comment">   * connection so it's possible that our connection is restricted from creating new streams during</span></span><br><span class="line"><span class="comment">   * a follow-up request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Socket <span class="title">releaseIfNoNewStreams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line">    RealConnection allocatedConnection = <span class="keyword">this</span>.connection;</span><br><span class="line">    <span class="keyword">if</span> (allocatedConnection != <span class="keyword">null</span> &amp;&amp; allocatedConnection.noNewStreams) &#123;</span><br><span class="line">      <span class="keyword">return</span> deallocate(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">streamFinished</span><span class="params">(<span class="keyword">boolean</span> noNewStreams, HttpCodec codec, <span class="keyword">long</span> bytesRead, IOException e)</span> </span>&#123;</span><br><span class="line">    eventListener.responseBodyEnd(call, bytesRead);</span><br><span class="line"></span><br><span class="line">    Socket socket;</span><br><span class="line">    Connection releasedConnection;</span><br><span class="line">    <span class="keyword">boolean</span> callEnd;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (codec == <span class="keyword">null</span> || codec != <span class="keyword">this</span>.codec) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"expected "</span> + <span class="keyword">this</span>.codec + <span class="string">" but was "</span> + codec);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!noNewStreams) &#123;</span><br><span class="line">        connection.successCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      releasedConnection = connection;</span><br><span class="line">      socket = deallocate(noNewStreams, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span>) releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      callEnd = <span class="keyword">this</span>.released;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.callFailed(call, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callEnd) &#123;</span><br><span class="line">      eventListener.callEnd(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpCodec <span class="title">codec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">return</span> codec;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RouteDatabase <span class="title">routeDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Internal.instance.routeDatabase(connectionPool);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RealConnection <span class="title">connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Connection releasedConnection;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      releasedConnection = connection;</span><br><span class="line">      socket = deallocate(<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span>) releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Forbid new streams from being created on the connection that hosts this allocation. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noNewStreams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Connection releasedConnection;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      releasedConnection = connection;</span><br><span class="line">      socket = deallocate(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span>) releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Releases resources held by this allocation. If sufficient resources are allocated, the</span></span><br><span class="line"><span class="comment">   * connection will be detached or closed. Callers must be synchronized on the connection pool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Returns a closeable that the caller should pass to &#123;<span class="doctag">@link</span> Util#closeQuietly&#125; upon completion</span></span><br><span class="line"><span class="comment">   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Socket <span class="title">deallocate</span><span class="params">(<span class="keyword">boolean</span> noNewStreams, <span class="keyword">boolean</span> released, <span class="keyword">boolean</span> streamFinished)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamFinished) &#123;</span><br><span class="line">      <span class="keyword">this</span>.codec = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (released) &#123;</span><br><span class="line">      <span class="keyword">this</span>.released = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (noNewStreams) &#123;</span><br><span class="line">        connection.noNewStreams = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.codec == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.released || connection.noNewStreams)) &#123;</span><br><span class="line">        release(connection);</span><br><span class="line">        <span class="keyword">if</span> (connection.allocations.isEmpty()) &#123;</span><br><span class="line">          connection.idleAtNanos = System.nanoTime();</span><br><span class="line">          <span class="keyword">if</span> (Internal.instance.connectionBecameIdle(connectionPool, connection)) &#123;</span><br><span class="line">            socket = connection.socket();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpCodec codecToCancel;</span><br><span class="line">    RealConnection connectionToCancel;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      canceled = <span class="keyword">true</span>;</span><br><span class="line">      codecToCancel = codec;</span><br><span class="line">      connectionToCancel = connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (codecToCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">      codecToCancel.cancel();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connectionToCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">      connectionToCancel.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">streamFailed</span><span class="params">(IOException e)</span> </span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Connection releasedConnection;</span><br><span class="line">    <span class="keyword">boolean</span> noNewStreams = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e <span class="keyword">instanceof</span> StreamResetException) &#123;</span><br><span class="line">        StreamResetException streamResetException = (StreamResetException) e;</span><br><span class="line">        <span class="keyword">if</span> (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) &#123;</span><br><span class="line">          refusedStreamCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All</span></span><br><span class="line">        <span class="comment">// other errors must be retried on a new connection.</span></span><br><span class="line">        <span class="keyword">if</span> (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          noNewStreams = <span class="keyword">true</span>;</span><br><span class="line">          route = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection != <span class="keyword">null</span></span><br><span class="line">          &amp;&amp; (!connection.isMultiplexed() || e <span class="keyword">instanceof</span> ConnectionShutdownException)) &#123;</span><br><span class="line">        noNewStreams = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this route hasn't completed a call, avoid it for new connections.</span></span><br><span class="line">        <span class="keyword">if</span> (connection.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (route != <span class="keyword">null</span> &amp;&amp; e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            routeSelector.connectFailed(route, e);</span><br><span class="line">          &#125;</span><br><span class="line">          route = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      releasedConnection = connection;</span><br><span class="line">      socket = deallocate(noNewStreams, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span> || !reportedAcquired) releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Use this allocation to hold &#123;<span class="doctag">@code</span> connection&#125;. Each call to this must be paired with a call to</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> #release&#125; on the same connection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(RealConnection connection, <span class="keyword">boolean</span> reportedAcquired)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    <span class="keyword">this</span>.reportedAcquired = reportedAcquired;</span><br><span class="line">    connection.allocations.add(<span class="keyword">new</span> StreamAllocationReference(<span class="keyword">this</span>, callStackTrace));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Remove this allocation from the connection's list of allocations. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = connection.allocations.size(); i &lt; size; i++) &#123;</span><br><span class="line">      Reference&lt;StreamAllocation&gt; reference = connection.allocations.get(i);</span><br><span class="line">      <span class="keyword">if</span> (reference.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">        connection.allocations.remove(i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Release the connection held by this connection and acquire &#123;<span class="doctag">@code</span> newConnection&#125; instead. It is</span></span><br><span class="line"><span class="comment">   * only safe to call this if the held connection is newly connected but duplicated by &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * newConnection&#125;. Typically this occurs when concurrently connecting to an HTTP/2 webserver.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Returns a closeable that the caller should pass to &#123;<span class="doctag">@link</span> Util#closeQuietly&#125; upon completion</span></span><br><span class="line"><span class="comment">   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Socket <span class="title">releaseAndAcquire</span><span class="params">(RealConnection newConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line">    <span class="keyword">if</span> (codec != <span class="keyword">null</span> || connection.allocations.size() != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the old connection.</span></span><br><span class="line">    Reference&lt;StreamAllocation&gt; onlyAllocation = connection.allocations.get(<span class="number">0</span>);</span><br><span class="line">    Socket socket = deallocate(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire the new connection.</span></span><br><span class="line">    <span class="keyword">this</span>.connection = newConnection;</span><br><span class="line">    newConnection.allocations.add(onlyAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreRoutes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> route != <span class="keyword">null</span></span><br><span class="line">        || (routeSelection != <span class="keyword">null</span> &amp;&amp; routeSelection.hasNext())</span><br><span class="line">        || routeSelector.hasNext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RealConnection connection = connection();</span><br><span class="line">    <span class="keyword">return</span> connection != <span class="keyword">null</span> ? connection.toString() : address.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAllocationReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">StreamAllocation</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for</span></span><br><span class="line"><span class="comment">     * identifying the origin of connection leaks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object callStackTrace;</span><br><span class="line"></span><br><span class="line">    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) &#123;</span><br><span class="line">      <span class="keyword">super</span>(referent);</span><br><span class="line">      <span class="keyword">this</span>.callStackTrace = callStackTrace;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="RealConnection"><a href="#RealConnection" class="headerlink" title="RealConnection"></a>RealConnection</h5><h5 id="ConnectionPool"><a href="#ConnectionPool" class="headerlink" title="ConnectionPool"></a>ConnectionPool</h5><p>管理HTTP或HTTP/2上连接的重用，指向相同Address的请求将共享一个连接。这个类实现了保持连接打开以备将来重用。<font color="#dd0000"><strong>从源码中看到，默认的maxIdleConnections=5，默认的连接空闲存活时间是5分钟</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部使用基于SynchronousQueue的线程池用于存放清理任务(cleanupRunnable)。看一下cleanupRunnable的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到cleanupRunnable是一个死循环，不断的执行cleanup方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 维护连接池操作，当超过keep alive限制或者空闲连接限制时执行，移除一个空闲时间最长的connection。</span></span><br><span class="line"><span class="comment">   * 返回下次执行cleanup方法的时间，如果不再需要cleanup则返回-1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并移除一个connection，或者返回下次执行cleanup任务的时间</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果连接正在使用，跳过继续搜索下一个连接</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换对象，找出空闲时间最长的connection</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// 找到了一个可以移除的connection，从列表中移除，稍后在循环外关闭它</span></span><br><span class="line">        <span class="comment">//注意，走到这个分支，会return 0，意味着会立即执行下一次cleanup任务。</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回下一次进行cleanup的时间距离</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 所有的connection都在使用中，因此返回一个完整的cleanup任务间隔时间</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有任何连接，返回-1</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即重新执行cleanup任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>当你想要让一个以上的对象<strong>有机会</strong>能够处理某个请求的时候，可以使用责任链模式。<strong>链中的每个对象扮演处理器，并且有一个后继对象。它可以处理请求，也可以把请求转发给后继者。</strong></p>
<p>责任链的优点：</p>
<ul>
<li>将请求的发送者和接收者解耦</li>
<li>可以简化你的对象，因为它不需要知道链的结构。</li>
<li>通过改变链内的成员或调动他们的顺序，允许你动态地新增或删除责任。</li>
</ul>
<p>责任链的缺点：</p>
<ul>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
<li>并不能保证请求一定会被执行。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190424000014296.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2Mzg4ODM=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： <strong>TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）</strong>。传输层安全性协议（英语：Transport Layer Security，缩写作<strong>TLS</strong>），及其<font color="#dd0000"><strong>前身</strong></font><strong>安全套接层</strong>（Secure Sockets Layer，缩写作<strong>SSL</strong>）是一种安全协议，目的是互联网通信提供安全及数据完整性保障。</p>
<p>SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用<a href="https://baike.baidu.com/item/X.509" target="_blank" rel="noopener">X.509</a>认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（<a href="https://baike.baidu.com/item/Session%20key" target="_blank" rel="noopener">Session key</a>）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p>
<p>TLS协议采用<a href="https://baike.baidu.com/item/%E4%B8%BB%E4%BB%8E%E5%BC%8F%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">主从式架构</a>模型，用于在两个应用程序间透过网络创建起安全的连线，防止在交换数据时受到<a href="https://baike.baidu.com/item/%E7%AA%83%E5%90%AC" target="_blank" rel="noopener">窃听</a>及篡改。</p>
<p>TLS协议的优势是与高层的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener">应用层</a>协议（如<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener">HTTP</a>、<a href="https://baike.baidu.com/item/FTP" target="_blank" rel="noopener">FTP</a>、<a href="https://baike.baidu.com/item/Telnet" target="_blank" rel="noopener">Telnet</a>等）无耦合。应用层协议能透明地运行在TLS协议之上，由TLS协议进行创建加密通道需要的协商和认证。应用层协议传送的数据在通过TLS协议时都会被加密，从而保证通信的私密性。</p>
<p>TLS协议是可选的，必须配置客户端和服务器才能使用。主要有两种方式实现这一目标：一个是使用统一的TLS协议通信端口（例如：用于<a href="https://baike.baidu.com/item/HTTPS" target="_blank" rel="noopener">HTTPS</a>的端口443）；另一个是客户端请求服务器连接到TLS时使用特定的协议机制（例如：邮件、新闻协议和<a href="https://baike.baidu.com/item/STARTTLS" target="_blank" rel="noopener">STARTTLS</a>）。<font color="#dd0000"><strong>一旦客户端和服务器都同意使用TLS协议，他们通过使用一个握手过程协商出一个有状态的连接以传输数据</strong></font>。通过握手，客户端和服务器协商各种参数用于创建安全连接：</p>
<ul>
<li>当客户端连接到支持TLS协议的服务器要求创建安全连接并列出了受支持的密码组合（加密密码算法和加密哈希函数），握手开始。</li>
<li>服务器从该列表中决定加密和散列函数，并通知客户端。</li>
<li>服务器发回其数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的公钥。</li>
<li>客户端确认其颁发的证书的有效性。</li>
<li>为了生成会话密钥用于安全连接，客户端使用服务器的公钥加密随机生成的密钥，并将其发送到服务器，只有服务器才能使用自己的私钥解密。</li>
<li>利用随机数，双方生成用于加密和解密的对称密钥。这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭。如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接。</li>
</ul>
<h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><h5 id="EventListener"><a href="#EventListener" class="headerlink" title="EventListener"></a>EventListener</h5><p>提供可量化的指标，用于衡量应用中的HTTP请求的质量。提供如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventListener NONE = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> EventListener.<span class="function">Factory <span class="title">factory</span><span class="params">(<span class="keyword">final</span> EventListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventListener.Factory() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> EventListener <span class="title">create</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listener;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnsStart</span><span class="params">(Call call, String domainName)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnsEnd</span><span class="params">(Call call, String domainName, @Nullable List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectStart</span><span class="params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secureConnectStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secureConnectEnd</span><span class="params">(Call call, @Nullable Handshake handshake)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectEnd</span><span class="params">(Call call, InetSocketAddress inetSocketAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Proxy proxy, @Nullable Protocol protocol)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(Call call, InetSocketAddress inetSocketAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Proxy proxy, @Nullable Protocol protocol, @Nullable IOException ioe)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionAcquired</span><span class="params">(Call call, Connection connection)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionReleased</span><span class="params">(Call call, Connection connection)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestHeadersStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestHeadersEnd</span><span class="params">(Call call, Request request)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestBodyStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestBodyEnd</span><span class="params">(Call call, <span class="keyword">long</span> byteCount)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseHeadersStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseHeadersEnd</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseBodyStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseBodyEnd</span><span class="params">(Call call, <span class="keyword">long</span> byteCount)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callEnd</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFailed</span><span class="params">(Call call, IOException ioe)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NamedRunnable"><a href="#NamedRunnable" class="headerlink" title="NamedRunnable"></a>NamedRunnable</h5><p>是一个抽象类，继承了Runnable，为其扩展了一个name字段，并定义了抽象方法execute()。<font color="#dd0000"><strong>注意！！这里的run方法中调用了抽象方法execute()，因此在Dispatcher调度任务时执行executorService().execute(call)，其实就是执行NamedRunnable的抽象方法execute()</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runnable implementation which always sets its thread name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AsyncCall-amp-RealCall"><a href="#AsyncCall-amp-RealCall" class="headerlink" title="AsyncCall &amp; RealCall"></a>AsyncCall &amp; RealCall</h5><p>两个都继承了<strong>NamedRunnalbe</strong>，并实现了execute()方法，而AsyncCall是RealCall的内部类。两个的不同在于execute的实现，AsyncCall因为是异步任务，所以在<strong>execute方法中通过responseCallback接口对象中的onResponse和onFailure方法像调用方回传了请求结果</strong>。</p>
<p>下面看一下AsyncCall的源码，注意finally中的finished调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">      <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//调用finished方法，从运行中队列中移除当前Call，同时调用promoteCalls方法从等待队列中取得任务添加到运行中队列，并开始执行任务。</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>聊一下看完OKHTTP源码之后印象深刻的地方吧！</p>
<ol>
<li>要看懂OKHTTP的源码，首先还得比较了解Http协议，比如缓存机制需要知道的响应头有：<strong>expires，Cache-Control，Last-Modified，If-Modified-Since，ETag/If-None-Match</strong>；而在判断<strong>重定向</strong>时，如果服务器返回401，那么会回调Authenticator的authenticate方法，我们可以在构造OkHttpClient时重写该方法实现自己的验证逻辑。</li>
<li>使用队列管理同步任务、异步任务。控制并发数。</li>
<li>关于StreamAllocation、Call、Stream之间的关系，以及为什么要这么设计的理解</li>
<li>关于缓存的实现</li>
<li>关于连接复用的实现</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="noopener">OKHttp源码解析(一)—初阶</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/1c271d91529a" target="_blank" rel="noopener">okhttp源码解析（四）：重试机制</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/" data-id="ck82f1b6v002slu260l7r265p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java类库学习『ProtocolBuffers』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0%E3%80%8EProtocolBuffers%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.088Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0%E3%80%8EProtocolBuffers%E3%80%8F/">Java类库学习『ProtocolBuffers』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>protoBuf是一种灵活高效的独立于语言平台的结构化数据表示方法，与XML相比，protoBuf更小更快更简单。你可以用定义自己protoBuf的数据结构，用ProtoBuf编译器生成特定语言的源代码，如C++，Java，Python等，目前protoBuf对主流的编程语言都提供了支持,非常方便的进行序列化和反序列化。</p>
<p>特点：</p>
<ul>
<li>平台无关、语言无关。</li>
<li>二进制、数据自描述。</li>
<li>提供了完整详细的操作API。</li>
<li>高性能 比xml要快20-100倍</li>
<li>尺寸小 比xml要小3-10倍 高可扩展性</li>
<li>数据自描述、前后兼容</li>
</ul>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/angrycode/p/6238058.html" target="_blank" rel="noopener">在Android Studio配置google protobuf</a></p>
<p><a href="https://www.jianshu.com/p/e63082e9188d" target="_blank" rel="noopener">前端后台以及游戏中使用google-protobuf详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0%E3%80%8EProtocolBuffers%E3%80%8F/" data-id="ck82f1b5z001glu26dral9w4k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%EF%BC%8Cprotobuf/" rel="tag">数据转换，protobuf</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java进阶『Javassist学习笔记』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.088Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.javassist.org/" target="_blank" rel="noopener">http://www.javassist.org/</a></p>
<h3 id="文档翻译"><a href="#文档翻译" class="headerlink" title="文档翻译"></a>文档翻译</h3><ol>
<li><p>读取和写入字节码</p>
<p>Javassist是一个用于处理Java字节码的类库。Java字节码被存储在class文件中，每个class文件包含一个Java类或者接口。</p>
<p>Javassist.CtClass是一个class文件的抽象代表。一个CtClass对象可以(在编译期)用来处理一个class文件。以下面代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">"test.Point"</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure>

<p>这段代码首先获得一个ClassPool对象，ClassPool是CtClass所代表的class文件的容器。ClassPool会在构造CtClass对象时去读取class文件，并且持有构造好的CtClass对象以便之后使用。想要修改一个class，首先需要通过ClassPool获取到一个CtClass对象。ClassPool对象的get()方法可以用来实现这个目的。</p>
<p>从实现细节来说，ClassPool是一个以class的名字为key用来存储CtClass对象的哈希表，get()会从哈希表中根据传入的key查找CtClass对象。如果未能查找到缓存对象，get()方法会创建一个新的CtClass对象，并将这个新建的对象保存到哈希表中，然后返回给调用方。</p>
<p>从ClassPool中获取到的CtClass对象可以被修改，在上面的代码中，cc的superclass被修改成了test.Point。</p>
<p>writeFile()实现了从CtClass对象到class文件的转换，并将他写入到了本地磁盘。Javassist也提供了一种直接获取修改过的二进制代码的方法toBytecode()。除此之外，还可以直接载入CtClass：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clzzz = cc.toClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个新的class</p>
<p>可以使用makeClass创建一个新的class，之后可以使用CtNewMethod类中的方法创建方法，然后通过addMethod添加到创建的class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">"Point"</span>);</span><br></pre></td></tr></table></figure>

<p>要创建接口，需要使用makeInterface()</p>
</li>
<li><p>冻结的class</p>
<p>如果一个CtClass对象已经通过writeFile()，toClass()，或toBytecode()转换成一个class文件，那么Javassist会冻结Ctclass对象，不允许对Ctclass对象进行修改。这是为了提示开发者在JVM已经加载class文件后不能修改class文件。<strong>一个冰冻了的Ctclass可以通过defrost()方法解冻的方式来使能编辑。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;</span><br><span class="line">    :</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.defrost();</span><br><span class="line">cc.setSuperclass(...);    <span class="comment">// OK since the class is not frozen.</span></span><br></pre></td></tr></table></figure>

<p>如果ClassPool.doPruning被设置为true，那么Javassist会在冻结对象是进行CtClass对象的剪裁，以减少内存开销。想要禁用剪裁，需要调用stopPruning()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;</span><br><span class="line">cc.stopPruning(<span class="keyword">true</span>);</span><br><span class="line">    :</span><br><span class="line">cc.writeFile();                             <span class="comment">// convert to a class file.</span></span><br><span class="line"><span class="comment">// cc is not pruned.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类搜索路径</p>
<p>默认ClassPool.getDefault()从JVM的相同环境变量搜索类。但是如果程序运行在服务端，那么ClassPool对象就无法在用户的类搜索路径上找到目标类，此时可以通过insertClassPatch来增加类搜索路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>搜索路径不仅可以是本地路径，还可以是线上的路径</strong>，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure>

<p>除此之外，还可以直接传入byte数据来构造CtClass对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] b = a <span class="keyword">byte</span> array;</span><br><span class="line">String name = <span class="class"><span class="keyword">class</span> <span class="title">name</span></span>;</span><br><span class="line">cp.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, b));</span><br><span class="line">CtClass cc = cp.get(name);</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ol>
<li>如果想在运行期编辑类，给类添加方法，只能新增一个新的类。<strong>因为一个ClassLoader不能加载同一个类两次</strong>。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/" data-id="ck82f1b61001ilu267woxf7qx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『线程相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.087Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/">Java『线程相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Java『线程相关』### Java线程<br><strong>线程是进程中实施调度和分派的基本单位</strong>。一个进程可以包含多个线程，一个线程只能在一个进程的地址空间内活动。</p>
<h5 id="一、线程状态"><a href="#一、线程状态" class="headerlink" title="一、线程状态"></a>一、线程状态</h5><p>​    线程有6种状态，new，runnable，blocked，waiting(等待其他线程执行结束)，timed_waiting(等待其他线程结束，设定超时)，terminated(Thread类中一个State枚举了线程的所有状态）。</p>
<h5 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h5><ol>
<li>使用synchronized关键字修饰方法。由于java的<font color="#dd0000"><strong>每个对象都有一个内置锁</strong></font>，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。注： synchronized关键字也可以<font color="#dd0000"><strong>修饰静态方法</strong></font>，此时如果调用该静态方法，将会<font color="#dd0000"><strong>锁住整个类</strong></font>。</li>
<li>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。
        
          <p class="article-more-link">
            <a href="/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ck82f1b5y001elu26bwbtfo81" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java『Javap命令』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.086Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/">Java『Javap命令』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看JVM的运行时数据区，包括：虚拟机栈、程序计数器、本地方法栈、方法区和堆；其中虚拟机栈中存储的是栈帧，而栈帧是由<font color="#dd0000"><strong>局部变量表、操作数栈</strong></font>、动态链接、方法出口等组成。今天学习一下Javap命令，通过对字节码进行反编译来查看局部变量表的细节。</p>
<p>javap -v cclassName，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。<br>javap -l className，会输出行号和本地变量表信息。<br>javap -c className，会对当前class字节码进行反编译生成汇编代码。</p>
<ol>
<li>新建TreeNode.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用javac编译生成class文件</li>
<li>输入命令：javap -v TreeNode.class</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Classfile TreeNode<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">Last</span> <span class="title">modified</span> 2020-2-3</span>; size <span class="number">370</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">6</span>db15fb197ff5952f8b106978416b74a</span><br><span class="line">  Compiled from <span class="string">"TreeNode.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">leon</span>.<span class="title">LeetCode</span>.<span class="title">TreeNode</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#19         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#20         // com/leon/LeetCode/TreeNode.val:I</span><br><span class="line">   #3 = Class              #21            // com/leon/LeetCode/TreeNode</span><br><span class="line">   #4 = Class              #22            // java/lang/Object</span><br><span class="line">   #5 = Utf8               val</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               left</span><br><span class="line">   #8 = Utf8               Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">   #9 = Utf8               right</span><br><span class="line">  #10 = Utf8               &lt;init&gt;</span><br><span class="line">  #11 = Utf8               (I)V</span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line">  #13 = Utf8               LineNumberTable</span><br><span class="line">  #14 = Utf8               LocalVariableTable</span><br><span class="line">  #15 = Utf8               this</span><br><span class="line">  #16 = Utf8               x</span><br><span class="line">  #17 = Utf8               SourceFile</span><br><span class="line">  #18 = Utf8               TreeNode.java</span><br><span class="line">  #19 = NameAndType        #10:#23        // "&lt;init&gt;":()V</span><br><span class="line">  #20 = NameAndType        #5:#6          // val:I</span><br><span class="line">  #21 = Utf8               com/leon/LeetCode/TreeNode</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               ()V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode left;</span><br><span class="line">    descriptor: Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode right;</span><br><span class="line">    descriptor: Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.leon.LeetCode.TreeNode(<span class="keyword">int</span>);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         6: putfield      #2                  // Field val:I</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/leon/LeetCode/TreeNode;</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">1</span>     x   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>常见的字节码命令</p>
<table>
<thead>
<tr>
<th>Bytecode</th>
<th>Stackbefore-&gt;after</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>iconst_0</td>
<td>-&gt;0</td>
<td>Loads the int value 0 onto the stack //从栈中读取变量</td>
</tr>
<tr>
<td>istore_1</td>
<td>value-&gt;</td>
<td>Store int value into variable 1 //将变量压入栈</td>
</tr>
<tr>
<td>istore_2</td>
<td>value-&gt;</td>
<td>Store int value into variable 2 //将变量压入栈</td>
</tr>
<tr>
<td>iinc</td>
<td>No change</td>
<td>Increment local variable #index by signed byte const</td>
</tr>
<tr>
<td>iload_1</td>
<td>-&gt;value</td>
<td>Loads an int value from variable 1 //加载变量的值</td>
</tr>
<tr>
<td>iadd</td>
<td>value 1,value 2-&gt;result</td>
<td>Adds 2 ints together //将两个变量相加</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Java%E3%80%8EJavap%E5%91%BD%E4%BB%A4%E3%80%8F/" data-id="ck82f1b5v001blu26fju00szr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android项目『APPFrame』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E9%A1%B9%E7%9B%AE%E3%80%8EAPPFrame%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.081Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E9%A1%B9%E7%9B%AE%E3%80%8EAPPFrame%E3%80%8F/">Android项目『APPFrame』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GreenDao使用记录"><a href="#GreenDao使用记录" class="headerlink" title="GreenDao使用记录"></a>GreenDao使用记录</h3><p>一、3.2.2上目前只支持使用java类生成dao，不支持kotlin</p>
<p>二、报错：Caused by: org.greenrobot.greendao.DaoException: Could not init DAOConfig</p>
<p>解决：添加混淆规则：</p>
<p>-keep class org.greenrobot.greendao.<em>*{</em>;}<br>-keepclassmembers class * extends org.greenrobot.greendao.AbstractDao {<br>public static java.lang.String TABLENAME;<br>}<br>-keep class **$Properties<br>三、</p>
<h3 id="使用TitleBar"><a href="#使用TitleBar" class="headerlink" title="使用TitleBar"></a>使用TitleBar</h3><p>一、修改Activity的theme为NoActionBar</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"NoActionBar"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>二、添加menu.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;menu xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar_viewmode"</span></span><br><span class="line">        android:title=<span class="string">"练习"</span></span><br><span class="line">        app:showAsAction=<span class="string">"always"</span>/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar_quickclassify"</span></span><br><span class="line">        android:title=<span class="string">"分类"</span></span><br><span class="line">        app:showAsAction=<span class="string">"always"</span>/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar_sort"</span></span><br><span class="line">        android:title=<span class="string">"排序"</span></span><br><span class="line">        app:showAsAction=<span class="string">"always"</span>/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>



<p>三、添加布局元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">        android:id=<span class="string">"@+id/toolbar"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"?attr/actionBarSize"</span></span><br><span class="line">        android:background=<span class="string">"?attr/colorPrimary"</span></span><br><span class="line">        android:theme=<span class="string">"@style/ThemeOverlay.AppCompat.ActionBar"</span></span><br><span class="line">        app:popupTheme=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span></span><br><span class="line">        android:elevation=<span class="string">"4dp"</span></span><br><span class="line">        android:layout_marginTop=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_marginStart=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_marginEnd=<span class="string">"0dp"</span></span><br><span class="line">        app:menu=<span class="string">"@menu/base_main_activity_actions"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure>

<p>四、设置supportActionBar和listener</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setSupportActionBar(toolbar)</span><br><span class="line">toolbar.setNavigationOnClickListener(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>五、重写onOptionsItemSelected和onCreateOptionsMenu</p>
<h3 id="命令行查看数据库"><a href="#命令行查看数据库" class="headerlink" title="命令行查看数据库"></a>命令行查看数据库</h3><ol>
<li>选择一个root过的手机，或者新建一个root过得模拟器，具体可以看命令行操作用户结尾的是#(已root)，还是$(未root)，或者提示pemisssion denied。</li>
<li>cd到databases文件目录。</li>
<li>使用adb shell命令，进入shell模式。</li>
<li>使用sqlite3命令选择数据库文件，如sqlite3 DBNAME.db。</li>
<li>使用.table查看当前选中数据库包含的数据表。</li>
<li>查看具体数据表的结构：.schema tableName</li>
<li>退出shell，.exit。</li>
</ol>
<h2 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h2><h3 id="体验优化"><a href="#体验优化" class="headerlink" title="体验优化"></a>体验优化</h3><ul>
<li><p>初始化数据库时，显示加载百分比进度条，暂定计算方式有两种</p>
<ul>
<li>当前处理行数 / 总行数</li>
<li>下载文件时，已经知道了要处理的单词数量。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E9%A1%B9%E7%9B%AE%E3%80%8EAPPFrame%E3%80%8F/" data-id="ck82f1b5o0013lu26240g0i23" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android知识点『换肤方案』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E6%8D%A2%E8%82%A4%E6%96%B9%E6%A1%88%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.080Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E6%8D%A2%E8%82%A4%E6%96%B9%E6%A1%88%E3%80%8F/">Android知识点『换肤方案』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android换肤在使用场景上可以分为静态换肤/动态换肤、应用内换肤/插件换肤。</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/b0253de8ac04" target="_blank" rel="noopener">Android换肤方案总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E6%8D%A2%E8%82%A4%E6%96%B9%E6%A1%88%E3%80%8F/" data-id="ck82f1b5l000xlu264z7zatz4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android知识点『适配相关』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E3%80%8F/" class="article-date">
  <time datetime="2020-03-19T07:54:49.080Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E3%80%8F/">Android『适配相关』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Android-ID"><a href="#Android-ID" class="headerlink" title="Android ID"></a>Android ID</h5><p>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String id = Settings.Secure.getString(mContext.getContentResolver(),</span><br><span class="line">                 Settings.Secure.ANDROID_ID);</span><br></pre></td></tr></table></figure>

<p>兼容问题：</p>
<p>In O, Android ID (Settings.Secure.ANDROID_ID or SSAID) has a different value for each app and each user on the device. Developers requiring a device-scoped identifier, should instead use a resettable identifier, such as Advertising ID, giving users more control. Advertising ID also provides a user-facing setting to limit ad tracking</p>
<p>Additionally in Android O:</p>
<ul>
<li>The ANDROID_ID value won’t change on package uninstall/reinstall, as long as the package name and signing key are the same. Apps can rely on this value to maintain state across reinstalls.</li>
<li>If an app was installed on a device running an earlier version of Android, the Android ID remains the same when the device is updated to Android O,<font color="#dd0000"><strong>unless the app is uninstalled and reinstalled.</strong></font> </li>
<li>The Android ID value only changes if the device is factory reset or if the signing key rotates between uninstall and reinstall events.</li>
<li>This change is only required for device manufacturers shipping with Google Play services and Advertising ID. <font color="#dd0000"><strong>Other device manufacturers may provide an alternative resettable ID or continue to provide ANDROID ID.</strong></font></li>
</ul>
<h5 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h5><h5 id="动态权限"><a href="#动态权限" class="headerlink" title="动态权限"></a>动态权限</h5><h5 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h5><h5 id="定位权限"><a href="#定位权限" class="headerlink" title="定位权限"></a>定位权限</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%8E%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E3%80%8F/" data-id="ck82f1b5m000zlu267po3hpn8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AnnotationProcessor/" rel="tag">AnnotationProcessor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/" rel="tag">Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava2/" rel="tag">RxJava2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jni/" rel="tag">jni</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ndk/" rel="tag">ndk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/" rel="tag">布局相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%EF%BC%8Cprotobuf/" rel="tag">数据转换，protobuf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">源码学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/AnnotationProcessor/" style="font-size: 10px;">AnnotationProcessor</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/RxJava2/" style="font-size: 13.33px;">RxJava2</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/jni/" style="font-size: 10px;">jni</a> <a href="/tags/ndk/" style="font-size: 10px;">ndk</a> <a href="/tags/%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/" style="font-size: 10px;">布局相关</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%EF%BC%8Cprotobuf/" style="font-size: 10px;">数据转换，protobuf</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">源码学习</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8EJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8F/">读书笔记『Java并发编程实战』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E3%80%8E%E8%85%BE%E8%AE%AFMMKV%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6%E3%80%8F/">开源项目『腾讯MMKV存储框架』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94OkHttp%E3%80%8E%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%8F/">OkHttp『源码学习-杂项』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/Java%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0%E3%80%8EProtocolBuffers%E3%80%8F/">Java类库学习『ProtocolBuffers』</a>
          </li>
        
          <li>
            <a href="/2020/03/19/Java%E8%BF%9B%E9%98%B6%E3%80%8EJavassist%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8F/">Java进阶『Javassist学习笔记』</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ > </script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>