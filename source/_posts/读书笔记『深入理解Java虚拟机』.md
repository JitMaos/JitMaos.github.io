---
title: 读书笔记『深入理解Java虚拟机』
tags: [读书笔记,JVM]
---

### 第1章 走进Java

**P11**：HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以`方法`为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别处罚标准编译和OSR(栈上替换)编译动作。(这点在第11章关于热点代码的描述中有再次提到)

**P15**：Dalvik VM并不是一个Java虚拟机，**它没有遵循Java虚拟机规范，不能直接执行Java的Class文件**，使用的是`寄存器架构`而不是JVM中常见的`栈架构`。但它执行的dex文件可以通过Class文件转化而来。在Android2.2上已提供即时编译器实现(JIT)，在执行性能上有了很大的提高。

### 第2章 Java内存区域与内存溢出异常

运行时数据区包括：程序计数器、虚拟机栈、本地方法栈、方法区(非堆)、堆。其中前三个为线程私有的。

**P39**：程序计数器

程序计数器是一块较小的内存空间，可以看作是`当前线程`所执行的字节码的**行号指示器**。字节码解释器工作时就是通过改变之歌计数器的值来选取下一条需要执行的字节码指令的。**程序计数器是线程私有的**，这很容易理解。如果正在执行的是Native方法，这个计数器值则为空。`程序计数器是内存区域中唯一Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域`(可能是因为它本身占据的内存很小吧)

<!-- more -->

**P40**：Java虚拟机栈

Java虚拟机栈也是线程私有的，**它的生命周期和线程相同，虚拟机栈描述的是方法执行的内存模型**，每个方法在执行时都会创建一个栈帧，用于存储`局部变量表、操作数栈、动态链接、方法出口等信息`(这些内容在第8章字节码执行引擎中详细展开，`本书的一个重点也在这里`)

​	局部变量表所需的内存空间在编译期就完成了分配，当进入一个方式，这个方法需要在占中分配多大的局部变量空间是**完全确定**的，在方法运行期间不会改变局部变量表的大小。

​	本地方法栈和虚拟机栈的作用非常相似，他们支之间的区别在于本地方法栈为本地Native方法服务。

**P41**：Java堆

Java堆是被所有线程共享的一块内存区域，此内存区域唯一的目的就是存放`对象实例`，**几乎**所有的对象实例都在这里分配内存(随着JIT和逃逸分析技术的发展，对象分配，标量替换优化技术导致了一些微妙的变化，逃逸分析在第11章有分析)。

Java堆是GC发生的主要区域，可以分为：新生代和老年代，或者：Eden、From Survivor、To Surviror(默认8:1:1)。

`方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器(JIT)编译后的代码等数据`。（JDK1.8以后取消了永久代，改为元空间，类的元信息被存储在元空间中，元空间没有使用堆内存)

运行时常量池是方法区的一部分(`在JDK1.6及以前是的；JDK1.7及以后将运行时常量池从方法区中移出，并在Java堆上开辟了一块区域用于存放常量池；`)。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项是常量池，`用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入运行时常量池中存放。`

**P44**：对象的创建

1. 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在`常量池`中定位到一个类的**符号引用**，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。分配对象内存可能存在**指针碰撞**的问题，解决方式有两种：一种是对分配内存空间的动作进行同步处理——时机上虚拟机采用CAS（在最后2章讲解的比较清楚）配上失败重试的方式保证更新操作的原子性；另一种是把内存分配动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB)。
3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。
4. 虚拟机要对对象进行必要的设置，如：这个对象属于哪个类，如何能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的`对象头`中。根据当前虚拟机的运行状态，如是否启用偏向锁(偏向锁在本书的最后有介绍)等，对象头会有不同的设置方式。

**P47**：对象的内存布局

在HotSpot虚拟机中，对象在内存布局分为3部分：对象头、实例说几句、对齐填充（非必需且无意义)。

对象头包含两部分信息：用于`存储对象自身运行时`数据(哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等，官方称之为**Mark Word**)；另一部分是`类型指针`，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**P56**：String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。`在JDK1.6及以前的版本中，常量池分配在永久代(方法区)中，JDK1.6之后分配到堆上`

### 第3章 垃圾收集器与内存分配策略

**P61**：运行时数据区，哪些需要GC，哪些不需要？

程序计数器、虚拟机栈、本地方法栈会随着线程的销毁而销毁，**栈中的栈帧亦会随着方法的退出而出栈，且栈帧中分配多少内存基本上在类结构确定下来时就已知了**，这几个区域不需要考虑垃圾回收。剩下的Java堆、方法区由于使用多少内存需要在运行期才能确实，所以他们是垃圾回收发生的主要场所。

**P64**：Java中可以作为GC Roots的`对象`

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象(书上写着本地变量表，应该就是局部变量表吧，局部变量表在第8章有详细介绍，用于存放方法参数和方法内部定义的局部变量)

2. 方法区中类静态属性引用的对象

3. 方法区中常量引用的对象

4. 本地方法栈中JNI（即一般说的Native方法）引用的对象

怎么理解这几种类型呢？可以设想一个引用无非出现在这几个地方，一是类的成员变量中，这个成员变量如果是静态的，或者是常量，就存储在方法区中。所以上边2，3两点。或者出现在方法中，可以是方法的参数，也可以是方法的局部变量，这就是第1，4两点所说的。`那么类的非static非final成员变量是GCRoots吗？`有网友写了测试代码可以看一下：[【证】:那些可作为GC Roots的对象](https://blog.csdn.net/u010798968/article/details/72835255)

**P65**：四种引用类型

**强引用**：类似"Object obj = new Object()"这类的引用，`只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象`。

**软引用**：对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行`第二次回收`。

**弱引用**：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。`当垃圾收集器工作时，无论内存当前内存是否足够，都会回收掉只被弱引用关联的对象`。

**虚引用**：一个对象是否存在虚引用，完全不会对其生存时间构成影响，也无法 通过虚引用来取得一个对象实例。`为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收器回收是收到一个系统通知`。

**P66**：生存还是死亡

即使在可达性分析算法中不可达的对象，也并非马上就会被回收。如果对象重写了finalize()方法，那么对象会被放置到一个叫F-Queue的队列中，之后由一个由虚拟机创建的Finalizer线程去执行，**这里的执行仅仅是触发finalize()方法，不保证等待finalize()方法结束，因为这样可以避免无限期阻塞F-Queue**。`如果对象在finalize()中重新绑定了GCRoot对象`，那么对象就又**活**了。

**P67**：`任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再次被执行`。

```java
class FinalizeEscapeGC_3_2 {

    public static FinalizeEscapeGC_3_2 SAVE_HOOK = null;

    public void isAlive() {
        System.out.println("yes ,i am still alive:)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC_3_2.SAVE_HOOK = this; //自救
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC_3_2();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        //因为finalize方法优先级很低，所以暂停1秒等待它
        Thread.sleep(1000);
        if(SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead:(");
        }
        //一样的代码再执行一次，这次失败了，因为对象的finalize()只能执行一次
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(1000);
        if(SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead:(");
        }
    }
}

================>>>
finalize method executed!
yes ,i am still alive:)
no, i am dead:(
```

**P69**：标记-清除 算法

标记处所有需要回收的对象，在标记完成后同意回收所有被标记的对象。有两个不足：**一是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后产生大量不连续的内存空间，导致无法分配大对象。**

**P70**：复制算法

将可用内存划分成大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉。

**HotSpot虚拟机将新生代划分为一个Eden区和两个Survivor区，他们的比例是：8:1:1。当回收时，将Eden和其中一个Survivor中存活的对象复制到另外一个Survivor上去**。如果Survivor空间不够时，需要依赖其他内存(这里指老年代)进行`分配担保`(Handle Promotion)。

**P71**：标记-整理 算法

和标记-清除算法不同的地方是，标记完可收回对象之后，先将存活对象移动到内存的一端，然后清理到其与的部分。

**P72**：一般Java堆分为新生代和老年代，在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清除**或**标记-整理**算法来进行回收。

**P73**：程序执行时并非在所有地方都能停顿下来开始GC，`只有到达安全点时才能暂停`。

**P76**：Serial收集器是最基本，发展历史最悠久的收集器。这个收集器是一个单线程的收集器。

**P77**：ParNew收集器其实就是Serial收集器的多线程版本。

**P79**：Parallel Scavenge收集器的特点是它的关注点和其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾回收时用户线程的停顿时间，**而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。**吞吐量=运行用户代码时间 / (运行用户代码时间+垃圾收集时间)

**P81**：CMS(Concurrent Mark Sweep，并发低停顿收集器）收集器是一种**以获取最短回收停顿时间**为目标的收集器。

**P84**：G1收集器是当今收集器技术发展的最前沿成果之一，在后台维护一个优先列表，每次根据允许的收集时间，<font color="#dd0000">**优先回收价值最大的Region**</font>。

**P91**：内存分配和回收策略

对象的内存分配，往大方向讲，就是在堆上分配。对象<font color="#dd0000">**主要**</font>分配在**新生代的Eden(如果Eden去没有足够空间进行分配是，会触发一次minor GC)**区上，如果启动了本地线程分配缓存，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。

**P93**：大对象直接进入老年代

所谓大对象，是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。

**P95**：长期存活的对象将进入老年代

虚拟机给**每个对象**定义了一个对象年龄(Age)计数器。对象在Survivor区中每**熬过**一次Minor GC，年龄就会增加1岁，当他的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中，对象的晋升阈值可以通过参数设置。

**P97**：动态对象年龄判定

虚拟机并不是永远地要求对象的年龄必须达到了晋升阈值时才能晋升到老年代，**如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一般，那么年龄大于等于改年龄的对象就可以直接进入老年代。**

**P98**：空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，虚拟机会查看HandlePromotionFailure是否允许担保失败，如果允许，则更具历史晋升到老年代的平均大小，判断是否进行Minor GC，如果有风险，则会进行一次Full GC。

扩展：Minor GC & Major GC & Full GC

**Minor GC**指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，<font color="#dd0000">**虽然它会触发stop-the-world，但是它的回收速度很快**</font>。

**Major GC**清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。

**Full GC**是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。<font color="#dd0000">**Full GC不等于Major GC，也不等于Minor GC+Major GC**</font>，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。





**P312**：对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。

```java
//编译不过，因为List<String>和List<Integer>在编译之后会被擦除，都变成了类型List<E>
class Test {
  public static void test(List<String> items) {
	}
	public static void test(List<Integer> items) {
	}
}

```

