---
title: Android学习『跨进程通信』
tags:
---

### 一、内核态和用户态

#### 1、内核态和用户态的简介

> - **内核态**：CPU可以访问内存所有数据，包括外围设备，例如硬盘、网卡，CPU可以将自己从一个程序切换到另外一个程序。
> - **用户态**:   <font color="#dd0000">**只能受限的访问内存，且不允许访问外围设备，占用CPU的能力被剥削，CPU资源可以被其他程序获取**</font>。

#### 2、为什么要有用户态和内核态

> 由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送网络，CPU划分出两个权限等级  ----用户态  和  内核态。

#### 3、用户态与内核态的切换

##### 3.1 切换简介

所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情，例如从硬盘读取数据，或者从键盘获取输入等。而唯一可以这这些事情的就是 **操作系统** ，所以这时候 **程序** 就需要先向 **操作系统** 请求，以 **程序** 的名字来执行这些操作。这时候就需要一个这样的机制：用户态 切换到 内核态，但是不能控制内核态中执行的执行这种机制叫做** 系统调用 **，在CPU中的实现称之为 "陷阱指令(Trap Instruction)"

##### 3.2 系统调用机制流程：

> - 1、用户态程序将一些数据值放在寄存器中，或者使用参数创建一个堆栈(stack frame)，以表明需要操作系统提供的服务。
> - 2、用户态程序执行陷阱指令
> - 3、CUP切换到内核态，并跳到内存指定位置的指令，这些指令是操作系统的一部分，他们具有内存保护，不可被用户态程序访问
> - 4、这些指令称之为 陷阱 (trap) 或者新系统调用处理器 ( system call hanlder )。他们会读取程序放入内存的数据参数，并执行程序请求的服务。
> - 5、系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。

### 二、红黑树

红黑树，顾名思义，红黑树的节点是有颜色概念的，即非红即黑，通过颜色的语速，红黑树为支持着二叉搜索树的平衡性。一个红黑树必须有下面5个特征

> - 1、节点是红色或黑色
> - 2、根是黑色
> - 3、所有叶子是黑色(叶子是NIL节点)
> - 4、每个红色节点的两个子节点都是黑色的(从每个叶子到跟的所有路径不能有两个连续的红色节点)
> - 5、从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

这些特征强制约束了红黑树的关键性质：从跟到叶子的最长可能路径不多于最短可能路径的两倍长(特征4保证了路径最长的情况为1红1黑，最短的情况为全黑，再结合特征5，可以推导出)。**结果是这个树大致上是平衡的**。因为比如插入、删除和查找操作中，操作某个值的最坏情况的时间都要求与树的高度成比例，<font color="#dd0000">**这个高度上的理论上限允许红黑树在最坏的情况都是高效的，而不同于普通的(二叉搜索树)**</font>

### 三、Linux的跨进程通信(IPC)概述

#### 1.跨进程通信(IPC)的目的

跨进程通信(IPC)的目的主要如下：

> - 数据传递
>    一个进程需要将它的数据发送给另外一个进程，发送的数据量在一个字节到几M字节之间
> - 共享数据
>    多个进程想要操作共享数据。
> - 通知事件
>    一个进程需要向另一个或一组进程发送消息，通知它(它们)发生了某种事件(如进程终止时要通知父进程)
> - 资源共享
>    多个进程之间共享资源。为了做到这一点，需要内核提供锁和同步机制
> - 进程控制
>    有些进程希望完全控制另一个进程的执行(如debug进程)，此时控制进程希望能够拦截另一个进程的所有步骤和异常，并能够及时知道它的状态改变。

#### 2.Linux 进程间通信(IPC)的发展

Linux中的进程间通信大体分为4类

> - 基于早期Unix的进程间通信：管道和信号
> - 基于System V的进程间通信：System V消息队列、System V 信号灯、System V 共享内存
> - 基于Socket 的进程间通信：socket
> - POSIX进程间通信：posix 消息队列、posix信号灯、posix共享内存



### 三、Android中进程通信的限制

#### 1. 静态成员和单利模式完全失效

Android系统为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配了一个独立的虚拟机，不同的虚拟机在内存上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类对象会产生多分副本

#### 2. 线程同步机制完全失效

#### 3. SharedPreferences的可靠性下降

因为SharePreference不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，这是因为SharedPreferences底层是通过读/写XML文件来实现的，并发写显然会出问题的，甚至并发读/写都有可能出问题。

#### 4. Application会多次创建

当一个组件跑在一个新的进程中，由于系统要再创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程。因此，相当于系统又把这个应用重新启动了一遍，既然重新启动了，那么自认会创建新的Applicatiaon。

### 四、Serializable和Parcelable接口

#### 1. Serializable接口

##### 1.1 Serializable简介

Serializable 是<font color="#dd0000">**Java**</font>所提供的一个序列化接口，它是一个<font color="#dd0000">**空接口**</font>，为对象提供标准的序列化和反序列化操作。

##### 1.2 SerialVersionUID的作用

> - 这个serialVersionUID是用来辅助序列化和反序列化的过程。原则上序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID一致才能成功的反序列化。
> - serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中(也可能是其他中介)，当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能会发生变化，这时候就无法正常的反序列化。会报如下错误:

```css
java.io.InvalidClassException
```

###### 所以当我们手动制订了它之后，就可以很大程度上避免了泛学历化过程的失败。

1、静态成员变量属于类，不属于对象，所以不会参与序列化的过程

2、用transient关键字编辑的成员变量不参与序列化的过程。

3、可以通过重写writeObject()和readObject()两个方法来重写系统默认的序列化和反序列化的过程。不过本人并不推荐

#### 2. Parcelable接口

Parcelable也是一个接口，只要实现了这个接口，一个类的对象就可以实现序列化和并且通过Intent和Binder传递。













参考：[隔壁老李头的跨进程通信IPC系列](<https://www.jianshu.com/p/36b488863bc0>)