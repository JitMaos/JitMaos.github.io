---
title: 基础算法100天
tags:
---

Day1 平衡二叉树相关内容

摘自：[详解什么是平衡二叉树（AVL）（修订补充版）](<https://mp.weixin.qq.com/s/AweeCscNoLM2kKRA6Q_U8A>)

1. 什么是平衡二叉树？

   在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的时间复杂度都是 <font color="#dd0000">**O(logn）**</font>。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。**平衡二叉树的设计依据在于在二叉树影响效率的主要是树的高度，而平衡二叉树可以将二叉树的高度保持在一种近似平衡的状态中，从而提高数据操作的效率**

2. 平衡二叉树的插入与删除

   首先插入分为四种旋转情况：

   1. 插入到左子树的左

   插入：首先了解左旋、右旋的概念

   删除：

## 二分查找

#### 解题方法总结

```java
[L ,R) //左闭右开
 
def binary_search(L,R):
	while L < R:
 		m = (L + R) >>> 1
 		if(f(m)):return m		# Optional
 		if g(m):
 			R = m			# new range[L,R)
    else
      L = m + 1		#new range[m+1,R)
  return L # or not found
```

#### 标准题目



#### 变形题目



## 动态规划

#### 解题方法总结



#### 标准题目

LC.70 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

> 解法：一维动态规划，状态转义方程：f(n) = f(n-1) + f(n-2)
>
> ```java
> public int climbStairs(int n) {
>     int[] cache = new int[n + 1];
>     cache[0] = 1;
>     cache[1] = 1;
>     for(int i=2;i<=n;i++) {
>         cache[i] = cache[i-1] + cache[i-2];
>     }
>     return cache[n];
> }
> ```

##### LC.746 使用最小花费爬楼梯
数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 示例 2:

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：

cost 的长度将会在 [2, 1000]。
每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。

#### 变形题目

##### LC.300 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

> 动态规划，f(n) = max{f(0) -> f(n-1)} + 1; 注意：跳过array[x] 比 array[n]大的f(n)
>
> ```java
> public int lengthOfLIS(int[] nums) {
> 
>     if(nums == null || nums.length < 1) {
>         return 0;
>     }
>     int[] cache = new int[nums.length];
>     cache[0] = 1;
>     for(int i=1;i<nums.length;i++) {
>         int max = 0;
>         for(int j=0;j<i;j++) {
>             if(nums[j] < nums[i] && max < cache[j]) {
>                 max = cache[j];
>             }
>         }
>         cache[i] = max + 1;
>     }
>     int ans = 0;
>     for(int k=0;k<cache.length;k++) {
>         if(cache[k] > ans) {
>             ans = cache[k];
>         }
>     }
>     return ans;
> }
> ```

#### 



## 排序算法



## 数组

### Map的key作为游标

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] failed = new int[2];
        if(nums == null || nums.length < 2) {
            return failed;
        }
        //Map：key是数组位置，value是和target的差值
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<nums.length;i++) {

            if(map.containsKey(nums[i])) {
                return new int[]{map.get(nums[i]),i};
            } else {
                map.put(target-nums[i],i);
            }
        }
        return failed;
    }
}
```

### 双游标



## 桶算法



## 树

### 二叉树的遍历

二叉树的介绍：https://www.cnblogs.com/lanhaicode/p/10358736.html

前序遍历：首先访问根结点，然后遍历左子树，最后遍历右子树（根->左->右）

中序遍历：首先遍历左子树，然后访问根节点，最后遍历右子树（左->根->右）

后序遍历：首先遍历左子树，然后遍历右子树，最后访问根节点（左->右->根）

1. #### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

   

2. 

3. 

## 图



## 位运算





## 搜索(深搜、广搜、启发式搜索)





## 其他知名算法

### KMP字符匹配算法



### 马拉车算法





##小技巧：

1. LeetCode.P007整数反转

   需要注意反转后的越界问题

   ```java
   if(ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
   if(ans < Integer.MIN_VALUE/10 || (ans == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
   ```

2. LeetCode 875 1

   整数相除向上取整：被除数P 除以除数 M：

   ```java
   int result = (P + M - 1) / M; //如果P被M整除，加上(M-1)不影响结果；如果P不被M整数，加上(M-1)也不影响结果
   ```

3. LeetCode 875 2

   同样是875题，求两个数的中间值的一种高效写法。注意：

   `>>：带符号右移。正数右移高位补0，负数右移高位补1`。

   4 >> 1，结果是2；-4 >> 1，结果是-2。-2 >> 1，结果是-1。

   `>>>：无符号右移。无论是正数还是负数，高位通通补0`。

   ```java
   int m = (L + R) >>> 1
   ```

4. 判断两个数的符号是否相等

   ```java
   return ((a >> 31) ^ (b >> 31)) == 0;
   ```

5. 数组存储英文字母：

   ```java
   
   ```

6. 

