---
title: 读书笔记『C++简单程序设计』
tags:
---

##第二章 C++简单程序设计

**P27**：字符串中的每个字符占一个字节，**并在末尾添加'\0'作为结尾标记**。

```c++
sizeof("abc"); //4
```

**P32**：sizeof运算符用于计算某个类型的对象在内存中所占的字节数。

**按位与&**

00000011 & 00000101 = 00000001

**按位或|**

00000011 | 00000101 = 00000111

**按位异或^**

00111001 ^ 00100011 = 00010011

**P37**："<<"是预定义的**插入符**，作用在流类对象cout上便可以实现最一般的屏幕输出。

```c++
cout<<表达式1<<表达式2
```

最一般的键盘输入是将提取符作用在流对象cin上，要求从键盘上输入两个int，**以空格分隔**。

```c++
int a,b;
cin>>a>>b;
```

**P53**：使用typedef为**一个已知的数据类型另外命名**，这样有利于提高程序的可读性，给较长的类型名起一个短名。

```c++
typedef 已有类型名 新类型名表；
```

## 第三章 函数

**P65**：如果希望在定义一个函数前调用它，则需要在调用函数之前添加该函数的**函数原型**声明。<font color="#dd0000">**这点是和java不一定的地方**</font>。

```c++
类型说明符 函数名(含类型说明的形参表)
```

**P78**：<font color="#dd0000">**引用是一种特殊类型的变量，可以被认为是另一个变量的别名，**</font>通过引用名和通过被引用的变量名访问变量的效果是一样的。

**P81**：<font color="#dd0000">**内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处**</font>，内联函数应该是比较简单的函数，结构简单、语句少。

```c++
inline 类型说明符 函数名(含类型说明的形参表) {
  语句序列
}
```

**P82**：函数在定义时可以预先声明默认的形参值，有默认值的形参，不能出现在没有默认值的形参的左边。

```c++
int add(int x=5,int y=6) {
  return x + y;
}
```

**P87**：**include进来的头文件，有前缀c的表示该头文件继承自标准C的头文件**。为了保持对C程序的兼容性，C++中也允许继续使用这些以.h为后缀的文件。保留这些头文件仅仅是处于兼容性考虑，在编写C++程序时，**应尽量使用不带.h后缀的头文件。**

**P90**：运行栈实际上是一段区域的内存空间，与存储全局变量的空间无异，只是寻址的方式不同而已。**运行栈中的数据分为一个一个栈帧，每个栈帧对应一次函数调用，栈帧中包括这次函数调用中的形参值、一些控制信息、局部变量值和一些临时数据。**（<font color="#dd0000">**这看上去和Java的虚拟机栈类似**</font>)

**P91**：在将数据压入和弹出运行栈、确定要访问的形参和局部变量的地址是，都需要获得栈顶的地址，**因此需要一个专门的存储单元记录栈顶地址，**在1A-32中，<font color="#dd0000">**esp寄存器就是用来记录栈顶地址的，它称为栈指针**</font>。

但只有一个寄存器存储栈顶地址，有时还不够用，因为有些函数的栈帧大小是不确定的，这就会在函数返回前恢复栈指针时遇到麻烦，**因此还需要另外一个寄存器保存函数刚被调用时栈指针的位置**。在IA-32中这一任务由<font color="#dd0000">**ebp寄存器**</font>来完成，它被称为<font color="#dd0000">**帧指针**</font>。另外由于形参和局部变量相对于帧指针的位置肯定是确认的，函数的形参和局部变量地址通常通过**帧指针**来计算，而非**栈指针**。

**P94**：C++比C更安全的原因之一在于C语言允许在调用函数前只对函数进行不完整的声明——只声明函数名和返回类型，而不声明参数类型，C语言甚至允许在调用函数前根本不对函数加以声明。