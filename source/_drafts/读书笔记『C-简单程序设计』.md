---
title: 读书笔记『C++简单程序设计』
tags:
---

准备开始学习音视频开发，所以回顾一下已经完全忘光了的C++基础教程吧。



##第二章 C++简单程序设计

**P27**：字符串中的每个字符占一个字节，**并在末尾添加'\0'作为结尾标记**。

```c++
sizeof("abc"); //4
```

**P32**：sizeof运算符用于计算某个类型的对象在内存中所占的字节数。

**按位与&**

00000011 & 00000101 = 00000001

**按位或|**

00000011 | 00000101 = 00000111

**按位异或^**

00111001 ^ 00100011 = 00010011

**P37**："<<"是预定义的**插入符**，作用在流类对象cout上便可以实现最一般的屏幕输出。

```c++
cout<<表达式1<<表达式2
```

最一般的键盘输入是将提取符作用在流对象cin上，要求从键盘上输入两个int，**以空格分隔**。

```c++
int a,b;
cin>>a>>b;
```

**P53**：使用typedef为**一个已知的数据类型另外命名**，这样有利于提高程序的可读性，给较长的类型名起一个短名。

```c++
typedef 已有类型名 新类型名表；
```

## 第三章 函数

**P65**：如果希望在定义一个函数前调用它，则需要在调用函数之前添加该函数的**函数原型**声明。<font color="#dd0000">**这点是和java不一定的地方**</font>。

```c++
类型说明符 函数名(含类型说明的形参表)
```

**P78**：<font color="#dd0000">**引用是一种特殊类型的变量，可以被认为是另一个变量的别名，**</font>通过引用名和通过被引用的变量名访问变量的效果是一样的。

**P81**：<font color="#dd0000">**内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处**</font>，内联函数应该是比较简单的函数，结构简单、语句少。

```c++
inline 类型说明符 函数名(含类型说明的形参表) {
  语句序列
}
```

**P82**：函数在定义时可以预先声明默认的形参值，有默认值的形参，不能出现在没有默认值的形参的左边。

```c++
int add(int x=5,int y=6) {
  return x + y;
}
```

**P87**：**include进来的头文件，有前缀c的表示该头文件继承自标准C的头文件**。为了保持对C程序的兼容性，C++中也允许继续使用这些以.h为后缀的文件。保留这些头文件仅仅是处于兼容性考虑，在编写C++程序时，**应尽量使用不带.h后缀的头文件。**

**P90**：运行栈实际上是一段区域的内存空间，与存储全局变量的空间无异，只是寻址的方式不同而已。**运行栈中的数据分为一个一个栈帧，每个栈帧对应一次函数调用，栈帧中包括这次函数调用中的形参值、一些控制信息、局部变量值和一些临时数据。**（<font color="#dd0000">**这看上去和Java的虚拟机栈类似**</font>)

**P91**：在将数据压入和弹出运行栈、确定要访问的形参和局部变量的地址是，都需要获得栈顶的地址，**因此需要一个专门的存储单元记录栈顶地址，**在1A-32中，<font color="#dd0000">**esp寄存器就是用来记录栈顶地址的，它称为栈指针**</font>。

但只有一个寄存器存储栈顶地址，有时还不够用，因为有些函数的栈帧大小是不确定的，这就会在函数返回前恢复栈指针时遇到麻烦，**因此还需要另外一个寄存器保存函数刚被调用时栈指针的位置**。在IA-32中这一任务由<font color="#dd0000">**ebp寄存器**</font>来完成，它被称为<font color="#dd0000">**帧指针**</font>。另外由于形参和局部变量相对于帧指针的位置肯定是确认的，函数的形参和局部变量地址通常通过**帧指针**来计算，而非**栈指针**。

**P94**：C++比C更安全的原因之一在于C语言允许在调用函数前只对函数进行不完整的声明——只声明函数名和返回类型，而不声明参数类型，C语言甚至允许在调用函数前根本不对函数加以声明。

**P100**：多态性是指一段程序能够处理多种类型对象的能力。在C++语言中，这种多态性可以通过**强制多态、重载多态、类型参数化多态、包含多态**4种形式来实现。**包含多态和类型参数话多态属于一般多态性，是真正的多态**。<font color="#dd0000">**C++中采用虚函数实现包含多态。虚函数是多态性的精华，模板是C++实现参数化多态性的工具，分为函数模板和类模板两种**</font>。

**P104**：函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型。而函数的具体实现是卸载类定义之外。与普通函数不同的是，实现成员函数时需要指明类的名称。

类的成员函数是指那些把**定义和原型写在类定义内部的函数**，就像类定义中的其他变量一样。类成员函数是类的一个成员，**它可以操作类的任意对象，可以访问对象中的所有成员**。

**P114**：析构函数是在**对象的生存期即将结束的时候被自动调用的**。他的名称有类名前面加“~”构成，没有返回值。

```c++
class Clock {
  public:
  	Clock();
  	void setTime(int newH,int newW,int newS);
  	void showTime();
  	~Clock(){}
  private:
  	int hour,minute,second;
};
```

**P129**：<font color="#dd0000">**结构体是一种特殊形态的类**</font>，和类一样，可以有自己的数据成员和函数成员，可以有自己的构造函数和析构函数，可以控制访问权限，可以继承，支持包含多态等。和类唯一的区别在于，**结构体和类具有不同的默认访问控制属性：**<font color="#dd0000">**在类中，对于未指定的访问控制属性的成员，其访问控制属性为私有类型(private)；在结构体中，对于未指定任何访问控制属性的成员，其访问控制属性为公有类型(public)**</font>。C++引入结构体是为了保持和C程序的兼容性。

**P130**：如果一个结构体中只包含公共数据成员，且不包含自定义的构造方法，那么可以这么初始化结构体对象

```c++
struct Student {
  int num;
  String name;
  char sex;
  int age;
}

Student stu = {970089,"LinLin",'F',19};
```

**131**：联合体是和结构体类似的一种特殊形式的类，<font color="#dd0000">**联合体的全部数据成员共享同一组内存单元**</font>，联合体变量中的成员同时最多有一个是有意义的。联合体不能继承，也不支持包含多态。**一般联合体用来存储一些公有的数据，而不为它定义函数成员。**

**P137**：位域是一种允许将类中的多个数据成员打包，从而使不同成员可以<font color="#dd0000">**共享相同的字节的机制。**</font>

**P147**：类作用域

1. 如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m。
2. 通过表达式x.m或者<font color="#dd0000">**X::m**</font>。X::m的方式用于访问<font color="#dd0000">**静态成员**</font>。
3. **通过ptr->m这样的表达式，其中ptr为指向X类的一个对象的指针。**

**P148**：有两类特殊的命名空间——全局命名空间和匿名命名空间。全局命名空间就是默认的命名空间，**在显示声明的命名空间之外声明的标识符都在一个全局命名 空间中。**匿名命名空间是一个需要显示声明的没有名字的命名空间，<font color="#dd0000">**匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符，这是因为每个源文件的匿名命名空间是彼此不同的，在一个源文件中没有办法访问其他源文件的匿名命名空间。**</font>

```c++
//匿名命名空间
namespace {
  匿名命名空间内的各种声明
}
//using语句1
using 命名空间名::标识符名; //将指定标识符暴露在当前的作用域
using namespace 命名空间名; //将指定命名空间内所有标识符暴露在当前的作用域
```

**P159**：友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。

**P162**：友元关系不能传递的，友元关系是单向的，友元关系不能被继承。

**P164**：如果将一个对象说明为常对象，**则通过该对象只能调用它的常成员函数，而不能调用其他成员函数。**const关键字可以用于对重载函数的区分。

```c++
void print();
void print() const;
```

